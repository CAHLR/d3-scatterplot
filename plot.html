<!DOCTYPE html>
<html>
<meta charset="utf-8">

<!-- Example based on http://bl.ocks.org/mbostock/3887118 -->
<!-- Tooltip example from http://www.d3noob.org/2013/01/adding-tooltips-to-d3js-graph.html -->

<style>
body {
  font: 11px sans-serif;
}
.lasso path {
  stroke: rgb(80,80,80);
  stroke-width:2px;
}
.lasso .drawn {
  fill-opacity:.05 ;
}
.lasso .loop_close {
  fill:none;
  stroke-dasharray: 4,4;
}
.lasso .origin {
  fill:#3399FF;
  fill-opacity:.5;
}

.not_possible {
  fill:rgb(200,200,200);
}
.possible {
  fill:#EC888C;
}
.dot{
    stroke: #000;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.tooltip {
  position: absolute;
  width: 250px;
  height: 28px;
  background: rgba(255,255,255,0.80);
  pointer-events: none;
}
.tooltip1 {
  position: absolute;
  width: 100px;
  height:20px;
  background: rgba(255,255,255,0.9);
  pointer-events: none;
}

input{
  width: 185px;
  /*text-align: center;*/
}
.input1{
  width : 40px;
}
.input2{
  width : 230px;
  height : 25px;
}

.p1_coloring {
    margin-left: 20px;
    margin-top: 800px;
    position: absolute;
    font-size: 150%;
}
.select1_color{
    margin-left: 124px;
    margin-top: 800px;
    position: absolute;
}
.p1_coloring_spectrum_log {
    margin-left: 20px;
    margin-top: 825px;
    position: absolute;
    font-size: 150%;
}

.p2_searching {
    margin-left: 20px;
    margin-top: 1025px;
    position: absolute;
    font-size: 150%;
}
.select2_searching{
    margin-left: 140px;
    margin-top: 1025px;
    position: absolute;
}
.form2_searching {
    text-align: left;
    position: absolute;
    margin-left: 20px;
    margin-top: 1050px;
}

.p3_unknown {
    margin-left: 1000px;
    margin-top: 10px;
    position: absolute;
  white-space: nowrap;
    font-size: 150%;
}
.select3_table{
    position: absolute;
    margin-left: 50px;
    margin-top: 600px;
}
.form3_shaping_unsure__unused {
    text-align: left;
    position: absolute;
    margin-left: 680px;
    margin-top: 925px;
}

.p4_transparent {
    margin-left: 20px;
    margin-top: 1100px;
    position: absolute;
    font-size: 150%;
}
.select4_transparent{
    margin-left: 237px;
    margin-top: 1100px;
    position: absolute;
}
.form4_transparent {
    text-align: left;
    position: absolute;
    margin-left: 20px;
    margin-top: 1100px;
}

.p5_exact_match {
    margin-left: 20px;
    margin-top: 975px;
    position: absolute;
    font-size: 150%;
}

.p6_click {
    margin-left: 20px;
    margin-top: 875px;
    position: absolute;
    font-size: 150%;
}
.select6_click{
    margin-left: 190px;
    margin-top: 875px;
    position: absolute;
}

.p7_shaping {
    margin-left: 20px;
    margin-top: 925px;
    position: absolute;
    font-size: 150%;
}
.select7_shaping{
    margin-left: 140px;
    margin-top: 925px;
    position: absolute;
}

.p8_zoom {
    margin-left: 20px;
    margin-top: 750px;
    position: absolute;
    font-size: 150%;
}

.p9_circle {
    margin-left: 20px;
    margin-top: 700px;
    position: absolute;
    font-size: 150%;
}

.bar rect {
  fill: steelblue;
}
.bar text {
  fill: #fff;
  font: 10px sans-serif;
}
.div1 {
    position: absolute;    
    height: 400px;
    width: 600px;
    margin-left:1000px;
}
.div2 {
    position: absolute;
    margin-top: 400px;
    height: 400px;
    width: 600px;
    margin-left: 1000px;
}
#legend-svg {
    vertical-align: top;
}
.point {
  fill: steelblue;
  stroke: #000;
}
</style>
<body>
<!-- Text, instructions, and buttons -->
<p class="p9_circle"><b>Circle</b><input class="input1" type="checkbox" id="cbox4" value="fourth_checkbox"></input><input class = "input2" type="text" id="drawxy" placeholder="Select 1 pt after check"> </input> <button class = "input2" onclick="handleClick9()" value="Draw" >Draw</button></p>

<p class="p8_zoom"><b>Zoom</b><input class="input1" type="checkbox" id="cbox3" value="third_checkbox" onclick="handleClick8_checkZoom"></input><input class = "input2" type="text" id="zoomxy" placeholder="Select 2 pts after check"> </input> <button class = "input2" onclick="handleClick9()" value="Zoom" >Zoom</button></p>

<p class="p1_coloring" id="demo" ><b>Color by: </b></p>
<p class="p1_coloring_spectrum_log">Options: spectrum<input class="input1" type="checkbox" id="cbox1" value="first_checkbox" onclick="handleClick1()">log<input class="input1" type="checkbox" id="cbox2" value="second_checkbox" onclick="handleClick1()"></p>

<p class="p6_click"><b>Click on feature:</b></p>

<p class="p7_shaping"><b>Shape by: </b></p>

<p class="p5_exact_match"><b>Exact match:</b><input class="input1" type="checkbox" id="cbox5" value="fifth_checkbox"></input>(for search and transparent functions below) <button class = "input" onclick="handleClick5_checkExact()" value="Apply" >Apply</button></p>

<p class="p2_searching" id="demo2" ><b>Search by: </b></p>

<p class="p4_transparent" id="demo4" ><b>Transparent attribute: </b></p>

<p class="p3_unknown" id="demo3"></p>

<form name="form2_searching" class="form2_searching" onSubmit="return handleClick2()">
			<input type="text" id="myVal" placeholder="Search text">
      <input name="Submit"  type="submit" value="Apply" >
</form>

<form name="form4_transparent" class="form4_transparent" onSubmit="return handleClick4()">
			<label><p><br>Enter attribute value, and opacity values b/w 0 and 1:<br>(Currently doesn't work with simultaneously with search.)</p></label>
            <input type="text" id="myVal1" placeholder="Match attri. val">
			<input type="text" id="myVal2" placeholder="Opacity (match)">
			<input type="text" id="myVal3" placeholder="Opacity (no match)">
			<input name="Submit"  type="submit" value="Apply">
</form>

<!-- Imported JS -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="//d3js.org/d3-path.v0.1.min.js"></script>
<script src="//d3js.org/d3-shape.v0.6.min.js"></script>
<script src="http://axc.net/code_libraries/lasso/lasso.min.js"></script>
<script src="crossfilter.js"></script>


<!-- Our JS -->
<script>
  var margin = {top: 40, right: 40, bottom: 40, left: 40},
      width = 700 - margin.left - margin.right,
      height = 700 - margin.top - margin.bottom;

  // get dataset part of URL
  var query = window.location.search.substring(1);
  // split at &s, if any
  var temp_query = query.split("&");

  var dicts = {};
  var tvars;

  for(var i=0;i<temp_query.length;i++){
    // split "dataset" "filename.tsv"
  	tvars = temp_query[i].split("=");
  	dicts[tvars[0]] = tvars[1].replace(/%20/g, " ");
  }

  if ("dataset" in dicts) {
  	dataset = dicts["dataset"];
  }	else {
  	dataset = "joined_data.csv";
  }

  /* 
   * value accessor - returns the value to encode for a given data object.
   * scale - maps value to a visual display encoding, such as a pixel position.
   * map function - maps from data value to display value
   * axis - sets up axis
   */ 

  // setup x 
  var xValue = function(d) { return d.x;}, // data -> value
      xScale = d3.scale.linear().range([0, width]), // value -> display
      xMap = function(d) { 
  				return xScale(xValue(d));}, // data -> display
  			
      xAxis = d3.svg.axis().scale(xScale).orient("bottom");

  // setup y
  var yValue = function(d) { return d["y"];}, // data -> value
      yScale = d3.scale.linear().range([height, 0]), // value -> display
      yMap = function(d) { return yScale(yValue(d));}, // data -> display
      yAxis = d3.svg.axis().scale(yScale).orient("left");

  // add the tooltip area to the webpage
  var tooltip = d3.select("body").append("div")
  				.attr("class", "tooltip")
  				.style("opacity", 0);

  var tooltip1 = d3.select("body").append("div")
  				.attr("class", "tooltip1")
  				.style("opacity", 0);


  // to print all the values attributes                
  var print_array = function(arr, d) {
          var x = "";
          for (var i=0; i<arr.length; i++) {
              x = x + "<b>" + arr[i] + "</b>: " + d[arr[i]] + "<br>"
          }
          x = x + d.x + "<br>" + d["y"];
          return x;
      };


  // column for the transparent value
  var transparent_column="";
  var feature_column = "";
  var shaping_column = "";

  // setup fill color
  var category;
  var cValue = function(d) {
  	return d[category];
  }
  // logged version
  var cValue2 = function(d) {
  		return Math.log(parseFloat(d[category]));
  }
  var color = d3.scale.category20();


  var searchdic = function(arri, find) {
      for(var i=0;i<arri.length;i++) {
          if(JSON.stringify(find) === JSON.stringify(arri[i])){
              return false;
          }
      }
      return true;
  }

  // construct a table
  // INPUT data_tab array of dictionaries, 1 dictionary per datum
  // INPUT columns array of categories (column variables)
  var tabulate = function(data_tab, columns) {

      var table = d3.select("body").append("table")
              .attr("class", "select3_table"),
              thead = table.append("thead"),
              tbody = table.append("tbody");

      // append the header row
      thead.append("tr")
          .selectAll("th")
          .data(columns)
          .enter()
          .append("th")
              .text(function(column) { return column; });

      // create a row for each object in the data
      var rows = tbody.selectAll("tr")
          .data(data_tab)
          .enter()
          .append("tr");

      // create a cell in each row for each column
      var cells = rows.selectAll("td")
          .data(function(row) {
              return columns.map(function(column) {
                  return {column: column, value: row[column]};
              });
          })
          .enter()
          .append("td")
          .attr("style", "font-family: Courier") // sets the font style
              .html(function(d) { return d.value; });

          var output = "";
          var cf = crossfilter(data_tab);
          // jann: 11/1 for each column, columns[i], return the value of it for that datum
          for (var i=0;i<columns.length;i++) {
            console.log("columns[i] " + columns[i]);
              var byParty = cf.dimension(function(p) { return p[columns[i]]; }); 
              /*
                p is an array of dictionaries similar to

                var payments = crossfilter([
                  {date: "2011-11-14T16:17:54Z", quantity: 2, total: 190, tip: 100, type: "tab"},
                  {date: "2011-11-14T16:20:19Z", quantity: 2, total: 190, tip: 100, type: "tab"},
                  {date: "2011-11-14T16:28:54Z", quantity: 1, total: 300, tip: 200, type: "visa"},
                  {date: "2011-11-14T16:30:43Z", quantity: 2, total: 90, tip: 0, type: "tab"},
                  {date: "2011-11-14T16:48:46Z", quantity: 2, total: 90, tip: 0, type: "tab"},
                  {date: "2011-11-14T16:53:41Z", quantity: 2, total: 90, tip: 0, type: "tab"},
                  {date: "2011-11-14T16:54:06Z", quantity: 1, total: 100, tip: 0, type: "cash"},
                  {date: "2011-11-14T16:58:03Z", quantity: 2, total: 90, tip: 0, type: "tab"},
                  {date: "2011-11-14T17:07:21Z", quantity: 2, total: 90, tip: 0, type: "tab"},
                  {date: "2011-11-14T17:22:59Z", quantity: 2, total: 90, tip: 0, type: "tab"},
                  {date: "2011-11-14T17:25:45Z", quantity: 2, total: 200, tip: 0, type: "cash"},
                  {date: "2011-11-14T17:29:52Z", quantity: 1, total: 200, tip: 100, type: "visa"}
                ]);

                columns[i] returns a column name, like "username".
                p[columns[i]] seems odd to me
              */

              output = output + "<b>" +columns[i] + "</b>" + "<br>";
              var groupByParty = byParty.group();
                  groupByParty.top(5).forEach(function(p, i) {
                  output = output + p.key + ": " + p.value + "<br>";
                  console.log(p.key + ": " + p.value);
              });
              output = output + "<br>";
              console.log("i at " + i);

          }
          document.getElementById("demo3").innerHTML = output; 
          return table;
  }

  // create the dropdown menu
  var dropDown = d3.select("body").append("select")
                   .attr("class", "select1_color")
                   .attr("name", "category");

  var dropDown1_searching = d3.select("body").append("select")
                   .attr("class", "select2_searching")
                   .attr("name", "category");

  var dropDown2_transparent = d3.select("body").append("select")
                   .attr("class", "select4_transparent")
                   .attr("name", "category");

  var dropDown3_click = d3.select("body").append("select")
                   .attr("class", "select6_click")
                   .attr("name", "category");

  var dropDown4_shaping = d3.select("body").append("select")
                   .attr("class", "select7_shaping")
                   .attr("name", "category");

  // collecting categories
  var category_search_data = [];
  var categories = [];
  var category_search;
  // if in query
  if ("search" in dicts) {
  	category_search = dicts["search"]; // category_search = value we are searching by
  	category_search_data.push(category_search); // add desired search value to array
  }
  categories.push("Select"); // "Select" always first in categories
  // if in query
  if ("color" in dicts) {
  	category = dicts["color"]; // category is the color value
  	categories.push(category); // add color value to categories
  }	else {
  	category = "Select"; // if color is not in query, category is "Select", don't add anything to categories
  }

  var temp_cat = [];
  temp_cat.push(category); // temp_cat holds either color value or "Select"

  var columns = [];
  var temp = [];
  var x_max, x_min, y_max, y_min;

  // getting header files in csv file
  d3.tsv(dataset, function(data) {
    console.log(data[0]);
    temp = Object.keys(data[0]); // temp has all keys
    temp.splice(temp.indexOf('x'), 1); // remove x and y
    temp.splice(temp.indexOf('y'), 1);

    // add all other categories to category_search_data
    for(var i=0;i<temp.length;i++)
    	if (temp[i] != category_search) {
          category_search_data.push(temp[i]);
    	}
    // add all other categories to categories and temp_cat
    // add all categories to columns
    for(var i=0;i<temp.length;i++) {
    	if (temp[i] != category) {
          categories.push(temp[i]);
      	  temp_cat.push(temp[i]);
    	}
      columns.push(temp[i]);
    }

    if ("color" in dicts) {
      // since color would be first, start with next
  	  category = categories[1];
    } else {
  	  category = categories[0];
    }
    // take first (search value)
    category_search = category_search_data[0];
    dropDown1_searching.selectAll("option")
          .data(category_search_data)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    dropDown.selectAll("option")
          .data(temp_cat)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    dropDown2_transparent.selectAll("option")
          .data(temp_cat)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    dropDown3_click.selectAll("option")
          .data(temp_cat)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    dropDown4_shaping.selectAll("option")
          .data(temp_cat)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    shaping_column = "Select";
    feature_column = category_search_data[0];
    transparent_column = "Select";
  });

  dropDown.on("change", plotting);
  dropDown1_searching.on("change", plotting2);
  dropDown2_transparent.on("change", plotting3);
  dropDown3_click.on("change", plotting4);
  dropDown4_shaping.on("change", plotting5);

  if ("q" in dicts) {
      highlighting(dicts["q"], "", "");
  } else { 
      highlighting("", "", "");
  }
  function plotting4(){
  		feature_column = d3.event.target.value;
  }

  function plotting3(){
  		transparent_column = d3.event.target.value;
  }

  function plotting2(){
          category_search = d3.event.target.value;
  }

  // function to call for change event
  function plotting(){
  		// dropDown4_shaping.property( "value", "Select" );
  		category = d3.event.target.value;	
  		// shaping_column = "Select";
  		color = d3.scale.category20();
  		cValue = function(d) { return d[category];};
  		val = document.getElementById("myVal1").value; 
  		val1 = document.getElementById("myVal2").value; 
  		val2 = document.getElementById("myVal3").value;
  		highlighting(val, val1, val2);				
  }

  // function to call for change event
  function plotting5(){
  		// dropDown.property( "value", "Select" );
  		shaping_column = d3.event.target.value;	
  		color = d3.scale.category20();
  		cValue = function(d) { return d[category];};
  		val = document.getElementById("myVal1").value; 
  		val1 = document.getElementById("myVal2").value; 
  		val2 = document.getElementById("myVal3").value;
  		highlighting(val, val1, val2);				
  }

  var zoomed = 0;
  
  // log and spectrum events
  function handleClick1(){
      val = document.getElementById("myVal1").value; 
      val1 = document.getElementById("myVal2").value; 
      val2 = document.getElementById("myVal3").value;
      highlighting(val, val1, val2);
      // document.getElementById("zoomxy").value = ""
  }
  // search event: myVal from search option
  function handleClick2(event){
      console.log(document.getElementById("myVal").value);
      highlighting(document.getElementById("myVal").value, "", "");
      return false;
  }
  // transparent event myVal1-3 from transparent options
  function handleClick4(event){
      console.log(document.getElementById("myVal1").value);
      val = document.getElementById("myVal1").value; 
      val1 = document.getElementById("myVal2").value; 
      val2 = document.getElementById("myVal3").value;
      highlighting(val, val1, val2);
      return false;
  }
  function handleClick5_checkExact(event){
      val = document.getElementById("myVal1").value; 
      val1 = document.getElementById("myVal2").value; 
      val2 = document.getElementById("myVal3").value;
      highlighting(val, val1, val2);
  }
  function handleClick8_checkZoom(){
    if (!document.getElementById('cbox3').checked) {
      document.getElementById("zoomxy").value = ""; // clear the textbox
      // may possibly want to clear zoomx and zoomy, but
      // I don't think it's necessary
    }
  }
  // draw and zoom events
  function handleClick9(){
      val = document.getElementById("myVal1").value; 
      val1 = document.getElementById("myVal2").value; 
      val2 = document.getElementById("myVal3").value;
      highlighting(val, val1, val2);
    	// document.getElementById("zoomxy").value = ""
  }
  // currently unused
  function handleClickx(event){
      shaping_column = "Select";
      category = "Select";
      myForm.myVal.value = 0;
      myForm1.myVal1.value = 0;
      myForm1.myVal2.value = 0;
      myForm1.myVal3.value = 0;
      dropDown4_shaping.property( "value", "Select" );
      dropDown.property( "value", "Select" );
      highlighting("", "", "");
      return false;
  }
  function getParameterByName(name, url) {
      if (!url) {
          url = window.location.href;
      }
      name = name.replace(/[\[\]]/g, "\\$&");
      var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
              results = regex.exec(url);
      if (!results) return null;
      if (!results[2]) return '';
      return decodeURIComponent(results[2].replace(/\+/g, " "));
  }

  function linspace(start, end, n) {
      var out = [];
      var delta = (end - start) / (n - 1);

      var i = 0;
      while(i < (n - 1)) {
          out.push(start + (i * delta));
          i++;
      }

      out.push(end);
      return out;
  }
  // separate coordinate storage for zoom, s.t. front appending. may not be necessary if we can switch others to front appending as well.
  zoomx = [];
  zoomy = [];
  coordinatesx = [];
  coordinatesy = [];
  var scale_d = {
    'puOr11': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
    'spectral8': ['#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#e6f598', '#abdda4', '#66c2a5', '#3288bd'],
    'redBlackGreen': ['#ff0000', '#AA0000', '#550000', '#005500', '#00AA00', '#00ff00'],
	};
  scale = scale_d['spectral8'];

  /* >>>> START function for plotting (goes to end) <<<< */
  function highlighting(val, val1, val2) {
    var svg;
    var temp1 = [], temp2 = [], temp3_searching_var = [];
    var dict1 = {};
    
    document.getElementById("demo3").innerHTML = ""; 
    d3.select("svg").remove();
    d3.select("table").remove();
    d3.select("svg").remove();

  // function zoom() {
  // 	svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
  //		}

    svg = d3.select("body").append("svg")
    		.attr("width", width + margin.left + margin.right)
    		.attr("height", height + margin.top + margin.bottom)
  			.append("g")
  		  .attr("transform","translate(" + margin.left + "," + margin.top + ")");

    /* >>>> START lasso <<<< */
    var lasso_start = function() {
    d3.select("table").remove();
    document.getElementById("demo3").innerHTML = "";
    lasso.items()
        .attr("r",3.5) // reset size
        .style("fill",null) // clear all of the fills
        .classed({"not_possible":true,"selected":false}); // style as not possible
    };

    var lasso_draw = function() {
      // Style the possible dots
      lasso.items().filter(function(d) {return d.possible===true})
          .classed({"not_possible":false,"possible":true});

      // Style the not possible dot
      lasso.items().filter(function(d) {return d.possible===false})
          .classed({"not_possible":true,"possible":false})
          .style("stroke", "#000");
    };

    var lasso_end = function() {
      // Reset the color of all dots
      lasso.items()
           .style("fill", function(d) { return color(d[category]); });

      // Style the selected dots
      lasso.items().filter(function(d) {return d.selected===true})
          .classed({"not_possible":false,"possible":false})
          .attr("r",7)
          .style("stroke", "yellow")
          .style("stroke-width", 2)


      var zsx = lasso.items().filter(function(d) {return d.selected===true});
      x_values = [];
      y_values = [];
      for (var i=0; i<zsx[0].length; i++) {
          x_values.push(((((zsx[0][i].getBBox().x+6.5) * (x_max - x_min))/width + x_min )));
          y_values.push(((((zsx[0][i].getBBox().y+6.5) * (y_min - y_max))/height + y_max)));
      }       
      var selected_data=[];
      for (var ii=0;ii<x_values.length;ii++) {
          for (var jj=0;jj<temp1.length;jj++) {
              x_values[ii] = +(x_values[ii].toFixed(3));
              y_values[ii] = +(y_values[ii].toFixed(5));
              if ( (x_values[ii] === +(temp1[jj].toFixed(3))) && (y_values[ii] === +(temp2[jj].toFixed(5))) ) {
                  all_values = {};
                  for (var k=1;k<categories.length;k++) {
                      all_values[categories[k]] = (dict1[categories[k]][jj]);
                  }
                  if(searchdic(selected_data,all_values)==true){
                      selected_data.push(all_values);
                      break;
                  }
              }
          }
      }

      // render the table
      console.log("construct table? selected_data length: " + selected_data.length);
      if(selected_data.length != 0) {
          var peopleTable =  tabulate(selected_data, columns, x_values); // jann: causes error with my data
      }

      // Reset the style of the not selected dots
      lasso.items().filter(function(d) {return d.selected===false})
          .classed({"not_possible":false,"possible":false})
          .attr("r",3)
          .style("stroke", "#000");

    };

    // Create the area where the lasso event can be triggered
    var lasso_area = svg.append("rect")
                        .attr("width",width)
                        .attr("height",height)
                        .style("opacity",0);

    // Define the lasso
    var lasso = d3.lasso()
        .closePathDistance(75) // max distance for the lasso loop to be closed
        .closePathSelect(true) // can items be selected by closing the path?
        .hoverSelect(true) // can items by selected by hovering over them?
        .area(lasso_area) // area where the lasso can be started
        .on("start",lasso_start) // lasso start function
        .on("draw",lasso_draw) // lasso draw function
        .on("end",lasso_end); // lasso end function

    // Init the lasso on the svg:g that contains the dots
  	svg.call(lasso);
  	
    /* >>>> END lasso <<<< */


    /* >>>> START load data (goes to end) <<<< */
  	d3.tsv(dataset, function(error, data) {

    	// change string (from CSV) into number format
    	var numerics = {};
    	var symbol = {};
      for(var i=1;i<categories.length;i++) {
          dict1[categories[i]] = [];
  				numerics[categories[i]] = 0; // jann: previously = 1. Changed s.t. initialize to not numeric
      }
    	counter = 0;
      data.forEach(function(d) {
          d.x = +d.x
          d["y"] = +d["y"]
          for(var i=1;i<categories.length;i++){
            // jann: as long as one pt is numeric, set to numeric *may cause problems later
            if (!isNaN(parseFloat(d[categories[i]]))) {
              numerics[categories[i]] = 1;
              break;
            }
      		  // numerics[categories[i]] = numerics[categories[i]] && (d[categories[i]] == parseFloat(d[categories[i]]));
          }
      		if (!(d[shaping_column] in symbol)) {
      			symbol[d[shaping_column]] = counter;
      			counter = counter + 1;
      		}
          temp1.push(d.x);
          temp2.push(d["y"]);
          temp3_searching_var.push(d[category_search]);
      		// console.log(d["z"] == parseInt(d["z"]));
      });

      /* >>>> START Color with spectrum <<<< */
    	console.log(numerics);
    	console.log(category);
    	if (numerics[category] && document.getElementById('cbox1').checked) {
    		  console.log(category);
    	
          console.log(d3.min(data.map(function(d) {return Math.log(parseFloat(d[category])); })), d3.max(data.map(function(d) {return Math.log(parseFloat(d[category])); })));

    		if (document.getElementById('cbox2').checked) {
    				m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[category])); })));
    				m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[category])); })));
    		} else {
    				m1 = (d3.min(data.map(function(d) {return parseFloat(d[category])})));
    				m2 = (d3.max(data.map(function(d) {return parseFloat(d[category])})));
    		}

    		color = d3.scale.linear()
      	  .domain(linspace(m1, m2,scale.length))
      	//.domain(linspace(d3.min(data.map(function(d) {return parseInt(d[category])})), d3.max(data.map(function(d) {return parseInt(d[category])})),scale.length))
    			.range(scale);	
    	}
      /* >>>> END color with spectrum <<<< */

      /* >>>> START zoom <<<< */
      // don't want dots overlapping axis, so add in buffer to data domain
    	var zoom = getParameterByName('zoom');
    	if (document.getElementById("cbox3").checked==false) {
          document.getElementById("zoomxy").value = "";
          zoomed = 0;
          x_max = d3.max(data, xValue)+1;
          x_min = d3.min(data, xValue)-1;
          y_max = d3.max(data, yValue)+1;
          y_min = d3.min(data, yValue)-1; 
    	}

      // if (zoom != null) {
    	if (document.getElementById("cbox3").checked==true && zoomx.length >= 2) { // jann : previously required zoomed==0, but I want to allow zooming chains
    					
  				x_max = xScale.invert(Math.max(zoomx[0], zoomx[1]))+1;
  				x_min = xScale.invert(Math.min(zoomx[0], zoomx[1]))-1;
  				y_max = yScale.invert(Math.min(zoomy[0], zoomy[1]))+1;
  				y_min = yScale.invert(Math.max(zoomy[0], zoomy[1]))-1;

  				console.log(x_max, x_min, y_max, y_min);
  				document.getElementById("zoomxy").value = "X:["+parseInt(x_min)+", "+parseInt(x_max)+"] Y:["+parseInt(y_min)+", "+parseInt(y_max)+"]";
  				
  				zoomed = 1;
  				// document.getElementById("cbox3").checked = false;
  				/*
                    zoom = zoom.substr(1, zoom.length-2);
                    commaIndex = zoom.indexOf(',');
                    x_min = parseFloat(zoom.substr(0, commaIndex));
                    zoom = zoom.substr(commaIndex+1);
                    commaIndex = zoom.indexOf(',');
                    x_max = parseFloat(zoom.substr(0, commaIndex));
                    zoom = zoom.substr(commaIndex+1);
                    commaIndex = zoom.indexOf(',');
                    y_min = parseFloat(zoom.substr(0, commaIndex));
                    y_max = parseFloat(zoom.substr(commaIndex+1));
  				*/
      }
      /* >>>> END zoom <<<< */

      xScale.domain([x_min, x_max]);
      yScale.domain([y_min, y_max]);
    	// xScale.domain([d3.min(data, xValue)-1, d3.max(data, xValue)+1]);
      // yScale.domain([d3.min(data, yValue)-1, d3.max(data, yValue)+1]);
      cx = 0;
      cy = 0;
      ans = 0;
      // x-axis
      svg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis)
          .append("text")
          .attr("class", "label")
          .attr("x", width)
          .attr("y", -6)
          .style("text-anchor", "end")
          .text("");

      // y-axis
      svg.append("g")
          .attr("class", "y axis")
          .call(yAxis)
          .append("text")
          .attr("class", "label")
          .attr("transform", "rotate(-90)")
          .attr("y", 6)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .text("");

      /* >>>> START circle (conflict with zoom) <<<< */
    	if (document.getElementById("cbox4").checked==true && zoomed==0 && coordinatesx.length == 1) {
      		console.log(document.getElementById("drawxy").value);
      		draw = document.getElementById("drawxy").value;
      		draw = draw.split(',');
      		console.log("hello");
      		cx = coordinatesx[0]
      		cy = coordinatesy[0]
      		
      		coordinatesx[0] = xScale.invert(coordinatesx[0])
      		coordinatesy[0] = yScale.invert(coordinatesy[0])
      		console.log(coordinatesx, coordinatesy);
      		
      		for (var i=1 ; i <= 1000; i++) {		
      			c = 0;
      			t = 0;
      			f = i;
      			data.forEach(function(d) {
                  d.x = +d.x
                  d["y"] = +d["y"]
      			
        			// dist = Math.sqrt((d.x - coordinatesx[0])*(d.x - coordinatesx[0]) + (d["y"] - coordinatesy[0])*(d["y"] - coordinatesy[0]))
        			dist = Math.sqrt((xScale(d.x) - xScale(coordinatesx[0]))*(xScale(d.x) - xScale(coordinatesx[0])) + (yScale(d["y"]) - yScale(coordinatesy[0]))*(yScale(d["y"]) - yScale(coordinatesy[0])))
        			// console.log(dist)	
        			if (d[draw[1]] == draw[2]) {
        				if (dist <= f) {
          				c += 1;
          			}
          			t += 1;
        			}
      			});
        		console.log(c, t);
        		if (parseInt(c*100/t) >= 100*parseFloat(draw[0])) {
        				ans = f;
        				break;
        		}
      		}
      }
    	console.log(ans);	
    	if (ans != 0) {
        	console.log(xScale(ans))
        	svg.append("circle")
        		.attr("r", ans)
        		.attr("cx", cx)
        		.attr("cy", cy)
        		.style("stroke", "black") // set the line colour
        		.style("stroke-width", 5)
        		.style("fill", "green")
        		.style("opacity", .2);
    	}
      /* >>>> END circle (conflict with zoom) <<<< */

    	/* >>>> BEGIN transparent  <<<< */
    	if (transparent_column !== "Select" && val !== "" && val2 !== "") {
      		transparent_column = transparent_column.toString();
      		val = val.toString();
    	}
    	else {
      		val = val.toLowerCase();
    	}
    	
    	// transparency according to transparent column value
      // jann: this looks like it just returns 1...
      // jann: now unused
    	var transp = function(d){
          var x = val.length === 0;
          return x ? 1 : (searchFunc(d)-1 ? 1:1); // 0.65 yellow 
      };
    	/* >>>> END transparent function <<<< */

    	var transpar = function(d) {
      		if (val !== ""){
              var x;
              if (document.getElementById('cbox5').checked) { // exact match checked, case counts too
                x = d[transparent_column] == val; // if exact, x true
              } else {
                x = d[transparent_column] && (d[transparent_column].toLowerCase().indexOf(val) > -1); // if match, x true
              }
              return x ? parseFloat(val1) : parseFloat(val2);
      		}
      		else {
              return 1;
        			// return transp(d); // (jann: transp looks like it just returns 1...)
          }
  		};
    	
      // bring search highlight to front
      var searchFunc = function(d) {
          var x=d[category_search].toLowerCase().indexOf(val) < 0
          || val.length === 0;
          return x ? 1 : 2;
      };

      var searchFunc1_searching = function(d) {
        if (d) { // had to add a check for null values
          var x;
          if (document.getElementById('cbox5').checked) {
            x = d != val; // truthy if not equal (1 is not found, 2 is found)
          } else {
            x=d.toLowerCase().indexOf(val) < 0 || val.length === 0; // x = truthy if not found or if box empty
          }
          return x ? 1 : 2;
        }
        else {
            return 1;
        }
      };

      // iterate through the search variable values of dataset
      // fill temp dict with only matching results
      var searched_data = [], d_temp;
      for (var i=0;i<temp3_searching_var.length;i++) {
          if ( searchFunc1_searching(temp3_searching_var[i])-1 ) { // 0 if not found, 1 if found
              d_temp = {}; // dictionary of categories for this datum
              for(var j=1;j<categories.length;j++) { // fill each category with datum's value
                      d_temp[categories[j]] = dict1[categories[j]][i];
              }
              // checks not duplicate
              // jann : why? is this needed?
              if(searchdic(searched_data, d_temp) === true) { 
                  searched_data.push(d_temp);
              }
          }
      }
      if ( val != "" && searched_data.length != 0) {
          var peopleTable1 = tabulate(searched_data, columns);
      };
    	
    	var sizes = {}
    	
    	sizes[0] = ["0", "90", "0", "0"]
    	sizes[1] = ["0", "45", "0", "0"]
    	sizes[2] = ["0", "90", "0", "0"]
    	sizes[3] = ["0", "45", "0", "0"]
    	sizes[4] = ["0", "90", "0", "0"]
    	sizes[5] = ["0", "0", "0", "0"]

    	var symbols = ["diamond", "cross", "triangle-up", "square", "triangle-down","circle"];
    	
    	
    	/* >>>> BEGIN shape (draw dots) <<<< */
    	if (shaping_column !== "Select" ) {
    		// category = shaping_column;
    		svg.selectAll(".dot")
          .data(data)
        	.enter().append("path")
          .attr("class", "point")
      		// .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))
    		  .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}))
          .attr("transform", function(d) { return "translate(" + xMap(d) + "," + yMap(d) + ") rotate(" + sizes[parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + ")"; })
          .style("fill", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})
          .style("opacity",function(d) { return transpar(d);})
          .on("mouseover", function(d) {

              tooltip.transition()
                     .duration(200)
                     .style("opacity", 1);
              tooltip.html(
                      print_array(category_search_data, d))
                        .style("left", 60 + "px")
                        .style("top", 30 + "px");
            })
          .on("mouseout", function(d) {
        			d3.select(this).attr("r", function(d){ return searchFunc(d)-1 ? 7:3 ; })
        			 .style("fill", function(d) { return color(cValue(d));});
              tooltip.transition()
               .duration(500)
               .style("opacity", 0);
            })
      		.on("click", function(d) {
        			svg.append("text")
          			.text(d[feature_column])
          			.attr("x", (d3.event.pageX-50))
                .attr("y", (d3.event.pageY-35));
      		});	
    	}
    	else {
      	console.log(document.getElementById('cbox2').checked)	
        // draw dots
        // jann: changing the searched and transparency dots is here
    		marked = {}
        var nonSelected = svg.selectAll(".dot")
            .data(data, function(d) { return searchFunc(d)-1 ? null:d ; });

        console.log(nonSelected);
        // .filter(function(d, i) { return (searchFunc(d)-1 == 0); })
        var points = svg.selectAll(".dot")
          	.data(data)
        	  .enter()
        points.append("circle")
            .filter(function(d, i){ return (searchFunc(d)-1 == 0); })
            .attr("class", "dot")
          	.attr("r", 3)
            .style("stroke", "#000")
            .style("stroke-width", 1)
          	.attr("cx", xMap)
          	.attr("cy", yMap)
          	.style("fill", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})
            .style("opacity",function(d) { return transpar(d);})
          	
        		.on("mouseover", function(d) {
                tooltip.transition()
                       .duration(200)
                       .style("opacity", 1);
                tooltip.html(
                        print_array(category_search_data, d))
                          .style("left", 60 + "px")
                          .style("top", 30 + "px");
            })

      			.on("mouseout", function(d) {
          			tooltip.transition()
                       .duration(500)
                       .style("opacity", 0);
            })
           
    		    .on("click", function(d) {
            		console.log("Hello");
            		if (!([d3.event.pageX, d3.event.pageY] in marked)){
                		marked[[d3.event.pageX, d3.event.pageY]] = true;
                		marked[[d3.event.pageX-1, d3.event.pageY-1]] = true;
                		marked[[d3.event.pageX+1, d3.event.pageY+1]] = true;
                		marked[[d3.event.pageX-1, d3.event.pageY+1]] = true;
                		marked[[d3.event.pageX+1, d3.event.pageY-1]] = true;
                		marked[[d3.event.pageX+2, d3.event.pageY-2]] = true;
                		marked[[d3.event.pageX-2, d3.event.pageY-2]] = true;
                		marked[[d3.event.pageX-2, d3.event.pageY+2]] = true;
                		marked[[d3.event.pageX+2, d3.event.pageY+2]] = true;
                		svg.append("text")
                			.text(d[feature_column])
                			.attr("x", (d3.event.pageX-50))
                      .attr("y", (d3.event.pageY-35));
                			/*
                			tooltip1.transition()
                			   .attr("class", "tooltip1")
                               .style("opacity", 1);	
                			   
                			tooltip1.html("<b>"+d[feature_column]+"</b>")
                               .style("left", (d3.event.pageX + 10) + "px")
                               .style("top", (d3.event.pageY - 10) + "px");	
                			*/
    			      }
    		    });
            points.append("circle")
            .filter(function(d, i){ return (searchFunc(d)-1 == 1); })
            .attr("class", "dot")
            .attr("r", 7)
            .style("stroke", "yellow")
            .style("stroke-width", 2)
            .attr("cx", xMap)
            .attr("cy", yMap)
            .style("fill", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})
            .style("opacity",function(d) { return transpar(d);})
            // jann: here is the mouseover display
            .on("mouseover", function(d) {
                tooltip.transition()
                       .duration(200)
                       .style("opacity", 1);
                tooltip.html(
                        print_array(category_search_data, d))
                          .style("left", 60 + "px")
                          .style("top", 30 + "px");
            })

            .on("mouseout", function(d) {
                tooltip.transition()
                       .duration(500)
                       .style("opacity", 0);
            })
           
            .on("click", function(d) {
                console.log("Hello");
                if (!([d3.event.pageX, d3.event.pageY] in marked)){
                    marked[[d3.event.pageX, d3.event.pageY]] = true;
                    marked[[d3.event.pageX-1, d3.event.pageY-1]] = true;
                    marked[[d3.event.pageX+1, d3.event.pageY+1]] = true;
                    marked[[d3.event.pageX-1, d3.event.pageY+1]] = true;
                    marked[[d3.event.pageX+1, d3.event.pageY-1]] = true;
                    marked[[d3.event.pageX+2, d3.event.pageY-2]] = true;
                    marked[[d3.event.pageX-2, d3.event.pageY-2]] = true;
                    marked[[d3.event.pageX-2, d3.event.pageY+2]] = true;
                    marked[[d3.event.pageX+2, d3.event.pageY+2]] = true;
                    svg.append("text")
                      .text(d[feature_column])
                      .attr("x", (d3.event.pageX-50))
                      .attr("y", (d3.event.pageY-35));
                }
            });
    	}
      /* >>>> END shape (plotting the dots) <<<< */

      /* >>>> BEGIN click on feature <<<< */
    	svg.on("click",function() {
    		// svg.select("#myText").remove();

    		tooltip1.style("opacity", 0);
    		var coordinates1 = d3.mouse(this);
    		coordinatesx.push(coordinates1[0]);
    		coordinatesy.push(coordinates1[1]);
        zoomx.unshift(coordinates1[0]);
        zoomy.unshift(coordinates1[1]);
    		console.log(coordinatesx, coordinatesy);
    	})
      /* >>>> END click on feature <<<< */
    	
        
    	lasso.items(d3.selectAll(".dot"));
    	var len = color.domain().length;
    	// if spectrum is checked
    	if (numerics[category] && document.getElementById('cbox1').checked) {
    		
    		if (document.getElementById('cbox2').checked)
    		{
    			m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[category])); })));
    			m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[category])); })));
    		}
    		else {
    		m1 = (d3.min(data.map(function(d) {return parseFloat(d[category])})));
    		m2 = (d3.max(data.map(function(d) {return parseFloat(d[category])})));

    		}
    		console.log(m1, m2);
    		// create a scale and axis for the legend
    		var legend = svg.selectAll(".legend")
    			.data(color.domain())
    			.enter().append("g")
    			.attr("class", "legend");

    		var gradient = legend.append('defs')
                .append('linearGradient')
                .attr('id', 'gradient')
                .attr('x1', '0%') // bottom
                .attr('y1', '100%')
                .attr('x2', '0%') // to top
                .attr('y2', '0%')
                .attr('spreadMethod', 'pad');

    		var pct = linspace(0, 100, scale.length).map(function(d) {
                return Math.round(d) + '%';
            });

            var colourPct = d3.zip(pct, scale);
            colourPct.forEach(function(d) {
                gradient.append('stop')
                    .attr('offset', d[0])
                    .attr('stop-color', d[1])
                    .attr('stop-opacity', 1);
            });

    		legend.append('rect')
    				.attr('x1', 0)
    				.attr('y1', 0)
    				.attr('width', 18)
    				.attr('height', 150)
    				.attr("transform", "translate(" + 582 + ", 0)")
    				.style('fill', 'url(#gradient)');

            var legendScale = d3.scale.linear()
                .domain([m1, m2])
                .range([150, 0]);

            var legendAxis = d3.svg.axis()
                .scale(legendScale)
                .orient("right")
                // .tickValues([m1, m2])
                .ticks(10);

    		legend.append("g")
    			.attr("class", "legend axis")
                .attr("transform", "translate(" + 600 + ", 0)")
    			.call(legendAxis);
    	}
    	else {
    		var keys = Object.keys(symbol)
    		leng = keys.length;
    		if (leng<20 && shaping_column != "Select"){
    			// draw legend
    		
        	var legend = svg.selectAll(".legend")
        			.data(keys)
        			.enter().append("g")
        			// .attr("class", "legend");
        			// .attr("transform", function(d, i) { return "translate(30," + i * 20 + ")"; });
      		console.log(keys);
      		console.log(symbol);
      		console.log(symbols);
      		// draw legend colored rectangles
      		legend.append("path")
      			// .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}).size(function(d) {return sizes[parseInt(symbol[d]/6)%3];}))
      			.attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}))
      	
      			.attr("x", width + 0)
      			.attr("width", 18)
      			.attr("height", 18)
      			// .attr("transform", function(d, i) { return "translate(" + 20 + "," + i*20 + ")"; });
      			.attr("transform", function(d, i) { return "translate(" + 20 + "," + i*20 + ") rotate(" + sizes[parseInt(symbol[d]%6)][parseInt(symbol[d]/6)%4] + ")"; });
      		// draw legend text
      		legend.append("text")
      			// .attr("x", 100 + 0)
      			// .attr("y", 4)
      			.attr("dy", ".35em")
      			.style("text-anchor", "begin")
      			.text(function(d) { return d;})
      			.attr("transform", function(d, i) { return "translate(30," + i * 20 + ")"; });
    		}

    		if(len <= 30 && category != "Select"){

          // draw legend
        	var legend = svg.selectAll(".legend")
        		.data(color.domain())
        		.enter().append("g")
        		.attr("class", "legend")
        		.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });
        	// draw legend colored rectangles
        	legend.append("rect")
        		.attr("x", width + 6)
        		.attr("width", 18)
        		.attr("height", 18)
        		.style("fill", color);

        	// draw legend text
        	legend.append("text")
        		.attr("x", width + 0)
        		.attr("y", 9)
        		.attr("dy", ".35em")
        		.style("text-anchor", "end")
        		.text(function(d) { return d;});
    		}
      };
    }); /* >>>> Load data ends <<<< */
  } /* >>>> Function for plotting ends <<<< */
</script>
</body>
</html>
