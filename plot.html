<!DOCTYPE html>
<html>
<meta charset="utf-8">

<!-- Example based on http://bl.ocks.org/mbostock/3887118 -->
<!-- Tooltip example from http://www.d3noob.org/2013/01/adding-tooltips-to-d3js-graph.html -->

<!-- The css script below determines the appearance of the webpage -->
<style>
body {
  font: 11px sans-serif;
}
.lasso path {
  stroke: rgb(80,80,80);
  stroke-width:2px;
}
.lasso .drawn {
  fill-opacity:.05 ;
}
.lasso .loop_close {
  fill:none;
  stroke-dasharray: 4,4;
}
.lasso .origin {
  fill:#3399FF;
  fill-opacity:.5;
}
.not_possible {
  fill:rgb(200,200,200);
}
.possible {
  fill:#EC888C;
}
.dot{
    stroke: #000;
}
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
.tooltip {
  position: absolute;
  width: 250px;
  height: 28px;
  background: rgba(255,255,255,0.80);
  pointer-events: none;
}
.tooltip1 {
  position: absolute;
  width: 100px;
  height:20px;
  background: rgba(255,255,255,0.9);
  pointer-events: none;
}
/*The dropdown selectors*/
/*Coloring*/
.select1{
    margin-left: 122px;
    margin-top: 800px;
    position: absolute;
}
/*Searching*/
.select2{
    margin-left: 140px;
    margin-top: 975px;
    position: absolute;
}
/*?? Used in table in tabulate*/
.select3{
    position: absolute;
    margin-left: 50px;
    margin-top: 600px;
}
/*Transparent*/
.select4{
    margin-left: 237px;
    margin-top: 1075px;
    position: absolute;
}
/*Click on feature*/
.select5{
    margin-left: 190px;
    margin-top: 875px;
    position: absolute;
}
/*Shaping*/
.select6{
    margin-left: 135px;
    margin-top: 925px;
    position: absolute;
}
/*?? Default input textbox*/
input{
        width: 145px;
}
/*The checkbox*/
.input1{
  width : 40px;
}
/*Input textbox for circle and zoom*/
.input2{
  width : 180px;
  height : 25px;
}
/*Transparent*/
.form1 {
    text-align: left;
    position: absolute;
    margin-left: 20px;
    margin-top: 1125px;
}
/*Search*/
.form2 {
    text-align: left;
    position: absolute;
    margin-left: 20px;
    margin-top: 1025px;
}
/*Unused*/
.form3 {
    text-align: left;
    position: absolute;
    margin-left: 680px;
    margin-top: 850px;
}
/*Wrapper for each option*/
/*Coloring column*/
.p1 {
    margin-left: 20px;
    margin-top: 800px;
    position: absolute;
    font-size: 150%;
}
/*Searching column*/
.p2 {
    margin-left: 20px;
    margin-top: 975px;
    position: absolute;
    font-size: 150%;
}
/*Side table*/
.p3 {
    margin-left: 1000px;
    margin-top: 10px;
    position: absolute;
  white-space: nowrap;
    font-size: 150%;
}
/*Transparent column*/
.p4 {
    margin-left: 20px;
    margin-top: 1075px;
    position: absolute;
    font-size: 150%;
}
/*Spectrum and log*/
.p5 {
    margin-left: 20px;
    margin-top: 825px;
    position: absolute;
    font-size: 150%;
}
/*Click on feature*/
.p6 {
    margin-left: 20px;
    margin-top: 875px;
    position: absolute;
    font-size: 150%;
}
/*Shaping column*/
.p7 {
    margin-left: 20px;
    margin-top: 925px;
    position: absolute;
    font-size: 150%;
}
/*Zoom*/
.p8 {
    margin-left: 20px;
    margin-top: 750px;
    position: absolute;
    font-size: 150%;
}
/*Circle*/
.p9 {
    margin-left: 20px;
    margin-top: 700px;
    position: absolute;
    font-size: 150%;
}
/*Exact match - search*/
.p10 {
    margin-left: 20px;
    margin-top: 1000px;
    position: absolute;
    font-size: 150%;
}
/*Exact match - transparent*/
.p11 {
    margin-left: 20px;
    margin-top: 1100px;
    position: absolute;
    font-size: 150%;
}
.bar rect {
  fill: steelblue;
}
.bar text {
  fill: #fff;
  font: 10px sans-serif;
}
/*Never referenced - unused*/
.div1 {
    position: absolute;
    height: 400px;
    width: 600px;
    margin-left:1000px;
}
/*Never referenced - unused*/
.div2 {
    position: absolute;
    margin-top: 400px;
    height: 400px;
    width: 600px;
    margin-left: 1000px;
}
/*Never referenced - unused*/
#legend-svg {
            vertical-align: top;
}
.point {
  fill: steelblue;
  stroke: #000;
}
</style>
<body>

<p class="p9"><b>Circle</b><input class="input1" type="checkbox" id="cbox4" value="fourth_checkbox"></input><input class = "input2" type="text" id="drawxy" placeholder="Select 1 pt after check"> </input> <button class = "input2" onclick="handleClick4()" value="Draw" >Draw</button></p>

<p class="p8"><b>Zoom</b><input class="input1" type="checkbox" id="cbox3" value="third_checkbox"></input><input class = "input2" type="text" id="zoomxy" placeholder="Select 2 pts after check"> </input> <button class = "input2" onclick="handleClick4()" value="Zoom" >Zoom</button></p>

<p class="p1" id="demo" ><b>Color by: </b></p>
<p class="p5">Options: spectrum<input class="input1" type="checkbox" id="cbox1" value="first_checkbox" onclick="handleClick3()">log<input class="input1" type="checkbox" id="cbox2" value="second_checkbox" onclick="handleClick3()"></p>


<p class="p6"><b>Click on feature: </b></p>

<p class="p7"><b>Shape by: </b></p>


<p class="p2" id="demo2" ><b>Search by: </b></p>
<p class="p10">Exact match: <input class="input1" type="checkbox" id="cbox5" value="fifth_checkbox" onclick="handleCheck()"></p>

<p class="p4" id="demo4" ><b>Transparent attribute: </b></p>
<p class="p11">Exact match: <input class="input1" type="checkbox" id="cbox6" value="sixth_checkbox" onclick="handleCheck1()"></p>

<!-- Side Table -->
<p class="p3" id="demo3"></p>


<!-- The handleClick() function will be executed when the search button is pressed  -->
<form name="myform" class="form2" onSubmit="return handleClick()">
      <input type="text" id="myVal" placeholder="Search text">
      <input name="Submit"  type="submit" value="Apply" >
</form>

<!-- The handleClick1() function will be executed when the transparent button is pressed  -->
<form name="myform1" class="form1" onSubmit="return handleClick1()">
      <p>Enter attribute value, and opacity values b/w 0 and 1: <br>(Currently doesn't work simultaneously with search.)</p>
      <input type="text" id="myVal1" placeholder="Match attri. val">
      <input type="text" id="myVal2" placeholder="Opacity (match)">
      <input type="text" id="myVal3" placeholder="Opacity (no match)">
      <input name="Submit"  type="submit" value="Apply">
</form>

<!-- These javascript modules are used to draw the interactive plot  -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="//d3js.org/d3-path.v0.1.min.js"></script>
<script src="//d3js.org/d3-shape.v0.6.min.js"></script>
<script src="http://axc.net/code_libraries/lasso/lasso.min.js"></script>
<script src="crossfilter.min.js"></script>
<script>

// The location of svg plot is determined by the following margins
var margin = {top: 40, right: 40, bottom: 40, left: 40},
    width = 700 - margin.left - margin.right,
    height = 700 - margin.top - margin.bottom;

// This step is performed to parse the url to identify the dataset and the default coloring column
var query = window.location.search.substring(1);
var temp_query = query.split("&");
var dicts = {};
var tvars;
for(var i=0;i<temp_query.length;i++) {
  tvars = temp_query[i].split("=");
  dicts[tvars[0]]=tvars[1].replace(/%20/g, " ");
}
if ("dataset" in dicts) {
  dataset = dicts["dataset"];
} else {
  dataset = "joined_data.csv";
}

/*
 * value accessor - returns the value to encode for a given data object.
 * scale - maps value to a visual display encoding, such as a pixel position.
 * map function - maps from data value to display value
 * axis - sets up axis
 */

// setup x
var xValue = function(d) { return d.x;}, // data -> value
    xScale = d3.scale.linear().range([0, width]), // value -> display
    xMap = function(d) {return xScale(xValue(d));}, // data -> display
    xAxis = d3.svg.axis().scale(xScale).orient("bottom");

// setup y
var yValue = function(d) { return d["y"];}, // data -> value
    yScale = d3.scale.linear().range([height, 0]), // value -> display
    yMap = function(d) { return yScale(yValue(d));}, // data -> display
    yAxis = d3.svg.axis().scale(yScale).orient("left");

// add the tooltip area to the webpage
var tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

var tooltip1 = d3.select("body").append("div")
        .attr("class", "tooltip1")
        .style("opacity", 0);

// to print all the key values pairs of a point (used to display the summary on the webpage)
var print_array = function(arr, d) {
        var x = "";
        for (var i=0; i<arr.length; i++) {
            x = x + "<b>" + arr[i] + "</b>: " + d[arr[i]] + "<br>"
        }
        x = x + d.x + "<br>" + d["y"];
        return x;
};

// setup fill color
var category;

// column for the transparent value
var transparent_column = "";
var feature_column = "";
var shaping_column = "";

// coloring will be done according to the values determined by cValue
var cValue = function(d) {return d[category];},
    cValue2 = function(d) {return Math.log(parseFloat(d[category]));},
    color = d3.scale.category20();

// used to search a particular substring in the list of requested feature column
// used to determine whether we should add find to arri, hence the t/f -> f/t
var searchdic = function(arri, find) {
    for(var i=0;i<arri.length;i++) {
        if(JSON.stringify(find) === JSON.stringify(arri[i])){
            return false;
        }
    }
    return true;
}

// displays the summary in tabular form
var tabulate = function(data_tab, columns) {

    var table = d3.select("body").append("table")
            .attr("class", "select3"),
        thead = table.append("thead"),
        tbody = table.append("tbody");

    // append the header row
    thead.append("tr")
        .selectAll("th")
        .data(columns)
        .enter()
        .append("th")
            .text(function(column) { return column; });

    // create a row for each object in the data
    var rows = tbody.selectAll("tr")
        .data(data_tab)
        .enter()
        .append("tr");

    // create a cell in each row for each column
    var cells = rows.selectAll("td")
        .data(function(row) {
            return columns.map(function(column) {
                return {column: column, value: row[column]};
            });
        })
        .enter()
        .append("td")
        .attr("style", "font-family: Courier") // sets the font style
        .html(function(d) { return d.value; });

    /*
      crossfilter dimensions and group by
      http://animateddata.co.uk/articles/crossfilter/
    */
    var output = "";
    var cf = crossfilter(data_tab);
    /* crossfilter currently only supports up to 32 columns) */
    for (var i=0;i<columns.length && i<32;i++) {
        var byParty = cf.dimension(function(p) {
            return p[columns[i]]; });
        output = output + "<b>" +columns[i] + "</b>" + "<br>";
        var groupByParty = byParty.group();
        groupByParty.top(5).forEach(function(p, i) {
            output = output + p.key + ": " + p.value + "<br>";
            console.log(p.key + ": " + p.value);
        });
        output = output + "<br>";
    }
    // side table
    document.getElementById("demo3").innerHTML = output;
    return table;
}

// create the dropdown menu
// Coloring
var dropDown = d3.select("body").append("select")
                 .attr("class", "select1")
                 .attr("name", "category");

// Searching
var dropDown1 = d3.select("body").append("select")
                 .attr("class", "select2")
                 .attr("name", "category");

// Transparent
var dropDown2 = d3.select("body").append("select")
                 .attr("class", "select4")
                 .attr("name", "category");

// Click on feature
var dropDown3 = d3.select("body").append("select")
                 .attr("class", "select5")
                 .attr("name", "category");

// Shaping
var dropDown4 = d3.select("body").append("select")
                 .attr("class", "select6")
                 .attr("name", "category");

var category_search_data = [];
// categories stores the name of all the columns
var categories = [];
// category_search stores the name of column according to which searching is to be done
var category_search;


// check whether the searching column is provided in the url or not
if ("search" in dicts) {
  category_search = dicts["search"];
  category_search_data.push(category_search);
}
categories.push("Select");

// category stores the name of column according to which coloring is to be done
// check whether the coloring column is provided in the url or not
if ("color" in dicts) {
  category = dicts["color"];
  categories.push(category);
} else {
  category = "Select";
}

// temp_cat is just the copy of categories
var temp_cat = [];
temp_cat.push(category);

var columns = [];
var temp = [];
var x_max, x_min, y_max, y_min;

// getting header from csv file to make drowdown menus
d3.tsv(dataset, function(data) {
    console.log(data[0]);
    temp = Object.keys(data[0]);
    // remove x and y
    temp.splice(temp.indexOf('x'), 1);
    temp.splice(temp.indexOf('y'), 1);

    for(var i=0;i<temp.length;i++)
        if (temp[i] != category_search) {
            category_search_data.push(temp[i]);
        }

    for(var i=0;i<temp.length;i++) {
        // category already pushed
        if (temp[i] != category) {
            categories.push(temp[i]);
            temp_cat.push(temp[i]);
        }
        columns.push(temp[i]);
    }
    // check whether the coloring column is provided in the url or not
    // ?? is this necessary? category is already defined with the same procedure outside the function
    if ("color" in dicts) {
      category = categories[1]; // since color would be first, start with next
    } else {
      // "Select"
      category = categories[0];
    }
    category_search = category_search_data[0];
    // Searching
    dropDown1.selectAll("option")
          .data(category_search_data)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    // Coloring
    dropDown.selectAll("option")
          .data(temp_cat)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    // Transparent
    dropDown2.selectAll("option")
          .data(temp_cat)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    // Click on feature
    dropDown3.selectAll("option")
          .data(temp_cat)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    // Shaping
    dropDown4.selectAll("option")
          .data(temp_cat)
          .enter()
          .append("option")
          .text(function(d) { return d;})
          .text(function(d) {return d;});
    shaping_column = "Select";
    feature_column = category_search_data[0];
    transparent_column = "Select";
});

// whenever any one of the drowdown menu's selected column is changes the plot is generated according to the value of dropdown menu selected
// Coloring
dropDown.on("change", plotting);
// Searching
dropDown1.on("change", plotting2);
// Transparent
dropDown2.on("change", plotting3);
// Click on feature
dropDown3.on("change", plotting4);
// Shaping
dropDown4.on("change", plotting5);

if ("q" in dicts) {
    highlighting(dicts["q"], "", "");
} else {
    highlighting("", "", "");
}

// the functions to call when the value of dropdown menu is changes
// Click on feature
function plotting4(){
    feature_column = d3.event.target.value;
}
// Transparent
function plotting3(){
    transparent_column = d3.event.target.value;
}
// Searching
function plotting2(){
    category_search = d3.event.target.value;
}

// function to call for change event
// Coloring
function plotting(){
    // dropDown4.property( "value", "Select" );
    category = d3.event.target.value;
    // shaping_column = "Select";
    // color = d3.scale.category20();
    cValue = function(d) { return d[category];};
    val = document.getElementById("myVal1").value;
    val1 = document.getElementById("myVal2").value;
    val2 = document.getElementById("myVal3").value;
    highlighting(val, val1, val2);
}

// function to call for change event
// Shaping
function plotting5(){

    // dropDown.property( "value", "Select" );
    shaping_column = d3.event.target.value;
    // color = d3.scale.category20();
    cValue = function(d) { return d[category];};
    val = document.getElementById("myVal1").value;
    val1 = document.getElementById("myVal2").value;
    val2 = document.getElementById("myVal3").value;
    highlighting(val, val1, val2);
}

var zoomed = 0;
var needZoom = false;
var needDrawCircle = false;
/* ?? why do some of the following handlers have return false? */
// search event
// it will be executed when search button is pressed and points that matches the searched string will be highlighted
function handleClick(event) {
    console.log(document.getElementById("myVal").value);
    highlighting(document.getElementById("myVal").value, "", "");
    return false;
}
function handleCheck(event) {
    if (document.getElementById("myVal").value) {
        handleClick();
    }
}

// transparent event
// it will be executed when Transparent button is pressed and points that satisfies the condition will be highlighted
function handleClick1(event) {
    console.log(document.getElementById("myVal1").value);
    val = document.getElementById("myVal1").value;
    val1 = document.getElementById("myVal2").value;
    val2 = document.getElementById("myVal3").value;
    highlighting(val, val1, val2);
    return false;
}
function handleCheck1(event) {
    if (document.getElementById("myVal1").value) {
        handleClick1();
    }
}

// ?? I believe this function is unused, and draw also maps to handleClick4
// it will be executed when Draw button is pressed and the plot will highlight those points that covers fixed percentage of point from the point obtained by mouse click
function handleClick2(event){
        shaping_column = "Select";
        category = "Select";
        myForm.myVal.value = 0;
        myForm1.myVal1.value = 0;
        myForm1.myVal2.value = 0;
        myForm1.myVal3.value = 0;
        dropDown4.property( "value", "Select" );
        dropDown.property( "value", "Select" );
        highlighting("", "", "");
        return false;
}

// spectrum / log event
// it will be executed when spectrum/log is checked
// ?? Can we collapse handleClick1,3,4?
function handleClick3(event) {
    val = document.getElementById("myVal1").value;
    val1 = document.getElementById("myVal2").value;
    val2 = document.getElementById("myVal3").value;
    highlighting(val, val1, val2);
}

// it will be executed when (?? draw and) zoom button is pressed and the plot will zoomed out according to the points obtained by mouse click event
function handleClick4(){
    if (!document.getElementById('cbox3').checked) {
      document.getElementById("zoomxy").value = ""; // clear the textbox
    }
    val = document.getElementById("myVal1").value;
    val1 = document.getElementById("myVal2").value;
    val2 = document.getElementById("myVal3").value;
    needZoom = true;
    highlighting(val, val1, val2);
}



// Checks the url query for name=value and extracts the value
function getParameterByName(name, url) {
    if (!url) {
        url = window.location.href;
    }
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
            results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}

function linspace(start, end, n) {
    var out = [];
    var delta = (end - start) / (n - 1);
    var i = 0;
    while(i < (n - 1)) {
        out.push(start + (i * delta));
        i++;
    }
    out.push(end);
    return out;
}

coordinatesx = [];
coordinatesy = [];

// provides different colored spectrum
var scale_d = {
    'puOr11': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
    'spectral8': ['#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#e6f598', '#abdda4', '#66c2a5', '#3288bd'],
    'redBlackGreen': ['#ff0000', '#AA0000', '#550000', '#005500', '#00AA00', '#00ff00'],
};
scale = scale_d['spectral8'];

// function for plotting
function highlighting(val, val1, val2) {

    var svg;
    var temp1 = [], temp2 = [], temp3 = [];
    var dict1 = {};

    // to remove the existing svg plot if any
    // clear side table
    document.getElementById("demo3").innerHTML = "";
    d3.select("svg").remove();
    d3.select("table").remove();
    d3.select("svg").remove();

    // function zoom() {
    //  svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    //    }

    // the location of svg image will be determined
    svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform","translate(" + margin.left + "," + margin.top + ")");

    /* https://github.com/skokenes/D3-Lasso-Plugin
       plugin also handles selected and possible settings */
    // Lasso starts
    var lasso_start = function() {
        d3.select("table").remove();
        document.getElementById("demo3").innerHTML = "";
        lasso.items()
            .attr("r",3.5) // reset size
            .style("fill",null) // clear all of the fills (greys out)
            .classed({"not_possible":true,"selected":false}); // style as not possible
    };

    var lasso_draw = function() {
        // Style the possible dots
        lasso.items().filter(function(d) {return d.possible===true})
            .classed({"not_possible":false,"possible":true});

        // Style the not possible dot
        lasso.items().filter(function(d) {return d.possible===false})
            .classed({"not_possible":true,"possible":false})
            .style("stroke", "#000");
    };

    var lasso_end = function() {
        // Reset the color of all dots
        lasso.items()
             .style("fill", function(d) { return color(d[category]); });

        // Style the selected dots
        lasso.items().filter(function(d) {return d.selected===true})
            .classed({"not_possible":false,"possible":false})
            .attr("r",6.5);

        // get values for table -> array inside a list
        var zsx = lasso.items().filter(function(d) {return d.selected===true});
        x_values = [];
        y_values = [];
        // adjust the x and y values
        for (var i=0; i<zsx[0].length; i++) {
            x_values.push(((((zsx[0][i].getBBox().x+6.5) * (x_max - x_min))/width + x_min )));
            y_values.push(((((zsx[0][i].getBBox().y+6.5) * (y_min - y_max))/height + y_max)));
        }
        var selected_data=[];

        // Compare every selected point to all points (tempX)
        // in order to match coordinates with actual data
        for (var ii=0;ii<x_values.length;ii++) {
            console.log("lasso_end gathering selected data");
            console.log(temp1.length);
            for (var jj=0;jj<temp1.length;jj++) {
                x_values[ii] = +(x_values[ii].toFixed(3));
                y_values[ii] = +(y_values[ii].toFixed(5));
                if ( (x_values[ii] === +(temp1[jj].toFixed(3))) && (y_values[ii] === +(temp2[jj].toFixed(5))) ) {
                    all_values = {};
                    for (var k=1;k<categories.length;k++) {
                        all_values[categories[k]] = (dict1[categories[k]][jj]);
                    }
                    if(searchdic(selected_data,all_values)==true){
                        selected_data.push(all_values);
                        break;
                    }
                }
            }
        }

        // render the table for the points selected by lasso
        if(selected_data.length != 0) {
            console.log("about to tabulate");
            console.log(selected_data);
            console.log(columns);
            console.log(x_values);
            var peopleTable = tabulate(selected_data, columns, x_values);
        }

        // Reset the style of the not selected dots (we made them 0.5 smaller)
        lasso.items().filter(function(d) {return d.selected===false})
            .classed({"not_possible":false,"possible":false})
            .attr("r",3)
            .style("stroke", "#000");
    };

    // Create the area where the lasso event can be triggered
    var lasso_area = svg.append("rect")
                        .attr("width",width)
                        .attr("height",height)
                        .style("opacity",0);

    // Define the lasso
    var lasso = d3.lasso()
        .closePathDistance(75) // max distance for the lasso loop to be closed
        .closePathSelect(true) // can items be selected by closing the path?
        .hoverSelect(true) // can items by selected by hovering over them?
        .area(lasso_area) // area where the lasso can be started
        .on("start",lasso_start) // lasso start function
        .on("draw",lasso_draw) // lasso draw function
        .on("end",lasso_end); // lasso end function

    // Init the lasso object on the svg:g that contains the dots
    svg.call(lasso);

    // load data
    d3.tsv(dataset, function(error, data) {

        // change string (from CSV) into number format
        var numerics = {};
        var symbol = {};
        //Omitting Select (0)
        for(var i=1;i<categories.length;i++) {
            // initialize the value for each category key to empty list
            dict1[categories[i]] = [];
            // initialize all categories as numeric
            numerics[categories[i]] = 1;
        }
        counter = 0;
        data.forEach(function(d) {
            // coerce the data to numbers
            d.x = +d.x
            d["y"] = +d["y"]

            for(var i=1;i<categories.length;i++){
                // add every attribute of point to the {category:[val1,val2,...]}
                dict1[categories[i]].push(d[categories[i]]);
                // revoke a category's numerics status if find an entry has a non-Int or non-null value for that category
                numerics[categories[i]] = numerics[categories[i]] && (d[categories[i]] == "" || d[categories[i]] == parseFloat(d[categories[i]]));
                /* the following was causing problems */
                // any non-empty non-numeric will forever set that category to false
                // if (!numerics[categories[i]]) {
                //     break;
                // }
            }
            // fill the symbol dictionary with all possible values of the shaping column as keys
            // value is the order of points
            if (!(d[shaping_column] in symbol)) {
                symbol[d[shaping_column]] = counter;
                counter = counter + 1;
            }
            // push all x values, y values, and all category search values into temp1/2/3
            temp1.push(d.x);
            temp2.push(d["y"]);
            temp3.push(d[category_search]);
          // console.log(d["z"] == parseInt(d["z"]));
        });
        console.log(numerics);
        console.log(category);
        // set color according to spectrum
        if (numerics[category] && document.getElementById('cbox1').checked) {
            // take log if log checkbox checked
            if (document.getElementById('cbox2').checked) {
                m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[category])); })));
                m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[category])); })));
            } else{
                m1 = (d3.min(data.map(function(d) {return parseFloat(d[category])})));
                m2 = (d3.max(data.map(function(d) {return parseFloat(d[category])})));
            }

            console.log(m1, m2);

            color = d3.scale.linear()
               .domain(linspace(m1, m2,scale.length))
              //.domain(linspace(d3.min(data.map(function(d) {return parseInt(d[category])})), d3.max(data.map(function(d) {return parseInt(d[category])})),scale.length))
              .range(scale);
        } else {
            color = d3.scale.category20();
        }

        // don't want dots overlapping axis, so add in buffer to data domain
        var zoom = getParameterByName('Zoom'); // unused, capitalized Z anyway as changed above

        if (document.getElementById("cbox3").checked==false) {
            document.getElementById("zoomxy").value = "";
            zoomed = 0;
            needZoom = false;
            x_max = d3.max(data, xValue)+1;
            x_min = d3.min(data, xValue)-1;
            y_max = d3.max(data, yValue)+1;
            y_min = d3.min(data, yValue)-1;
        }

        // if zoom is checked and conditions are satisfied
        if (document.getElementById("cbox3").checked==true  && needZoom == true && coordinatesx.length >= 2) {

            x_max = xScale.invert(Math.max(coordinatesx[0], coordinatesx[1]))+1;
            x_min = xScale.invert(Math.min(coordinatesx[0], coordinatesx[1]))-1;
            y_max = yScale.invert(Math.min(coordinatesy[0], coordinatesy[1]))+1;
            y_min = yScale.invert(Math.max(coordinatesy[0], coordinatesy[1]))-1;

            console.log(x_max, x_min, y_max, y_min);
            document.getElementById("zoomxy").value = "X:["+parseInt(x_min)+", "+parseInt(x_max)+"] Y:["+parseInt(y_min)+", "+parseInt(y_max)+"]";

            zoomed = 1;
            needZoom = false;
                // document.getElementById("cbox3").checked = false;
                /*
                          zoom = zoom.substr(1, zoom.length-2);
                          commaIndex = zoom.indexOf(',');
                          x_min = parseFloat(zoom.substr(0, commaIndex));
                          zoom = zoom.substr(commaIndex+1);
                          commaIndex = zoom.indexOf(',');
                          x_max = parseFloat(zoom.substr(0, commaIndex));
                          zoom = zoom.substr(commaIndex+1);
                          commaIndex = zoom.indexOf(',');
                          y_min = parseFloat(zoom.substr(0, commaIndex));
                          y_max = parseFloat(zoom.substr(commaIndex+1));
                */
        }
        xScale.domain([x_min, x_max]);
        yScale.domain([y_min, y_max]);

        // xScale.domain([d3.min(data, xValue)-1, d3.max(data, xValue)+1]);
          // yScale.domain([d3.min(data, yValue)-1, d3.max(data, yValue)+1]);

        // x-axis
        cx = 0;
        cy = 0;
        ans = 0;

        // check whether the circle checkbox is selected or not
        // ?? may want to allow coordinatesx.length >= 1
        if (document.getElementById("cbox4").checked==true && zoomed==0 && coordinatesx.length == 1) {
            console.log(document.getElementById("drawxy").value);
            draw = document.getElementById("drawxy").value;
            draw = draw.split(',');
            cx = coordinatesx[0]
            cy = coordinatesy[0]

            /*
              invert: Given a value from the range, returns the corresponding value from the domain.
              Inversion is useful for interaction, say to determine the data value corresponding to the position of the mouse.
            */
            console.log("before invert");
            console.log(coordinatesx[0], coordinatesy[0]);
            coordinatesx[0] = xScale.invert(coordinatesx[0])
            coordinatesy[0] = yScale.invert(coordinatesy[0])
            console.log("after invert");
            console.log(coordinatesx[0], coordinatesy[0]);
            console.log(coordinatesx, coordinatesy);

            for (var i=1 ; i <= 1000; i++) {
                c = 0;
                t = 0;
                f = i;
                data.forEach(function(d) {
                    d.x = +d.x
                    d["y"] = +d["y"]

                    // dist = Math.sqrt((d.x - coordinatesx[0])*(d.x - coordinatesx[0]) + (d["y"] - coordinatesy[0])*(d["y"] - coordinatesy[0]))
                    dist = Math.sqrt((xScale(d.x) - xScale(coordinatesx[0]))*(xScale(d.x) - xScale(coordinatesx[0])) + (yScale(d["y"]) - yScale(coordinatesy[0]))*(yScale(d["y"]) - yScale(coordinatesy[0])))
                    // console.log(dist)
                    if (d[draw[1]] == draw[2]) {
                        if (dist <= f) {
                            c += 1;
                        }
                        t += 1;
                    }
                });
                // console.log(c, t);
                if (parseInt(c*100/t) >= 100*parseFloat(draw[0])) {
                    ans = f;
                    break;
                }

            }
        }
        console.log(ans);
        if (ans != 0) {
            console.log(xScale(ans))
            svg.append("circle")
              .attr("r", ans)
              .attr("cx", cx)
              .attr("cy", cy)
              .style("stroke", "black")    // set the line colour
              .style("stroke-width", 5)
              .style("fill", "green")
              .style("opacity", .2);
        }

        // draw the x-axis of plot
        svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
          .append("text")
            .attr("class", "label")
            .attr("x", width)
            .attr("y", -6)
            .style("text-anchor", "end")
            .text("");

        // draw the y-axis of plot
        svg.append("g")
            .attr("class", "y axis")
            .call(yAxis)
          .append("text")
            .attr("class", "label")
            .attr("transform", "rotate(-90)")
            .attr("y", 6)
            .attr("dy", ".71em")
            .style("text-anchor", "end")
            .text("");

        // to identify the condition of transparent column values
        if (transparent_column !== "Select" && val !== "" && val2 !== "") {
            transparent_column = transparent_column.toString();
            val = val.toString(); // ?? no to lower case here?
        }
        else {
            val = val.toString();
        }

        var transpar = function(d) {
            if (val !== "" && typeof d != 'undefined') {
                // if point's transp column value is equal to the value specified, return val1, else val2
                var match;
                if (document.getElementById('cbox6').checked) {
                    // console.log("Using exact match");
                    match = d[transparent_column] == val;
                } else {
                    match = d[transparent_column] && (d[transparent_column].toLowerCase().indexOf(val.toLowerCase()) > -1);
                }

                if (match){
                  return parseFloat(val1);
                } else{
                  return parseFloat(val2);
                }
            }
            else {
                return 1;
            }
        };

        // searching according to the substring given and searching column
        var searchFunc = function(d) {
            if (typeof d[category_search] == 'undefined' ) {
                return 1;
            }
            // noMatch truthy if not found
            var noMatch;
            if (document.getElementById('cbox5').checked) {
                noMatch = d[category_search] != val;
            } else {
                noMatch = d[category_search].toLowerCase().indexOf(val.toLowerCase()) < 0
                || val.length === 0;
            }
            return noMatch ? 1 : 2;
        };

        var searchFunc1 = function(d) {
            if (typeof d == 'undefined' ) {
                return 1;
            }
            // x true if not found
            var noMatch;
            if (document.getElementById('cbox5').checked) {
                // console.log("Using exact match");
                noMatch = d != val;
            } else {
                noMatch = d.toLowerCase().indexOf(val.toLowerCase()) < 0
                || val.length === 0;
            }
            return noMatch ? 1 : 2;
        };

        var searched_data = [], d_temp;
        /* temp3 holds the value of every point for the search column */
        for (var i=0;i<temp3.length;i++) {
            // 0 if found val in this point, 1 if not found
            if ( searchFunc1(temp3[i])-1 ) {
                d_temp = {};
                // enter all data into dictionary
                for(var j=1;j<categories.length;j++) {
                    d_temp[categories[j]] = dict1[categories[j]][i];
                }
                // only add to searched_data if not already in
                if(searchdic(searched_data, d_temp) === true) {
                    searched_data.push(d_temp);
                }
            }
        }
        // create the table
        if ( val != "" && searched_data.length != 0) {
            var peopleTable1 = tabulate(searched_data, columns);
        };

        // determines the rotation of symbols that can be done
        var sizes = {}
        sizes[0] = ["0", "90", "0", "0"]
        sizes[1] = ["0", "45", "0", "0"]
        sizes[2] = ["0", "90", "0", "0"]
        sizes[3] = ["0", "45", "0", "0"]
        sizes[4] = ["0", "90", "0", "0"]
        sizes[5] = ["0", "0", "0", "0"]
        var symbols = ["diamond", "cross", "triangle-up", "square", "triangle-down","circle"];

        /*** BEGIN drawing dots ***/

        // shaping of symbols according to the shaping column
        if (shaping_column !== "Select" ) {
          // category = shaping_column;
          var points = svg.selectAll(".dot")
              .data(data)
              .enter();

          points.append("path")
              .filter(function(d){ return (searchFunc(d) == 1); })
              .attr("class", "point")
              .style("stroke", "#000")
              .style("stroke-width", 1)
          // .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))
              .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size(function(d) {return searchFunc(d)-1 ? 180:30;}))
              .attr("transform", function(d) { return "translate(" + xMap(d) + "," + yMap(d) + ") rotate(" + sizes[parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + ")"; })
              .style("fill", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})
              .style("opacity",function(d) { return transpar(d);})

              .on("mouseover", function(d) {
                  tooltip.transition()
                         .duration(200)
                         .style("opacity", 1);
                  tooltip.html(
                          print_array(category_search_data, d))
                            .style("left", 60 + "px")
                            .style("top", 30 + "px");
              })
              .on("mouseout", function(d) {
                  d3.select(this).attr("r", function(d){ return searchFunc(d)-1 ? 7:3 ; })
                          .style("fill", function(d) { return color(cValue(d));});
                  tooltip.transition()
                          .duration(500)
                          .style("opacity", 0);
              })
              .on("click", function(d) {
                  svg.append("text")
                          .text(d[feature_column])
                          .attr("x", (d3.event.pageX-50))
                          .attr("y", (d3.event.pageY-35));
              });

          points.append("path")
              .filter(function(d){ return (searchFunc(d) == 2); })
              .attr("class", "point")
              .style("stroke", "yellow")
              .style("stroke-width", 2)
          // .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))
              .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size(function(d) {return searchFunc(d)-1 ? 180:30;}))
              .attr("transform", function(d) { return "translate(" + xMap(d) + "," + yMap(d) + ") rotate(" + sizes[parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + ")"; })
              .style("fill", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})
              .style("opacity",function(d) { return transpar(d);})

              .on("mouseover", function(d) {
                  tooltip.transition()
                         .duration(200)
                         .style("opacity", 1);
                  tooltip.html(
                          print_array(category_search_data, d))
                            .style("left", 60 + "px")
                            .style("top", 30 + "px");
              })
              .on("mouseout", function(d) {
                  d3.select(this).attr("r", function(d){ return searchFunc(d)-1 ? 7:3 ; })
                          .style("fill", function(d) { return color(cValue(d));});
                  tooltip.transition()
                          .duration(500)
                          .style("opacity", 0);
              })
              .on("click", function(d) {
                  svg.append("text")
                          .text(d[feature_column])
                          .attr("x", (d3.event.pageX-50))
                          .attr("y", (d3.event.pageY-35));
              });
        } else {
          // console.log(document.getElementById('cbox2').checked)
          // draw dots
          marked = {}
          var points = svg.selectAll(".dot")
              .data(data)
              .enter();

          points.append("circle")
              .filter(function(d){ return (searchFunc(d) == 1); })
              .attr("class", "dot")
              .attr("r", 3)
              .style("stroke", "#000")
              .style("stroke-width", 1)
              .attr("cx", xMap)
              .attr("cy", yMap)
              .style("fill", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})
              .style("opacity",function(d) { return transpar(d);})

              .on("mouseover", function(d) {
                  tooltip.transition()
                         .duration(200)
                         .style("opacity", 1);
                  tooltip.html(print_array(category_search_data, d))
                          .style("left", 60 + "px")
                          .style("top", 30 + "px");
              })

              .on("mouseout", function(d) {
                  tooltip.transition()
                         .duration(500)
                         .style("opacity", 0);
              })

              .on("click", function(d) {
                  if (!([d3.event.pageX, d3.event.pageY] in marked)) {
                      marked[[d3.event.pageX, d3.event.pageY]] = true;
                      marked[[d3.event.pageX-1, d3.event.pageY-1]] = true;
                      marked[[d3.event.pageX+1, d3.event.pageY+1]] = true;
                      marked[[d3.event.pageX-1, d3.event.pageY+1]] = true;
                      marked[[d3.event.pageX+1, d3.event.pageY-1]] = true;
                      marked[[d3.event.pageX+2, d3.event.pageY-2]] = true;
                      marked[[d3.event.pageX-2, d3.event.pageY-2]] = true;
                      marked[[d3.event.pageX-2, d3.event.pageY+2]] = true;
                      marked[[d3.event.pageX+2, d3.event.pageY+2]] = true;
                      svg.append("text")
                        .text(d[feature_column])
                        .attr("x", (d3.event.pageX-50))
                        .attr("y", (d3.event.pageY-35));
                      /*
                      tooltip1.transition()
                         .attr("class", "tooltip1")
                               .style("opacity", 1);

                      tooltip1.html("<b>"+d[feature_column]+"</b>")
                               .style("left", (d3.event.pageX + 10) + "px")
                               .style("top", (d3.event.pageY - 10) + "px");
                       */
                  }
              });
          points.append("circle")
            .filter(function(d){ return (searchFunc(d) == 2); })
            .attr("class", "dot")
            .attr("r", 7)
            .style("stroke", "yellow")
            .style("stroke-width", 2)
            .attr("cx", xMap)
            .attr("cy", yMap)
            .style("fill", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})
            .style("opacity",function(d) { return transpar(d);})
            // jann: here is the mouseover display
            .on("mouseover", function(d) {
                tooltip.transition()
                       .duration(200)
                       .style("opacity", 1);
                tooltip.html(
                        print_array(category_search_data, d))
                          .style("left", 60 + "px")
                          .style("top", 30 + "px");
            })

            .on("mouseout", function(d) {
                tooltip.transition()
                       .duration(500)
                       .style("opacity", 0);
            })

            .on("click", function(d) {
                console.log("Hello");
                if (!([d3.event.pageX, d3.event.pageY] in marked)){
                    marked[[d3.event.pageX, d3.event.pageY]] = true;
                    marked[[d3.event.pageX-1, d3.event.pageY-1]] = true;
                    marked[[d3.event.pageX+1, d3.event.pageY+1]] = true;
                    marked[[d3.event.pageX-1, d3.event.pageY+1]] = true;
                    marked[[d3.event.pageX+1, d3.event.pageY-1]] = true;
                    marked[[d3.event.pageX+2, d3.event.pageY-2]] = true;
                    marked[[d3.event.pageX-2, d3.event.pageY-2]] = true;
                    marked[[d3.event.pageX-2, d3.event.pageY+2]] = true;
                    marked[[d3.event.pageX+2, d3.event.pageY+2]] = true;
                    svg.append("text")
                      .text(d[feature_column])
                      .attr("x", (d3.event.pageX-50))
                      .attr("y", (d3.event.pageY-35));
                }
            });
        }
        /*** END drawing dots ***/

        // the event to call on click event
        svg.on("click",function() {
          // svg.select("#myText").remove();

          tooltip1.style("opacity", 0);
          var coordinates1 = d3.mouse(this);
          coordinatesx.unshift(coordinates1[0]);
          coordinatesy.unshift(coordinates1[1]);
          console.log(coordinatesx, coordinatesy);
        })

        /* can move up into the if/else, but more clear to separate functionality */
        if (shaping_column !== "Select" ) {
            /* .point didn't work, leaving for next iteration to fix */
            // lasso.items(d3.selectAll(".point"));
            lasso.items(d3.selectAll(".dot"));
        } else {
            lasso.items(d3.selectAll(".dot"));
        }

        var len = color.domain().length;
        // if spectrum
        if (numerics[category] && document.getElementById('cbox1').checked) {

            if (document.getElementById('cbox2').checked) {
                m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[category])); })));
                m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[category])); })));
            } else {
              m1 = (d3.min(data.map(function(d) {return parseFloat(d[category])})));
              m2 = (d3.max(data.map(function(d) {return parseFloat(d[category])})));

            }
            console.log(m1, m2);
            var legend = svg.selectAll(".legend")
              .data(color.domain())
              .enter().append("g")
              .attr("class", "legend");

            var gradient = legend.append('defs')
                    .append('linearGradient')
                    .attr('id', 'gradient')
                    .attr('x1', '0%') // bottom
                    .attr('y1', '100%')
                    .attr('x2', '0%') // to top
                    .attr('y2', '0%')
                    .attr('spreadMethod', 'pad');

            var pct = linspace(0, 100, scale.length).map(function(d) {
                return Math.round(d) + '%';
            });

            var colourPct = d3.zip(pct, scale);
            colourPct.forEach(function(d) {
                gradient.append('stop')
                    .attr('offset', d[0])
                    .attr('stop-color', d[1])
                    .attr('stop-opacity', 1);
            });

            legend.append('rect')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('width', 18)
                .attr('height', 150)
                .attr("transform", "translate(" + 582 + ", 0)")
                .style('fill', 'url(#gradient)');

            var legendScale = d3.scale.linear()
                .domain([m1, m2])
                .range([150, 0]);

            var legendAxis = d3.svg.axis()
                .scale(legendScale)
                .orient("right")
                // .tickValues([m1, m2])
                .ticks(10);

            legend.append("g")
                .attr("class", "legend axis")
                .attr("transform", "translate(" + 600 + ", 0)")
                .call(legendAxis);
        } else { // no spectrum
            var keys = Object.keys(symbol)
            leng = keys.length;
            if (leng<20 && shaping_column != "Select") {
              // draw legend
                // ?? Not sure why, but this legend appears not to show
                var legend = svg.selectAll(".legend")
                    .data(keys)
                    .enter().append("g")
                    // .attr("class", "legend");
                    // .attr("transform", function(d, i) { return "translate(30," + i * 20 + ")"; });
                console.log(keys);
                console.log(symbol);
                console.log(symbols);
                // draw legend colored rectangles
                legend.append("path")
                    // .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}).size(function(d) {return sizes[parseInt(symbol[d]/6)%3];}))
                    .attr("d", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}))
                    .attr("x", width + 0)
                    .attr("width", 18)
                    .attr("height", 18)
                    // .attr("transform", function(d, i) { return "translate(" + 20 + "," + i*20 + ")"; });
                    .attr("transform", function(d, i) { return "translate(" + 20 + "," + i*20 + ") rotate(" + sizes[parseInt(symbol[d]%6)][parseInt(symbol[d]/6)%4] + ")"; });
                // draw legend text
                legend.append("text")
                    // .attr("x", 100 + 0)
                    // .attr("y", 4)
                    .attr("dy", ".35em")
                    .style("text-anchor", "begin")
                    .text(function(d) { return d;})
                    .attr("transform", function(d, i) { return "translate(30," + i * 20 + ")"; });
            }

            if(len <= 30 && category != "Select") {

                // draw legend
                var legend = svg.selectAll(".legend")
                  .data(color.domain())
                  .enter().append("g")
                  .attr("class", "legend")
                  .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

                // draw legend colored rectangles
                legend.append("rect")
                  .attr("x", width + 6)
                  .attr("width", 18)
                  .attr("height", 18)
                  .style("fill", color);

                // draw legend text
                legend.append("text")
                  .attr("x", width + 0)
                  .attr("y", 9)
                  .attr("dy", ".35em")
                  .style("text-anchor", "end")
                  .text(function(d) { return d;});
            }
        };
    }); // end load data
} // end highlighting
</script>
</body>
</html>
