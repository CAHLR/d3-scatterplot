/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/table_creator.js */ \"./src/modules/table_creator.js\");\n/* harmony import */ var _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/utilities.js */ \"./src/modules/utilities.js\");\n/* harmony import */ var _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/constants.js */ \"./src/modules/constants.js\");\n\n\n\n\n// This step is performed to parse the url to identify the dataset and the default coloring column\nvar query = window.location.search.substring(1);\nvar temp_query = query.split(\"&\");\nvar dicts = {};\nvar tvars, dataset;\nfor(var i=0;i<temp_query.length;i++) {\n  tvars = temp_query[i].split(\"=\");\n  dicts[tvars[0]]=tvars[1].replace(/%20/g, \" \");\n}\nif (\"dataset\" in dicts) {\n  dataset = dicts[\"dataset\"];\n} else {\n  dataset = \"joined_data.csv\";\n}\nvar weights_2darray = [], biases_1darray = [], vocab_1darray = [], vectorspace_2darray = [], bow_2darray = [];\n// Semantic model option set up\nif (\"semantic_model\" in dicts && dicts[\"semantic_model\"] == \"true\") {\n  console.log('Using semantic model.\\nGetting matrices...');\n  var weightsfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_weights.txt';\n  var biasesfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_biases.txt';\n  var vocabfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_vocab.txt';\n  var vectorfile = 'VS-' + dataset.split(\"_semantic\")[0]+'.txt';\n  var bowfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_bow.txt';\n\n  console.log(\"Reading \" + bowfile);\n  d3.tsv(bowfile, function(text){\n    bow_2darray = text.map( Object.values );\n    bow_2darray = bow_2darray.map(function(entry) {\n      return entry.map(function(elem) {\n        return Math.round(parseFloat(elem));\n      });\n    });\n  });\n\n\n  console.log(\"Reading \" + vectorfile);\n  d3.tsv(vectorfile, function(text){\n    vectorspace_2darray = text.map( Object.values );\n    vectorspace_2darray = vectorspace_2darray.map(function(arr) {\n            // username column ends up last in the dictionary, due to alphanumeric sort\n            return arr.slice(0,-1).map(function(elem) {\n              return parseFloat(elem);\n            });\n          });\n  });\n  console.log(\"Reading \" + weightsfile);\n  d3.tsv(weightsfile, function(text){\n    weights_2darray = text.map( Object.values );\n    weights_2darray = weights_2darray.map(function(entry) {\n      return entry.map(function(elem) {\n        return parseFloat(elem);\n      });\n    });\n  });\n  console.log(\"Reading \" + biasesfile);\n  d3.tsv(biasesfile, function(text){\n    biases_1darray = text.map( Object.values );\n    biases_1darray = Object.values(biases_1darray.map(Number));\n  });\n  console.log(\"Reading \" + vocabfile);\n  d3.tsv(vocabfile, function(text){\n    vocab_1darray = text.map( Object.values );\n    vocab_1darray = Object.values(vocab_1darray.map(String));\n  });\n}\n\n// add the tooltip area to the webpage\nvar tooltip = d3.select(\"body\").append(\"div\")\n.attr(\"class\", \"tooltip\")\n.style(\"opacity\", 0);\n\nvar tooltip1 = d3.select(\"body\").append(\"div\")\n.attr(\"class\", \"tooltip1\")\n.style(\"opacity\", 0);\n\n// to print all the key values pairs of a point (used to display the summary on the webpage)\nvar print_array = function(arr, d) {\n  var x = \"\";\n  for (var i=0; i<arr.length; i++) {\n    x = x + \"<b>\" + arr[i] + \"</b>: \" + d[arr[i]] + \"<br>\"\n  }\n  x = x + d.x + \"<br>\" + d[\"y\"];\n  return x;\n};\n\n// setup fill color\nvar color_column;\n\n// coloring will be done according to the values determined by cValue\nvar cValue = function(d) {return d[color_column];},\ncValue2 = function(d) {return Math.log(parseFloat(d[color_column]));},\ncolor = d3.scale.ordinal().range(_modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"d3_category20_shuffled\"]);\n\n// create the dropdown menu\n// Coloring\nvar dropDown = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select1\")\n.attr(\"name\", \"color_column\");\n\n// Searching\nvar dropDown1 = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select2\")\n.attr(\"name\", \"color_column\");\n\n// Transparent\nvar dropDown2 = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select4\")\n.attr(\"name\", \"color_column\");\n\n// Click on feature\nvar dropDown3 = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select5\")\n.attr(\"name\", \"color_column\");\n\n// Shaping\nvar dropDown4 = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select6\")\n.attr(\"name\", \"color_column\");\n\nvar categories = [];\n// category_search stores the name of column according to which searching is to be done\nvar category_search_data = [];\n// categories stores the name of all the columns\nvar category_search;\n\ncategories.push(\"Select\");\n// check whether the searching column is provided in the url or not\nif (\"search\" in dicts) {\n  category_search = dicts[\"search\"];\n  category_search_data.push(category_search);\n}\n\n\n// color_column stores the name of column according to which coloring is to be done\n// check whether the coloring column is provided in the url or not\nif (\"color\" in dicts) {\n  color_column = dicts[\"color\"];\n  categories.push(color_column);\n} else {\n  color_column = \"Select\";\n}\n\n// categories_copy_color is just the copy of categories\nvar categories_copy_color = [];\ncategories_copy_color.push(color_column);\n\nvar columns = [], temp = [];\n// column for the transparent value\nvar transparent_column = \"Select\", feature_column = \"\", shaping_column = \"Select\";\n\nconsole.log('Loading main data')\n// getting header from csv file to make drowdown menus\nd3.tsv(dataset, function(data) {\n  console.log(data[0]);\n  temp = Object.keys(data[0]);\n    // remove x and y\n    temp.splice(temp.indexOf('x'), 1);\n    temp.splice(temp.indexOf('y'), 1);\n\n    for(var i=0;i<temp.length;i++)\n      if (temp[i] != category_search) {\n        category_search_data.push(temp[i]);\n      }\n\n      for(var i=0;i<temp.length;i++) {\n        // color_column already pushed\n        if (temp[i] != color_column) {\n          categories.push(temp[i]);\n          categories_copy_color.push(temp[i]);\n        }\n        columns.push(temp[i]);\n      }\n    // check whether the coloring column is provided in the url or not\n    // ?? is this necessary? color_column is already defined with the same procedure outside the function\n    if (\"color\" in dicts) {\n      color_column = categories[1]; // since color would be first, start with next\n    } else {\n      // color_column = \"Select\"\n      color_column = categories[0];\n    }\n    category_search = category_search_data[0];\n    // Searching\n    dropDown1.selectAll(\"option\")\n    .data(category_search_data)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    // Coloring\n    dropDown.selectAll(\"option\")\n    .data(categories_copy_color)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    // Transparent\n    dropDown2.selectAll(\"option\")\n    .data(category_search_data)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    // Click on feature\n    dropDown3.selectAll(\"option\")\n    .data(category_search_data)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    // Shaping\n    dropDown4.selectAll(\"option\")\n    .data(categories)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    shaping_column = categories[0];\n    feature_column = category_search_data[0];\n    transparent_column = category_search_data[0];\n  });\n\n// whenever any one of the drowdown menu's selected column is changes the plot is generated according to the value of dropdown menu selected\n// Coloring\ndropDown.on(\"change\", plotting);\n// Searching\ndropDown1.on(\"change\", plotting2);\n// Transparent\ndropDown2.on(\"change\", plotting3);\n// Click on feature\ndropDown3.on(\"change\", plotting4);\n// Shaping\ndropDown4.on(\"change\", plotting5);\n\nif (\"q\" in dicts) {\n  highlighting(dicts[\"q\"], \"\", \"\");\n} else {\n  highlighting(\"\", \"\", \"\");\n}\n\n// the functions to call when the value of dropdown menu is changes\n// Click on feature\nfunction plotting4(){\n  feature_column = d3.event.target.value;\n}\n// Transparent\nfunction plotting3(){\n  transparent_column = d3.event.target.value;\n}\n// Searching\nfunction plotting2(){\n  category_search = d3.event.target.value;\n}\n\n// function to call for change event\n// Coloring\nfunction plotting(){\n  color_column = d3.event.target.value;\n  cValue = function(d) { return d[color_column];};\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n}\n\n// function to call for change event\n// Shaping\nfunction plotting5(){\n  shaping_column = d3.event.target.value;\n  cValue = function(d) { return d[color_column];};\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n}\n\nvar zoomed = 0;\nvar needZoom = false;\nvar needDrawCircle = false;\n\n// search event\n// it will be executed when search button is pressed and points that matches the searched string will be highlighted\nfunction searchEventHandler(event) {\n  console.log(document.getElementById(\"searchText\").value);\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n  return false;\n}\nfunction searchExactMatchEventHandler(event) {\n  if (document.getElementById(\"searchText\").value) searchEventHandler();\n}\n\n// transparent event\n// it will be executed when Transparent button is pressed and points that satisfies the condition will be highlighted\nfunction transparentSearchEventHandler(event) {\n  console.log(document.getElementById(\"transpText\").value);\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n  return false;\n}\nfunction handleCheck1(event) {\n  if (document.getElementById(\"transpText\").value) {\n    transparentSearchEventHandler();\n  }\n}\n\n// ?? I believe this function is unused, and draw also maps to zoomEventHandler\n// it will be executed when Draw button is pressed and the plot will highlight those points that covers fixed percentage of point from the point obtained by mouse click\nfunction handleClick2(event){\n  shaping_column = \"Select\";\n  color_column = \"Select\";\n  myForm.searchText.value = 0;\n  myForm1.transpText.value = 0;\n  myForm1.opacityMatch.value = 0;\n  myForm1.opacityNoMatch.value = 0;\n  dropDown4.property( \"value\", \"Select\" );\n  dropDown.property( \"value\", \"Select\" );\n  highlighting(\"\", \"\", \"\");\n  return false;\n}\n\n// spectrum / log event\n// it will be executed when spectrum/log is checked\n// ?? Can we collapse transparentSearchEventHandler,3,4?\nfunction spectrumAndLogColoringEventHandler(event) {\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n}\n\n// it will be executed when (?? draw and) zoom button is pressed and the plot will zoomed out according to the points obtained by mouse click event\nfunction zoomEventHandler(){\n  if (!document.getElementById('cbox3').checked) {\n    document.getElementById(\"zoomxy\").value = \"\"; // clear the textbox\n  }\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  needZoom = true;\n  highlighting(val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n}\n\n(function setEventHandlers() {\n  let zoomButton = document.getElementsByClassName('zoom-button')[0];\n  zoomButton.onclick = zoomEventHandler;\n\n  let colorOptions = document.getElementsByClassName('color-option');\n  for (i = 0; i < 2; i++) {\n    colorOptions[i].onclick = spectrumAndLogColoringEventHandler;\n  };\n\n  let searchExactMatchCheckbox = document.getElementsByClassName('search-exact-match')[0];\n  searchExactMatchCheckbox.onclick = searchExactMatchEventHandler;\n\n  let searchFormButton = document.getElementsByClassName('search-button')[0];\n  searchFormButton.addEventListener('click', (event) => {\n    event.preventDefault();\n    searchEventHandler();\n  });\n\n  let transparentSearchButton = document.getElementsByClassName('transparent-search-button')[0];\n  transparentSearchButton.addEventListener('click', (event) => {\n    event.preventDefault();\n    transparentSearchEventHandler();\n  });\n})()\n\nlet coordinatesx = [];\nlet coordinatesy = [];\n\n// function for plotting\nfunction highlighting(val_search, val_transp, val_opacityMatch, val_opacityNoMatch) {\n\n  var svg, m1, m2, x_max, x_min, y_max, y_min;\n  var temp1 = [], temp2 = [], temp3 = [];\n  var dict1 = {};\n\n    // to remove the existing svg plot if any and clear side table\n    document.getElementById(\"demo3\").innerHTML = \"\";\n    document.getElementById(\"predicted_words\").innerHTML = \"\";\n    document.getElementById(\"frequent_words\").innerHTML = \"\";\n    d3.select(\"svg\").remove();\n    d3.select(\"table\").remove();\n\n    // function zoom() {\n    //  svg.attr(\"transform\", \"translate(\" + d3.event.translate + \")scale(\" + d3.event.scale + \")\");\n    //    }\n\n    // the location of svg image will be determined\n    svg = d3.select(\"body\").append(\"svg\")\n    .attr(\"width\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"width\"] + _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"margin\"].left + _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"margin\"].right)\n    .attr(\"height\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"height\"] + _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"margin\"].top + _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"margin\"].bottom)\n    .append(\"g\")\n    .attr(\"transform\",\"translate(\" + _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"margin\"].left + \",\" + _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"margin\"].top + \")\");\n\n    /* https://github.com/skokenes/D3-Lasso-Plugin\n    plugin also handles selected and possible settings */\n    // Lasso starts\n    var lasso_start = function() {\n      d3.select(\"table\").remove();\n      document.getElementById(\"demo3\").innerHTML = \"\";\n      lasso.items()\n            .attr(\"r\",3.5) // reset size\n            .style(\"fill\",null) // clear all of the fills (greys out)\n            .classed({\"not_possible\":true,\"selected\":false}); // style as not possible\n          };\n\n          var lasso_draw = function() {\n        // Style the possible dots\n        lasso.items().filter(function(d) {return d.possible===true})\n        .classed({\"not_possible\":false,\"possible\":true});\n\n        // Style the not possible dot\n        lasso.items().filter(function(d) {return d.possible===false})\n        .classed({\"not_possible\":true,\"possible\":false})\n        .style(\"stroke\", \"#000\");\n      };\n\n      var lasso_end = function() {\n        // Reset the color of all dots\n        lasso.items()\n        .style(\"fill\", function(d) { return color(d[color_column]); });\n\n        // Style the selected dots\n        lasso.items().filter(function(d) {return d.selected===true})\n        .classed({\"not_possible\":false,\"possible\":false})\n        .attr(\"r\",6.5);\n\n        // get values for table -> array inside a list\n        var zsx = lasso.items().filter(function(d) {return d.selected===true});\n        let x_values = [];\n        let y_values = [];\n        // adjust the x and y values\n        for (var i=0; i<zsx[0].length; i++) {\n          x_values.push(((((zsx[0][i].getBBox().x+6.5) * (x_max - x_min))/_modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"width\"] + x_min )));\n          y_values.push(((((zsx[0][i].getBBox().y+6.5) * (y_min - y_max))/_modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"height\"] + y_max)));\n        }\n        var selected_data=[], selected_data_indices=[];\n        // Compare every selected point to all points (tempX)\n        // in order to match coordinates with actual data\n        for (var ii=0;ii<x_values.length;ii++) {\n          console.log(\"lasso_end gathering selected data\");\n          console.log(temp1.length);\n          for (var jj=0;jj<temp1.length;jj++) {\n            x_values[ii] = +(x_values[ii].toFixed(3));\n            y_values[ii] = +(y_values[ii].toFixed(5));\n            if ( (x_values[ii] === +(temp1[jj].toFixed(3))) && (y_values[ii] === +(temp2[jj].toFixed(5))) ) {\n              let all_values = {};\n              for (var k=1;k<categories.length;k++) {\n                all_values[categories[k]] = (dict1[categories[k]][jj]);\n              }\n              if(Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"searchDic\"])(selected_data,all_values)==true){\n                selected_data.push(all_values);\n                selected_data_indices.push(jj);\n                break;\n              }\n            }\n          }\n        }\n        // render the table for the points selected by lasso\n        if (selected_data.length > 0) {\n          console.log(\"Rendering table...\");\n          console.log(selected_data);\n          console.log(columns);\n          console.log(x_values);\n          var peopleTable = Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"tabulate\"])(selected_data, columns, x_values);\n          if (\"semantic_model\" in dicts && dicts[\"semantic_model\"] == \"true\") {\n            console.log(\"Predicting words...\");\n            Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"classify\"])(selected_data_indices, vectorspace_2darray, weights_2darray, biases_1darray, vocab_1darray);\n            Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"benchmark\"])(selected_data_indices, bow_2darray, vocab_1darray);\n          }\n        }\n\n        // Reset the style of the not selected dots (we made them 0.5 smaller)\n        lasso.items().filter(function(d) {return d.selected===false})\n        .classed({\"not_possible\":false,\"possible\":false})\n        .attr(\"r\",3)\n        .style(\"stroke\", \"#000\");\n      };\n\n    // Create the area where the lasso event can be triggered\n    var lasso_area = svg.append(\"rect\")\n    .attr(\"width\",_modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"width\"])\n    .attr(\"height\",_modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"height\"])\n    .style(\"opacity\",0);\n\n    // Define the lasso\n    var lasso = d3.lasso()\n        .closePathDistance(75) // max distance for the lasso loop to be closed\n        .closePathSelect(true) // can items be selected by closing the path?\n        .hoverSelect(true) // can items by selected by hovering over them?\n        .area(lasso_area) // area where the lasso can be started\n        .on(\"start\",lasso_start) // lasso start function\n        .on(\"draw\",lasso_draw) // lasso draw function\n        .on(\"end\",lasso_end); // lasso end function\n\n    // Init the lasso object on the svg:g that contains the dots\n    svg.call(lasso);\n\n    console.log('Loading main data, again') // load data\n    d3.tsv(dataset, function(error, data) {\n\n        // change string (from CSV) into number format\n        var numerics = {}, symbol = {};\n        //Omitting Select (0)\n        for(var i=1;i<categories.length;i++) {\n            // initialize the value for each category key to empty list\n            dict1[categories[i]] = [];\n            // initialize all categories as numeric\n            numerics[categories[i]] = 1;\n          }\n          let counter = 0;\n          data.forEach(function(d) {\n            // coerce the data to numbers\n            d.x = +d.x;\n            d[\"y\"] = +d[\"y\"];\n\n            for(var i=1;i<categories.length;i++){\n                // add every attribute of point to the {category:[val1,val2,...]}\n                dict1[categories[i]].push(d[categories[i]]);\n                // revoke a category's numerics status if find an entry has a non-Int or non-null value for that category\n                numerics[categories[i]] = numerics[categories[i]] && (d[categories[i]] == \"\" || d[categories[i]] == parseFloat(d[categories[i]]));\n              }\n            // fill the symbol dictionary with all possible values of the shaping column as keys\n            // value is the order of points\n            if (!(d[shaping_column] in symbol)) {\n              symbol[d[shaping_column]] = counter;\n              counter = counter + 1;\n            }\n            // push all x values, y values, and all category search values into temp1/2/3\n            temp1.push(d.x);\n            temp2.push(d[\"y\"]);\n            temp3.push(d[category_search]);\n          // console.log(d[\"z\"] == parseInt(d[\"z\"]));\n        });\n          console.log(numerics);\n          console.log(color_column);\n        // set color according to spectrum\n        if (numerics[color_column] && document.getElementById('cbox1').checked) {\n          console.log('using spectrum');\n            // take log if log checkbox checked\n            if (document.getElementById('cbox2').checked) {\n              console.log('using log');\n              m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n              m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n            } else{\n              console.log('not using log');\n              m1 = (d3.min(data.map(function(d) {return parseFloat(d[color_column])})));\n              m2 = (d3.max(data.map(function(d) {return parseFloat(d[color_column])})));\n            }\n\n            console.log(m1, m2);\n            m1 = Math.max(Number.MIN_VALUE, m1);\n            console.log(m1, m2);\n\n            color = d3.scale.linear()\n            .domain(Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"linSpace\"])(m1, m2,_modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"scale\"].length))\n              //.domain(linSpace(d3.min(data.map(function(d) {return parseInt(d[color_column])})), d3.max(data.map(function(d) {return parseInt(d[color_column])})),scale.length))\n              .range(_modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"scale\"]);\n            } else {\n              console.log('not using spectrum');\n              color = d3.scale.ordinal().range(_modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"d3_category20_shuffled\"]);\n            }\n\n        // don't want dots overlapping axis, so add in buffer to data domain\n        var zoom = Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"getParameterByName\"])('Zoom'); // unused, capitalized Z anyway as changed above\n\n        if (document.getElementById(\"cbox3\").checked==false) {\n          document.getElementById(\"zoomxy\").value = \"\";\n          zoomed = 0;\n          needZoom = false;\n          x_max = d3.max(data, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xValue\"])+1;\n          x_min = d3.min(data, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xValue\"])-1;\n          y_max = d3.max(data, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yValue\"])+1;\n          y_min = d3.min(data, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yValue\"])-1;\n        }\n\n        // if zoom is checked and conditions are satisfied\n        if (document.getElementById(\"cbox3\").checked==true  && needZoom == true && coordinatesx.length >= 2) {\n\n          x_max = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xScale\"].invert(Math.max(coordinatesx[0], coordinatesx[1]))+1;\n          x_min = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xScale\"].invert(Math.min(coordinatesx[0], coordinatesx[1]))-1;\n          y_max = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yScale\"].invert(Math.min(coordinatesy[0], coordinatesy[1]))+1;\n          y_min = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yScale\"].invert(Math.max(coordinatesy[0], coordinatesy[1]))-1;\n\n          console.log(x_max, x_min, y_max, y_min);\n          document.getElementById(\"zoomxy\").value = \"X:[\"+parseInt(x_min)+\", \"+parseInt(x_max)+\"] Y:[\"+parseInt(y_min)+\", \"+parseInt(y_max)+\"]\";\n\n          zoomed = 1;\n          needZoom = false;\n                // document.getElementById(\"cbox3\").checked = false;\n                /*\n                          zoom = zoom.substr(1, zoom.length-2);\n                          commaIndex = zoom.indexOf(',');\n                          x_min = parseFloat(zoom.substr(0, commaIndex));\n                          zoom = zoom.substr(commaIndex+1);\n                          commaIndex = zoom.indexOf(',');\n                          x_max = parseFloat(zoom.substr(0, commaIndex));\n                          zoom = zoom.substr(commaIndex+1);\n                          commaIndex = zoom.indexOf(',');\n                          y_min = parseFloat(zoom.substr(0, commaIndex));\n                          y_max = parseFloat(zoom.substr(commaIndex+1));\n                          */\n                        }\n                        _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xScale\"].domain([x_min, x_max]);\n                        _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yScale\"].domain([y_min, y_max]);\n\n        // xScale.domain([d3.min(data, xValue)-1, d3.max(data, xValue)+1]);\n        // yScale.domain([d3.min(data, yValue)-1, d3.max(data, yValue)+1]);\n\n        // x-axis\n        let cx = 0;\n        let cy = 0;\n        let ans = 0;\n\n        // draw the x-axis of plot\n        svg.append(\"g\")\n        .attr(\"class\", \"x axis\")\n        .attr(\"transform\", \"translate(0,\" + _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"height\"] + \")\")\n        .call(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xAxis\"])\n        .append(\"text\")\n        .attr(\"class\", \"label\")\n        .attr(\"x\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"width\"])\n        .attr(\"y\", -6)\n        .style(\"text-anchor\", \"end\")\n        .text(\"\");\n\n        // draw the y-axis of plot\n        svg.append(\"g\")\n        .attr(\"class\", \"y axis\")\n        .call(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yAxis\"])\n        .append(\"text\")\n        .attr(\"class\", \"label\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"y\", 6)\n        .attr(\"dy\", \".71em\")\n        .style(\"text-anchor\", \"end\")\n        .text(\"\");\n\n        // to identify the condition of transparent column values\n        if (transparent_column !== \"Select\" && val_transp !== \"\" && val_opacityNoMatch !== \"\") {\n          transparent_column = transparent_column.toString();\n            val_transp = val_transp.toString(); // ?? no to lower case here?\n          }\n          else {\n            val_transp = val_transp.toString();\n          }\n\n          var transpar = function(d) {\n            if (val_transp !== \"\" && typeof d != 'undefined') {\n                // if point's transp column value is equal to the value specified, return val_opacityMatch, else val_opacityNoMatch\n                var match;\n                if (document.getElementById('cbox6').checked) {\n                    // console.log(\"Using exact match\");\n                    match = d[transparent_column] == val_transp;\n                  } else {\n                    match = d[transparent_column] && (d[transparent_column].toLowerCase().indexOf(val_transp.toLowerCase()) > -1);\n                  }\n\n                  if (match){\n                    return parseFloat(val_opacityMatch);\n                  } else{\n                    return parseFloat(val_opacityNoMatch);\n                  }\n                }\n                else {\n                  return 1;\n                }\n              };\n\n        // searching according to the substring given and searching column\n        var searchFunc = function(d) {\n          if (typeof d[category_search] == 'undefined' ) {\n            return 1;\n          }\n            // noMatch truthy if not found\n            var noMatch;\n            if (document.getElementById('cbox5').checked) {\n              noMatch = d[category_search] != val_search;\n            } else {\n              noMatch = d[category_search].toLowerCase().indexOf(val_search.toLowerCase()) < 0\n              || val_search.length === 0;\n            }\n            return noMatch ? 1 : 2;\n          };\n\n          var searchFunc1 = function(d) {\n            if (typeof d == 'undefined' ) {\n              return 1;\n            }\n            // noMatch true if not found\n            var noMatch;\n            if (document.getElementById('cbox5').checked) {\n              noMatch = d != val_search;\n            } else {\n              noMatch = d.toLowerCase().indexOf(val_search.toLowerCase()) < 0\n              || val_search.length === 0;\n            }\n            return noMatch ? 1 : 2;\n          };\n\n          var searched_data = [], searched_data_indices = [], d_temp;\n          /* temp3 holds the value of every point for the search column */\n          for (var i=0;i<temp3.length;i++) {\n            // 0 if found val in this point, 1 if not found\n            if ( searchFunc1(temp3[i])-1 ) {\n              d_temp = {};\n                // enter all data into dictionary\n                for(var j=1;j<categories.length;j++) {\n                  d_temp[categories[j]] = dict1[categories[j]][i];\n                }\n                // only add to searched_data if not already in\n                if(Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"searchDic\"])(searched_data, d_temp) === true) {\n                  searched_data.push(d_temp);\n                  searched_data_indices.push(i);\n                }\n              }\n            }\n        // create the table\n        if ( val_search != \"\" && searched_data.length > 0) {\n          var peopleTable1 = Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"tabulate\"])(searched_data, columns);\n          if (\"semantic_model\" in dicts && dicts[\"semantic_model\"] == \"true\") {\n            console.log(\"Predicting words...\");\n            Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"classify\"])(searched_data_indices, vectorspace_2darray, weights_2darray, biases_1darray, vocab_1darray);\n            Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"benchmark\"])(searched_data_indices, bow_2darray, vocab_1darray);\n          }\n        };\n\n        // determines the rotation of symbols that can be done\n        var sizes = {}\n        sizes[0] = [\"0\", \"90\", \"0\", \"0\"]\n        sizes[1] = [\"0\", \"45\", \"0\", \"0\"]\n        sizes[2] = [\"0\", \"90\", \"0\", \"0\"]\n        sizes[3] = [\"0\", \"45\", \"0\", \"0\"]\n        sizes[4] = [\"0\", \"90\", \"0\", \"0\"]\n        sizes[5] = [\"0\", \"0\", \"0\", \"0\"]\n        var symbols = [\"diamond\", \"cross\", \"triangle-up\", \"square\", \"triangle-down\",\"circle\"];\n\n        /*** BEGIN drawing dots ***/\n\n        // shaping of symbols according to the shaping column\n        if (shaping_column !== \"Select\" ) {\n          // color_column = shaping_column;\n          var points = svg.selectAll(\".dot\")\n          .data(data)\n          .enter();\n\n          points.append(\"path\")\n          .filter(function(d){ return (searchFunc(d) == 1); })\n          .attr(\"class\", \"point\")\n          .style(\"stroke\", \"#000\")\n          .style(\"stroke-width\", 1)\n          // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))\n          .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size(function(d) {return searchFunc(d)-1 ? 180:30;}))\n          .attr(\"transform\", function(d) { return \"translate(\" + Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xMap\"])(d) + \",\" + Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yMap\"])(d) + \") rotate(\" + sizes[parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + \")\"; })\n          .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})\n          .style(\"opacity\",function(d) { return transpar(d);})\n\n          .on(\"mouseover\", function(d) {\n            tooltip.transition()\n            .duration(200)\n            .style(\"opacity\", 1);\n            tooltip.html(\n              print_array(category_search_data, d))\n            .style(\"left\", 60 + \"px\")\n            .style(\"top\", 30 + \"px\");\n          })\n          .on(\"mouseout\", function(d) {\n            d3.select(this).attr(\"r\", function(d){ return searchFunc(d)-1 ? 7:3 ; })\n            .style(\"fill\", function(d) { return color(cValue(d));});\n            tooltip.transition()\n            .duration(500)\n            .style(\"opacity\", 0);\n          })\n          .on(\"click\", function(d) {\n            svg.append(\"text\")\n            .text(d[feature_column])\n            .attr(\"x\", (d3.event.pageX-50))\n            .attr(\"y\", (d3.event.pageY-35));\n          });\n\n          points.append(\"path\")\n          .filter(function(d){ return (searchFunc(d) == 2); })\n          .attr(\"class\", \"point\")\n          .style(\"stroke\", \"yellow\")\n          .style(\"stroke-width\", 2)\n          // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))\n          .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size(function(d) {return searchFunc(d)-1 ? 180:30;}))\n          .attr(\"transform\", function(d) { return \"translate(\" + Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xMap\"])(d) + \",\" + Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yMap\"])(d) + \") rotate(\" + sizes[parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + \")\"; })\n          .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})\n          .style(\"opacity\",function(d) { return transpar(d);})\n\n          .on(\"mouseover\", function(d) {\n            tooltip.transition()\n            .duration(200)\n            .style(\"opacity\", 1);\n            tooltip.html(\n              print_array(category_search_data, d))\n            .style(\"left\", 60 + \"px\")\n            .style(\"top\", 30 + \"px\");\n          })\n          .on(\"mouseout\", function(d) {\n            d3.select(this).attr(\"r\", function(d){ return searchFunc(d)-1 ? 7:3 ; })\n            .style(\"fill\", function(d) { return color(cValue(d));});\n            tooltip.transition()\n            .duration(500)\n            .style(\"opacity\", 0);\n          })\n          .on(\"click\", function(d) {\n            svg.append(\"text\")\n            .text(d[feature_column])\n            .attr(\"x\", (d3.event.pageX-50))\n            .attr(\"y\", (d3.event.pageY-35));\n          });\n        } else {\n          // draw dots\n          let marked = {}\n          var points = svg.selectAll(\".dot\")\n          .data(data)\n          .enter();\n\n          points.append(\"circle\")\n          .filter(function(d){ return (searchFunc(d) == 1); })\n          .attr(\"class\", \"dot\")\n          .attr(\"r\", 3)\n          .style(\"stroke\", \"#000\")\n          .style(\"stroke-width\", 1)\n          .attr(\"cx\", _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xMap\"])\n          .attr(\"cy\", _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yMap\"])\n          .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})\n          .style(\"opacity\",function(d) { return transpar(d);})\n\n          .on(\"mouseover\", function(d) {\n            tooltip.transition()\n            .duration(200)\n            .style(\"opacity\", 1);\n            tooltip.html(print_array(category_search_data, d))\n            .style(\"left\", 60 + \"px\")\n            .style(\"top\", 30 + \"px\");\n          })\n\n          .on(\"mouseout\", function(d) {\n            tooltip.transition()\n            .duration(500)\n            .style(\"opacity\", 0);\n          })\n\n          .on(\"click\", function(d) {\n            if (!([d3.event.pageX, d3.event.pageY] in marked)) {\n              marked[[d3.event.pageX, d3.event.pageY]] = true;\n              marked[[d3.event.pageX-1, d3.event.pageY-1]] = true;\n              marked[[d3.event.pageX+1, d3.event.pageY+1]] = true;\n              marked[[d3.event.pageX-1, d3.event.pageY+1]] = true;\n              marked[[d3.event.pageX+1, d3.event.pageY-1]] = true;\n              marked[[d3.event.pageX+2, d3.event.pageY-2]] = true;\n              marked[[d3.event.pageX-2, d3.event.pageY-2]] = true;\n              marked[[d3.event.pageX-2, d3.event.pageY+2]] = true;\n              marked[[d3.event.pageX+2, d3.event.pageY+2]] = true;\n              svg.append(\"text\")\n              .text(d[feature_column])\n              .attr(\"x\", (d3.event.pageX-50))\n              .attr(\"y\", (d3.event.pageY-35));\n                      /*\n                      tooltip1.transition()\n                         .attr(\"class\", \"tooltip1\")\n                               .style(\"opacity\", 1);\n\n                      tooltip1.html(\"<b>\"+d[feature_column]+\"</b>\")\n                               .style(\"left\", (d3.event.pageX + 10) + \"px\")\n                               .style(\"top\", (d3.event.pageY - 10) + \"px\");\n                               */\n                             }\n                           });\n          points.append(\"circle\")\n          .filter(function(d){ return (searchFunc(d) == 2); })\n          .attr(\"class\", \"dot\")\n          .attr(\"r\", 7)\n          .style(\"stroke\", \"yellow\")\n          .style(\"stroke-width\", 2)\n          .attr(\"cx\", _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"xMap\"])\n          .attr(\"cy\", _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"yMap\"])\n          .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})\n          .style(\"opacity\",function(d) { return transpar(d);})\n            // jann: here is the mouseover display\n            .on(\"mouseover\", function(d) {\n              tooltip.transition()\n              .duration(200)\n              .style(\"opacity\", 1);\n              tooltip.html(\n                print_array(category_search_data, d))\n              .style(\"left\", 60 + \"px\")\n              .style(\"top\", 30 + \"px\");\n            })\n\n            .on(\"mouseout\", function(d) {\n              tooltip.transition()\n              .duration(500)\n              .style(\"opacity\", 0);\n            })\n\n            .on(\"click\", function(d) {\n              if (!([d3.event.pageX, d3.event.pageY] in marked)){\n                marked[[d3.event.pageX, d3.event.pageY]] = true;\n                marked[[d3.event.pageX-1, d3.event.pageY-1]] = true;\n                marked[[d3.event.pageX+1, d3.event.pageY+1]] = true;\n                marked[[d3.event.pageX-1, d3.event.pageY+1]] = true;\n                marked[[d3.event.pageX+1, d3.event.pageY-1]] = true;\n                marked[[d3.event.pageX+2, d3.event.pageY-2]] = true;\n                marked[[d3.event.pageX-2, d3.event.pageY-2]] = true;\n                marked[[d3.event.pageX-2, d3.event.pageY+2]] = true;\n                marked[[d3.event.pageX+2, d3.event.pageY+2]] = true;\n                svg.append(\"text\")\n                .text(d[feature_column])\n                .attr(\"x\", (d3.event.pageX-50))\n                .attr(\"y\", (d3.event.pageY-35));\n              }\n            });\n          }\n          /*** END drawing dots ***/\n\n        // the event to call on click event\n        svg.on(\"click\",function() {\n          // svg.select(\"#myText\").remove();\n\n          tooltip1.style(\"opacity\", 0);\n          var coordinates1 = d3.mouse(this);\n          coordinatesx.unshift(coordinates1[0]);\n          coordinatesy.unshift(coordinates1[1]);\n          console.log(coordinatesx, coordinatesy);\n        })\n\n        /* can move up into the if/else, but more clear to separate functionality */\n        if (shaping_column !== \"Select\" ) {\n          lasso.items(d3.selectAll(\".dot\"));\n        } else {\n          lasso.items(d3.selectAll(\".dot\"));\n        }\n\n        var len = color.domain().length;\n        // if spectrum\n        if (numerics[color_column] && document.getElementById('cbox1').checked) {\n\n          if (document.getElementById('cbox2').checked) {\n            m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n            m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n          } else {\n            m1 = (d3.min(data.map(function(d) {return parseFloat(d[color_column])})));\n            m2 = (d3.max(data.map(function(d) {return parseFloat(d[color_column])})));\n\n          }\n          console.log(m1, m2);\n          m1 = Math.max(Number.MIN_VALUE, m1);\n          console.log(m1, m2);\n\n          var legend = svg.selectAll(\".legend\")\n          .data(color.domain())\n          .enter().append(\"g\")\n          .attr(\"class\", \"legend\");\n\n          var gradient = legend.append('defs')\n          .append('linearGradient')\n          .attr('id', 'gradient')\n                    .attr('x1', '0%') // bottom\n                    .attr('y1', '100%')\n                    .attr('x2', '0%') // to top\n                    .attr('y2', '0%')\n                    .attr('spreadMethod', 'pad');\n\n                    var pct = Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__[\"linSpace\"])(0, 100, _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"scale\"].length).map(function(d) {\n                      return Math.round(d) + '%';\n                    });\n\n                    var colourPct = d3.zip(pct, _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"scale\"]);\n                    colourPct.forEach(function(d) {\n                      gradient.append('stop')\n                      .attr('offset', d[0])\n                      .attr('stop-color', d[1])\n                      .attr('stop-opacity', 1);\n                    });\n\n                    legend.append('rect')\n                    .attr('x1', 0)\n                    .attr('y1', 0)\n                    .attr('width', 18)\n                    .attr('height', 150)\n                    .attr(\"transform\", \"translate(\" + 582 + \", 0)\")\n                    .style('fill', 'url(#gradient)');\n\n                    var legendScale = d3.scale.linear()\n                    .domain([m1, m2])\n                    .range([150, 0]);\n\n                    var legendAxis = d3.svg.axis()\n                    .scale(legendScale)\n                    .orient(\"right\")\n                // .tickValues([m1, m2])\n                .ticks(10);\n\n                legend.append(\"g\")\n                .attr(\"class\", \"legend axis\")\n                .attr(\"transform\", \"translate(\" + 600 + \", 0)\")\n                .call(legendAxis);\n        } else { // no spectrum\n          console.log(Object);\n          var keys = Object.keys(symbol);\n          let leng = keys.length;\n          if (leng<20 && shaping_column != \"Select\") {\n              // draw legend\n                // ?? Not sure why, but this legend appears not to show\n                var legend = svg.selectAll(\".legend\")\n                .data(keys)\n                .enter().append(\"g\");\n                    // .attr(\"class\", \"legend\");\n                    // .attr(\"transform\", function(d, i) { return \"translate(30,\" + i * 20 + \")\"; });\n                    console.log(keys);\n                    console.log(shaping_column);\n                    console.log(symbol);\n                    console.log(symbols);\n                // draw legend colored rectangles\n                legend.append(\"path\")\n                    // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}).size(function(d) {return sizes[parseInt(symbol[d]/6)%3];}))\n                    .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}))\n                    .attr(\"x\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"width\"] + 0)\n                    .attr(\"width\", 18)\n                    .attr(\"height\", 18)\n                    // .attr(\"transform\", function(d, i) { return \"translate(\" + 20 + \",\" + i*20 + \")\"; });\n                    .attr(\"transform\", function(d, i) { return \"translate(\" + 20 + \",\" + i*20 + \") rotate(\" + sizes[parseInt(symbol[d]%6)][parseInt(symbol[d]/6)%4] + \")\"; });\n                // draw legend text\n                legend.append(\"text\")\n                    // .attr(\"x\", 100 + 0)\n                    // .attr(\"y\", 4)\n                    .attr(\"dy\", \".35em\")\n                    .style(\"text-anchor\", \"begin\")\n                    .text(function(d) { return d;})\n                    .attr(\"transform\", function(d, i) { return \"translate(30,\" + i * 20 + \")\"; });\n                  }\n\n                  if(len <= 30 && color_column != \"Select\") {\n\n                // draw legend\n                var legend = svg.selectAll(\".legend\")\n                .data(color.domain())\n                .enter().append(\"g\")\n                .attr(\"class\", \"legend\")\n                .attr(\"transform\", function(d, i) { return \"translate(0,\" + i * 20 + \")\"; });\n\n                // draw legend colored rectangles\n                legend.append(\"rect\")\n                .attr(\"x\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"width\"] + 6)\n                .attr(\"width\", 18)\n                .attr(\"height\", 18)\n                .style(\"fill\", color);\n\n                // draw legend text\n                legend.append(\"text\")\n                .attr(\"x\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_2__[\"width\"] + 0)\n                .attr(\"y\", 9)\n                .attr(\"dy\", \".35em\")\n                .style(\"text-anchor\", \"end\")\n                .text(function(d) { return d;});\n              }\n            };\n    }); // end load data\n} // end highlighting//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYWluLmpzPzU2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xhc3NpZnksIGJlbmNobWFyaywgdGFidWxhdGUgfSBmcm9tICcuL21vZHVsZXMvdGFibGVfY3JlYXRvci5qcyc7XG5pbXBvcnQge1xuICBnZXRQYXJhbWV0ZXJCeU5hbWUsXG4gIGxpblNwYWNlLFxuICBzZWFyY2hEaWMsXG4gIHhBeGlzLFxuICB4TWFwLFxuICB4U2NhbGUsXG4gIHhWYWx1ZSxcbiAgeUF4aXMsXG4gIHlNYXAsXG4gIHlTY2FsZSxcbiAgeVZhbHVlXG59IGZyb20gJy4vbW9kdWxlcy91dGlsaXRpZXMuanMnO1xuaW1wb3J0IHtcbiAgZDNfY2F0ZWdvcnkyMF9zaHVmZmxlZCxcbiAgaGVpZ2h0LFxuICBtYXJnaW4sXG4gIHNjYWxlLFxuICBzY2FsZV9kLFxuICB3aWR0aFxufSBmcm9tICcuL21vZHVsZXMvY29uc3RhbnRzLmpzJztcblxuLy8gVGhpcyBzdGVwIGlzIHBlcmZvcm1lZCB0byBwYXJzZSB0aGUgdXJsIHRvIGlkZW50aWZ5IHRoZSBkYXRhc2V0IGFuZCB0aGUgZGVmYXVsdCBjb2xvcmluZyBjb2x1bW5cbnZhciBxdWVyeSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpO1xudmFyIHRlbXBfcXVlcnkgPSBxdWVyeS5zcGxpdChcIiZcIik7XG52YXIgZGljdHMgPSB7fTtcbnZhciB0dmFycywgZGF0YXNldDtcbmZvcih2YXIgaT0wO2k8dGVtcF9xdWVyeS5sZW5ndGg7aSsrKSB7XG4gIHR2YXJzID0gdGVtcF9xdWVyeVtpXS5zcGxpdChcIj1cIik7XG4gIGRpY3RzW3R2YXJzWzBdXT10dmFyc1sxXS5yZXBsYWNlKC8lMjAvZywgXCIgXCIpO1xufVxuaWYgKFwiZGF0YXNldFwiIGluIGRpY3RzKSB7XG4gIGRhdGFzZXQgPSBkaWN0c1tcImRhdGFzZXRcIl07XG59IGVsc2Uge1xuICBkYXRhc2V0ID0gXCJqb2luZWRfZGF0YS5jc3ZcIjtcbn1cbnZhciB3ZWlnaHRzXzJkYXJyYXkgPSBbXSwgYmlhc2VzXzFkYXJyYXkgPSBbXSwgdm9jYWJfMWRhcnJheSA9IFtdLCB2ZWN0b3JzcGFjZV8yZGFycmF5ID0gW10sIGJvd18yZGFycmF5ID0gW107XG4vLyBTZW1hbnRpYyBtb2RlbCBvcHRpb24gc2V0IHVwXG5pZiAoXCJzZW1hbnRpY19tb2RlbFwiIGluIGRpY3RzICYmIGRpY3RzW1wic2VtYW50aWNfbW9kZWxcIl0gPT0gXCJ0cnVlXCIpIHtcbiAgY29uc29sZS5sb2coJ1VzaW5nIHNlbWFudGljIG1vZGVsLlxcbkdldHRpbmcgbWF0cmljZXMuLi4nKTtcbiAgdmFyIHdlaWdodHNmaWxlID0gZGF0YXNldC5zcGxpdCgvXFwudFthLXpdezJ9JC8pWzBdKydfd2VpZ2h0cy50eHQnO1xuICB2YXIgYmlhc2VzZmlsZSA9IGRhdGFzZXQuc3BsaXQoL1xcLnRbYS16XXsyfSQvKVswXSsnX2JpYXNlcy50eHQnO1xuICB2YXIgdm9jYWJmaWxlID0gZGF0YXNldC5zcGxpdCgvXFwudFthLXpdezJ9JC8pWzBdKydfdm9jYWIudHh0JztcbiAgdmFyIHZlY3RvcmZpbGUgPSAnVlMtJyArIGRhdGFzZXQuc3BsaXQoXCJfc2VtYW50aWNcIilbMF0rJy50eHQnO1xuICB2YXIgYm93ZmlsZSA9IGRhdGFzZXQuc3BsaXQoL1xcLnRbYS16XXsyfSQvKVswXSsnX2Jvdy50eHQnO1xuXG4gIGNvbnNvbGUubG9nKFwiUmVhZGluZyBcIiArIGJvd2ZpbGUpO1xuICBkMy50c3YoYm93ZmlsZSwgZnVuY3Rpb24odGV4dCl7XG4gICAgYm93XzJkYXJyYXkgPSB0ZXh0Lm1hcCggT2JqZWN0LnZhbHVlcyApO1xuICAgIGJvd18yZGFycmF5ID0gYm93XzJkYXJyYXkubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICByZXR1cm4gZW50cnkubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChlbGVtKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cblxuICBjb25zb2xlLmxvZyhcIlJlYWRpbmcgXCIgKyB2ZWN0b3JmaWxlKTtcbiAgZDMudHN2KHZlY3RvcmZpbGUsIGZ1bmN0aW9uKHRleHQpe1xuICAgIHZlY3RvcnNwYWNlXzJkYXJyYXkgPSB0ZXh0Lm1hcCggT2JqZWN0LnZhbHVlcyApO1xuICAgIHZlY3RvcnNwYWNlXzJkYXJyYXkgPSB2ZWN0b3JzcGFjZV8yZGFycmF5Lm1hcChmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgIC8vIHVzZXJuYW1lIGNvbHVtbiBlbmRzIHVwIGxhc3QgaW4gdGhlIGRpY3Rpb25hcnksIGR1ZSB0byBhbHBoYW51bWVyaWMgc29ydFxuICAgICAgICAgICAgcmV0dXJuIGFyci5zbGljZSgwLC0xKS5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlbGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICB9KTtcbiAgY29uc29sZS5sb2coXCJSZWFkaW5nIFwiICsgd2VpZ2h0c2ZpbGUpO1xuICBkMy50c3Yod2VpZ2h0c2ZpbGUsIGZ1bmN0aW9uKHRleHQpe1xuICAgIHdlaWdodHNfMmRhcnJheSA9IHRleHQubWFwKCBPYmplY3QudmFsdWVzICk7XG4gICAgd2VpZ2h0c18yZGFycmF5ID0gd2VpZ2h0c18yZGFycmF5Lm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5Lm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGVsZW0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zb2xlLmxvZyhcIlJlYWRpbmcgXCIgKyBiaWFzZXNmaWxlKTtcbiAgZDMudHN2KGJpYXNlc2ZpbGUsIGZ1bmN0aW9uKHRleHQpe1xuICAgIGJpYXNlc18xZGFycmF5ID0gdGV4dC5tYXAoIE9iamVjdC52YWx1ZXMgKTtcbiAgICBiaWFzZXNfMWRhcnJheSA9IE9iamVjdC52YWx1ZXMoYmlhc2VzXzFkYXJyYXkubWFwKE51bWJlcikpO1xuICB9KTtcbiAgY29uc29sZS5sb2coXCJSZWFkaW5nIFwiICsgdm9jYWJmaWxlKTtcbiAgZDMudHN2KHZvY2FiZmlsZSwgZnVuY3Rpb24odGV4dCl7XG4gICAgdm9jYWJfMWRhcnJheSA9IHRleHQubWFwKCBPYmplY3QudmFsdWVzICk7XG4gICAgdm9jYWJfMWRhcnJheSA9IE9iamVjdC52YWx1ZXModm9jYWJfMWRhcnJheS5tYXAoU3RyaW5nKSk7XG4gIH0pO1xufVxuXG4vLyBhZGQgdGhlIHRvb2x0aXAgYXJlYSB0byB0aGUgd2VicGFnZVxudmFyIHRvb2x0aXAgPSBkMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcImRpdlwiKVxuLmF0dHIoXCJjbGFzc1wiLCBcInRvb2x0aXBcIilcbi5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cbnZhciB0b29sdGlwMSA9IGQzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwiZGl2XCIpXG4uYXR0cihcImNsYXNzXCIsIFwidG9vbHRpcDFcIilcbi5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cbi8vIHRvIHByaW50IGFsbCB0aGUga2V5IHZhbHVlcyBwYWlycyBvZiBhIHBvaW50ICh1c2VkIHRvIGRpc3BsYXkgdGhlIHN1bW1hcnkgb24gdGhlIHdlYnBhZ2UpXG52YXIgcHJpbnRfYXJyYXkgPSBmdW5jdGlvbihhcnIsIGQpIHtcbiAgdmFyIHggPSBcIlwiO1xuICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgeCA9IHggKyBcIjxiPlwiICsgYXJyW2ldICsgXCI8L2I+OiBcIiArIGRbYXJyW2ldXSArIFwiPGJyPlwiXG4gIH1cbiAgeCA9IHggKyBkLnggKyBcIjxicj5cIiArIGRbXCJ5XCJdO1xuICByZXR1cm4geDtcbn07XG5cbi8vIHNldHVwIGZpbGwgY29sb3JcbnZhciBjb2xvcl9jb2x1bW47XG5cbi8vIGNvbG9yaW5nIHdpbGwgYmUgZG9uZSBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlcyBkZXRlcm1pbmVkIGJ5IGNWYWx1ZVxudmFyIGNWYWx1ZSA9IGZ1bmN0aW9uKGQpIHtyZXR1cm4gZFtjb2xvcl9jb2x1bW5dO30sXG5jVmFsdWUyID0gZnVuY3Rpb24oZCkge3JldHVybiBNYXRoLmxvZyhwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSkpO30sXG5jb2xvciA9IGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwX3NodWZmbGVkKTtcblxuLy8gY3JlYXRlIHRoZSBkcm9wZG93biBtZW51XG4vLyBDb2xvcmluZ1xudmFyIGRyb3BEb3duID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJzZWxlY3RcIilcbi5hdHRyKFwiY2xhc3NcIiwgXCJzZWxlY3QxXCIpXG4uYXR0cihcIm5hbWVcIiwgXCJjb2xvcl9jb2x1bW5cIik7XG5cbi8vIFNlYXJjaGluZ1xudmFyIGRyb3BEb3duMSA9IGQzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwic2VsZWN0XCIpXG4uYXR0cihcImNsYXNzXCIsIFwic2VsZWN0MlwiKVxuLmF0dHIoXCJuYW1lXCIsIFwiY29sb3JfY29sdW1uXCIpO1xuXG4vLyBUcmFuc3BhcmVudFxudmFyIGRyb3BEb3duMiA9IGQzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwic2VsZWN0XCIpXG4uYXR0cihcImNsYXNzXCIsIFwic2VsZWN0NFwiKVxuLmF0dHIoXCJuYW1lXCIsIFwiY29sb3JfY29sdW1uXCIpO1xuXG4vLyBDbGljayBvbiBmZWF0dXJlXG52YXIgZHJvcERvd24zID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJzZWxlY3RcIilcbi5hdHRyKFwiY2xhc3NcIiwgXCJzZWxlY3Q1XCIpXG4uYXR0cihcIm5hbWVcIiwgXCJjb2xvcl9jb2x1bW5cIik7XG5cbi8vIFNoYXBpbmdcbnZhciBkcm9wRG93bjQgPSBkMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcInNlbGVjdFwiKVxuLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdDZcIilcbi5hdHRyKFwibmFtZVwiLCBcImNvbG9yX2NvbHVtblwiKTtcblxudmFyIGNhdGVnb3JpZXMgPSBbXTtcbi8vIGNhdGVnb3J5X3NlYXJjaCBzdG9yZXMgdGhlIG5hbWUgb2YgY29sdW1uIGFjY29yZGluZyB0byB3aGljaCBzZWFyY2hpbmcgaXMgdG8gYmUgZG9uZVxudmFyIGNhdGVnb3J5X3NlYXJjaF9kYXRhID0gW107XG4vLyBjYXRlZ29yaWVzIHN0b3JlcyB0aGUgbmFtZSBvZiBhbGwgdGhlIGNvbHVtbnNcbnZhciBjYXRlZ29yeV9zZWFyY2g7XG5cbmNhdGVnb3JpZXMucHVzaChcIlNlbGVjdFwiKTtcbi8vIGNoZWNrIHdoZXRoZXIgdGhlIHNlYXJjaGluZyBjb2x1bW4gaXMgcHJvdmlkZWQgaW4gdGhlIHVybCBvciBub3RcbmlmIChcInNlYXJjaFwiIGluIGRpY3RzKSB7XG4gIGNhdGVnb3J5X3NlYXJjaCA9IGRpY3RzW1wic2VhcmNoXCJdO1xuICBjYXRlZ29yeV9zZWFyY2hfZGF0YS5wdXNoKGNhdGVnb3J5X3NlYXJjaCk7XG59XG5cblxuLy8gY29sb3JfY29sdW1uIHN0b3JlcyB0aGUgbmFtZSBvZiBjb2x1bW4gYWNjb3JkaW5nIHRvIHdoaWNoIGNvbG9yaW5nIGlzIHRvIGJlIGRvbmVcbi8vIGNoZWNrIHdoZXRoZXIgdGhlIGNvbG9yaW5nIGNvbHVtbiBpcyBwcm92aWRlZCBpbiB0aGUgdXJsIG9yIG5vdFxuaWYgKFwiY29sb3JcIiBpbiBkaWN0cykge1xuICBjb2xvcl9jb2x1bW4gPSBkaWN0c1tcImNvbG9yXCJdO1xuICBjYXRlZ29yaWVzLnB1c2goY29sb3JfY29sdW1uKTtcbn0gZWxzZSB7XG4gIGNvbG9yX2NvbHVtbiA9IFwiU2VsZWN0XCI7XG59XG5cbi8vIGNhdGVnb3JpZXNfY29weV9jb2xvciBpcyBqdXN0IHRoZSBjb3B5IG9mIGNhdGVnb3JpZXNcbnZhciBjYXRlZ29yaWVzX2NvcHlfY29sb3IgPSBbXTtcbmNhdGVnb3JpZXNfY29weV9jb2xvci5wdXNoKGNvbG9yX2NvbHVtbik7XG5cbnZhciBjb2x1bW5zID0gW10sIHRlbXAgPSBbXTtcbi8vIGNvbHVtbiBmb3IgdGhlIHRyYW5zcGFyZW50IHZhbHVlXG52YXIgdHJhbnNwYXJlbnRfY29sdW1uID0gXCJTZWxlY3RcIiwgZmVhdHVyZV9jb2x1bW4gPSBcIlwiLCBzaGFwaW5nX2NvbHVtbiA9IFwiU2VsZWN0XCI7XG5cbmNvbnNvbGUubG9nKCdMb2FkaW5nIG1haW4gZGF0YScpXG4vLyBnZXR0aW5nIGhlYWRlciBmcm9tIGNzdiBmaWxlIHRvIG1ha2UgZHJvd2Rvd24gbWVudXNcbmQzLnRzdihkYXRhc2V0LCBmdW5jdGlvbihkYXRhKSB7XG4gIGNvbnNvbGUubG9nKGRhdGFbMF0pO1xuICB0ZW1wID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XG4gICAgLy8gcmVtb3ZlIHggYW5kIHlcbiAgICB0ZW1wLnNwbGljZSh0ZW1wLmluZGV4T2YoJ3gnKSwgMSk7XG4gICAgdGVtcC5zcGxpY2UodGVtcC5pbmRleE9mKCd5JyksIDEpO1xuXG4gICAgZm9yKHZhciBpPTA7aTx0ZW1wLmxlbmd0aDtpKyspXG4gICAgICBpZiAodGVtcFtpXSAhPSBjYXRlZ29yeV9zZWFyY2gpIHtcbiAgICAgICAgY2F0ZWdvcnlfc2VhcmNoX2RhdGEucHVzaCh0ZW1wW2ldKTtcbiAgICAgIH1cblxuICAgICAgZm9yKHZhciBpPTA7aTx0ZW1wLmxlbmd0aDtpKyspIHtcbiAgICAgICAgLy8gY29sb3JfY29sdW1uIGFscmVhZHkgcHVzaGVkXG4gICAgICAgIGlmICh0ZW1wW2ldICE9IGNvbG9yX2NvbHVtbikge1xuICAgICAgICAgIGNhdGVnb3JpZXMucHVzaCh0ZW1wW2ldKTtcbiAgICAgICAgICBjYXRlZ29yaWVzX2NvcHlfY29sb3IucHVzaCh0ZW1wW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW5zLnB1c2godGVtcFtpXSk7XG4gICAgICB9XG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGUgY29sb3JpbmcgY29sdW1uIGlzIHByb3ZpZGVkIGluIHRoZSB1cmwgb3Igbm90XG4gICAgLy8gPz8gaXMgdGhpcyBuZWNlc3Nhcnk/IGNvbG9yX2NvbHVtbiBpcyBhbHJlYWR5IGRlZmluZWQgd2l0aCB0aGUgc2FtZSBwcm9jZWR1cmUgb3V0c2lkZSB0aGUgZnVuY3Rpb25cbiAgICBpZiAoXCJjb2xvclwiIGluIGRpY3RzKSB7XG4gICAgICBjb2xvcl9jb2x1bW4gPSBjYXRlZ29yaWVzWzFdOyAvLyBzaW5jZSBjb2xvciB3b3VsZCBiZSBmaXJzdCwgc3RhcnQgd2l0aCBuZXh0XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbG9yX2NvbHVtbiA9IFwiU2VsZWN0XCJcbiAgICAgIGNvbG9yX2NvbHVtbiA9IGNhdGVnb3JpZXNbMF07XG4gICAgfVxuICAgIGNhdGVnb3J5X3NlYXJjaCA9IGNhdGVnb3J5X3NlYXJjaF9kYXRhWzBdO1xuICAgIC8vIFNlYXJjaGluZ1xuICAgIGRyb3BEb3duMS5zZWxlY3RBbGwoXCJvcHRpb25cIilcbiAgICAuZGF0YShjYXRlZ29yeV9zZWFyY2hfZGF0YSlcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJvcHRpb25cIilcbiAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkO30pXG4gICAgLnRleHQoZnVuY3Rpb24oZCkge3JldHVybiBkO30pO1xuICAgIC8vIENvbG9yaW5nXG4gICAgZHJvcERvd24uc2VsZWN0QWxsKFwib3B0aW9uXCIpXG4gICAgLmRhdGEoY2F0ZWdvcmllc19jb3B5X2NvbG9yKVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcIm9wdGlvblwiKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7fSlcbiAgICAudGV4dChmdW5jdGlvbihkKSB7cmV0dXJuIGQ7fSk7XG4gICAgLy8gVHJhbnNwYXJlbnRcbiAgICBkcm9wRG93bjIuc2VsZWN0QWxsKFwib3B0aW9uXCIpXG4gICAgLmRhdGEoY2F0ZWdvcnlfc2VhcmNoX2RhdGEpXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKFwib3B0aW9uXCIpXG4gICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtyZXR1cm4gZDt9KTtcbiAgICAvLyBDbGljayBvbiBmZWF0dXJlXG4gICAgZHJvcERvd24zLnNlbGVjdEFsbChcIm9wdGlvblwiKVxuICAgIC5kYXRhKGNhdGVnb3J5X3NlYXJjaF9kYXRhKVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcIm9wdGlvblwiKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7fSlcbiAgICAudGV4dChmdW5jdGlvbihkKSB7cmV0dXJuIGQ7fSk7XG4gICAgLy8gU2hhcGluZ1xuICAgIGRyb3BEb3duNC5zZWxlY3RBbGwoXCJvcHRpb25cIilcbiAgICAuZGF0YShjYXRlZ29yaWVzKVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcIm9wdGlvblwiKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7fSlcbiAgICAudGV4dChmdW5jdGlvbihkKSB7cmV0dXJuIGQ7fSk7XG4gICAgc2hhcGluZ19jb2x1bW4gPSBjYXRlZ29yaWVzWzBdO1xuICAgIGZlYXR1cmVfY29sdW1uID0gY2F0ZWdvcnlfc2VhcmNoX2RhdGFbMF07XG4gICAgdHJhbnNwYXJlbnRfY29sdW1uID0gY2F0ZWdvcnlfc2VhcmNoX2RhdGFbMF07XG4gIH0pO1xuXG4vLyB3aGVuZXZlciBhbnkgb25lIG9mIHRoZSBkcm93ZG93biBtZW51J3Mgc2VsZWN0ZWQgY29sdW1uIGlzIGNoYW5nZXMgdGhlIHBsb3QgaXMgZ2VuZXJhdGVkIGFjY29yZGluZyB0byB0aGUgdmFsdWUgb2YgZHJvcGRvd24gbWVudSBzZWxlY3RlZFxuLy8gQ29sb3JpbmdcbmRyb3BEb3duLm9uKFwiY2hhbmdlXCIsIHBsb3R0aW5nKTtcbi8vIFNlYXJjaGluZ1xuZHJvcERvd24xLm9uKFwiY2hhbmdlXCIsIHBsb3R0aW5nMik7XG4vLyBUcmFuc3BhcmVudFxuZHJvcERvd24yLm9uKFwiY2hhbmdlXCIsIHBsb3R0aW5nMyk7XG4vLyBDbGljayBvbiBmZWF0dXJlXG5kcm9wRG93bjMub24oXCJjaGFuZ2VcIiwgcGxvdHRpbmc0KTtcbi8vIFNoYXBpbmdcbmRyb3BEb3duNC5vbihcImNoYW5nZVwiLCBwbG90dGluZzUpO1xuXG5pZiAoXCJxXCIgaW4gZGljdHMpIHtcbiAgaGlnaGxpZ2h0aW5nKGRpY3RzW1wicVwiXSwgXCJcIiwgXCJcIik7XG59IGVsc2Uge1xuICBoaWdobGlnaHRpbmcoXCJcIiwgXCJcIiwgXCJcIik7XG59XG5cbi8vIHRoZSBmdW5jdGlvbnMgdG8gY2FsbCB3aGVuIHRoZSB2YWx1ZSBvZiBkcm9wZG93biBtZW51IGlzIGNoYW5nZXNcbi8vIENsaWNrIG9uIGZlYXR1cmVcbmZ1bmN0aW9uIHBsb3R0aW5nNCgpe1xuICBmZWF0dXJlX2NvbHVtbiA9IGQzLmV2ZW50LnRhcmdldC52YWx1ZTtcbn1cbi8vIFRyYW5zcGFyZW50XG5mdW5jdGlvbiBwbG90dGluZzMoKXtcbiAgdHJhbnNwYXJlbnRfY29sdW1uID0gZDMuZXZlbnQudGFyZ2V0LnZhbHVlO1xufVxuLy8gU2VhcmNoaW5nXG5mdW5jdGlvbiBwbG90dGluZzIoKXtcbiAgY2F0ZWdvcnlfc2VhcmNoID0gZDMuZXZlbnQudGFyZ2V0LnZhbHVlO1xufVxuXG4vLyBmdW5jdGlvbiB0byBjYWxsIGZvciBjaGFuZ2UgZXZlbnRcbi8vIENvbG9yaW5nXG5mdW5jdGlvbiBwbG90dGluZygpe1xuICBjb2xvcl9jb2x1bW4gPSBkMy5ldmVudC50YXJnZXQudmFsdWU7XG4gIGNWYWx1ZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbY29sb3JfY29sdW1uXTt9O1xuICBsZXQgdmFsX3NlYXJjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF90cmFuc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zcFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU1hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5TWF0Y2hcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICBoaWdobGlnaHRpbmcodmFsX3NlYXJjaCwgdmFsX3RyYW5zcCwgdmFsX29wYWNpdHlNYXRjaCwgdmFsX29wYWNpdHlOb01hdGNoKTtcbn1cblxuLy8gZnVuY3Rpb24gdG8gY2FsbCBmb3IgY2hhbmdlIGV2ZW50XG4vLyBTaGFwaW5nXG5mdW5jdGlvbiBwbG90dGluZzUoKXtcbiAgc2hhcGluZ19jb2x1bW4gPSBkMy5ldmVudC50YXJnZXQudmFsdWU7XG4gIGNWYWx1ZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbY29sb3JfY29sdW1uXTt9O1xuICBsZXQgdmFsX3NlYXJjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF90cmFuc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zcFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU1hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5TWF0Y2hcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICBoaWdobGlnaHRpbmcodmFsX3NlYXJjaCwgdmFsX3RyYW5zcCwgdmFsX29wYWNpdHlNYXRjaCwgdmFsX29wYWNpdHlOb01hdGNoKTtcbn1cblxudmFyIHpvb21lZCA9IDA7XG52YXIgbmVlZFpvb20gPSBmYWxzZTtcbnZhciBuZWVkRHJhd0NpcmNsZSA9IGZhbHNlO1xuXG4vLyBzZWFyY2ggZXZlbnRcbi8vIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBzZWFyY2ggYnV0dG9uIGlzIHByZXNzZWQgYW5kIHBvaW50cyB0aGF0IG1hdGNoZXMgdGhlIHNlYXJjaGVkIHN0cmluZyB3aWxsIGJlIGhpZ2hsaWdodGVkXG5mdW5jdGlvbiBzZWFyY2hFdmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgY29uc29sZS5sb2coZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hUZXh0XCIpLnZhbHVlKTtcbiAgbGV0IHZhbF9zZWFyY2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlYXJjaFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfdHJhbnNwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cmFuc3BUZXh0XCIpLnZhbHVlO1xuICBsZXQgdmFsX29wYWNpdHlNYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU1hdGNoXCIpLnZhbHVlO1xuICBsZXQgdmFsX29wYWNpdHlOb01hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5Tm9NYXRjaFwiKS52YWx1ZTtcbiAgaGlnaGxpZ2h0aW5nKHZhbF9zZWFyY2gsIHZhbF90cmFuc3AsIHZhbF9vcGFjaXR5TWF0Y2gsIHZhbF9vcGFjaXR5Tm9NYXRjaCk7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlYXJjaEV4YWN0TWF0Y2hFdmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoVGV4dFwiKS52YWx1ZSkgc2VhcmNoRXZlbnRIYW5kbGVyKCk7XG59XG5cbi8vIHRyYW5zcGFyZW50IGV2ZW50XG4vLyBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVHJhbnNwYXJlbnQgYnV0dG9uIGlzIHByZXNzZWQgYW5kIHBvaW50cyB0aGF0IHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIHdpbGwgYmUgaGlnaGxpZ2h0ZWRcbmZ1bmN0aW9uIHRyYW5zcGFyZW50U2VhcmNoRXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gIGNvbnNvbGUubG9nKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhbnNwVGV4dFwiKS52YWx1ZSk7XG4gIGxldCB2YWxfc2VhcmNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hUZXh0XCIpLnZhbHVlO1xuICBsZXQgdmFsX3RyYW5zcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhbnNwVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF9vcGFjaXR5TWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlNYXRjaFwiKS52YWx1ZTtcbiAgbGV0IHZhbF9vcGFjaXR5Tm9NYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU5vTWF0Y2hcIikudmFsdWU7XG4gIGhpZ2hsaWdodGluZyh2YWxfc2VhcmNoLCB2YWxfdHJhbnNwLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYW5kbGVDaGVjazEoZXZlbnQpIHtcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhbnNwVGV4dFwiKS52YWx1ZSkge1xuICAgIHRyYW5zcGFyZW50U2VhcmNoRXZlbnRIYW5kbGVyKCk7XG4gIH1cbn1cblxuLy8gPz8gSSBiZWxpZXZlIHRoaXMgZnVuY3Rpb24gaXMgdW51c2VkLCBhbmQgZHJhdyBhbHNvIG1hcHMgdG8gem9vbUV2ZW50SGFuZGxlclxuLy8gaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIERyYXcgYnV0dG9uIGlzIHByZXNzZWQgYW5kIHRoZSBwbG90IHdpbGwgaGlnaGxpZ2h0IHRob3NlIHBvaW50cyB0aGF0IGNvdmVycyBmaXhlZCBwZXJjZW50YWdlIG9mIHBvaW50IGZyb20gdGhlIHBvaW50IG9idGFpbmVkIGJ5IG1vdXNlIGNsaWNrXG5mdW5jdGlvbiBoYW5kbGVDbGljazIoZXZlbnQpe1xuICBzaGFwaW5nX2NvbHVtbiA9IFwiU2VsZWN0XCI7XG4gIGNvbG9yX2NvbHVtbiA9IFwiU2VsZWN0XCI7XG4gIG15Rm9ybS5zZWFyY2hUZXh0LnZhbHVlID0gMDtcbiAgbXlGb3JtMS50cmFuc3BUZXh0LnZhbHVlID0gMDtcbiAgbXlGb3JtMS5vcGFjaXR5TWF0Y2gudmFsdWUgPSAwO1xuICBteUZvcm0xLm9wYWNpdHlOb01hdGNoLnZhbHVlID0gMDtcbiAgZHJvcERvd240LnByb3BlcnR5KCBcInZhbHVlXCIsIFwiU2VsZWN0XCIgKTtcbiAgZHJvcERvd24ucHJvcGVydHkoIFwidmFsdWVcIiwgXCJTZWxlY3RcIiApO1xuICBoaWdobGlnaHRpbmcoXCJcIiwgXCJcIiwgXCJcIik7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3BlY3RydW0gLyBsb2cgZXZlbnRcbi8vIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBzcGVjdHJ1bS9sb2cgaXMgY2hlY2tlZFxuLy8gPz8gQ2FuIHdlIGNvbGxhcHNlIHRyYW5zcGFyZW50U2VhcmNoRXZlbnRIYW5kbGVyLDMsND9cbmZ1bmN0aW9uIHNwZWN0cnVtQW5kTG9nQ29sb3JpbmdFdmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgbGV0IHZhbF9zZWFyY2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlYXJjaFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfdHJhbnNwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cmFuc3BUZXh0XCIpLnZhbHVlO1xuICBsZXQgdmFsX29wYWNpdHlNYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU1hdGNoXCIpLnZhbHVlO1xuICBsZXQgdmFsX29wYWNpdHlOb01hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5Tm9NYXRjaFwiKS52YWx1ZTtcbiAgaGlnaGxpZ2h0aW5nKHZhbF9zZWFyY2gsIHZhbF90cmFuc3AsIHZhbF9vcGFjaXR5TWF0Y2gsIHZhbF9vcGFjaXR5Tm9NYXRjaCk7XG59XG5cbi8vIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiAoPz8gZHJhdyBhbmQpIHpvb20gYnV0dG9uIGlzIHByZXNzZWQgYW5kIHRoZSBwbG90IHdpbGwgem9vbWVkIG91dCBhY2NvcmRpbmcgdG8gdGhlIHBvaW50cyBvYnRhaW5lZCBieSBtb3VzZSBjbGljayBldmVudFxuZnVuY3Rpb24gem9vbUV2ZW50SGFuZGxlcigpe1xuICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94MycpLmNoZWNrZWQpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInpvb214eVwiKS52YWx1ZSA9IFwiXCI7IC8vIGNsZWFyIHRoZSB0ZXh0Ym94XG4gIH1cbiAgbGV0IHZhbF9zZWFyY2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlYXJjaFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfdHJhbnNwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cmFuc3BUZXh0XCIpLnZhbHVlO1xuICBsZXQgdmFsX29wYWNpdHlNYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU1hdGNoXCIpLnZhbHVlO1xuICBsZXQgdmFsX29wYWNpdHlOb01hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5Tm9NYXRjaFwiKS52YWx1ZTtcbiAgbmVlZFpvb20gPSB0cnVlO1xuICBoaWdobGlnaHRpbmcodmFsX3NlYXJjaCwgdmFsX3RyYW5zcCwgdmFsX29wYWNpdHlNYXRjaCwgdmFsX29wYWNpdHlOb01hdGNoKTtcbn1cblxuKGZ1bmN0aW9uIHNldEV2ZW50SGFuZGxlcnMoKSB7XG4gIGxldCB6b29tQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnem9vbS1idXR0b24nKVswXTtcbiAgem9vbUJ1dHRvbi5vbmNsaWNrID0gem9vbUV2ZW50SGFuZGxlcjtcblxuICBsZXQgY29sb3JPcHRpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29sb3Itb3B0aW9uJyk7XG4gIGZvciAoaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICBjb2xvck9wdGlvbnNbaV0ub25jbGljayA9IHNwZWN0cnVtQW5kTG9nQ29sb3JpbmdFdmVudEhhbmRsZXI7XG4gIH07XG5cbiAgbGV0IHNlYXJjaEV4YWN0TWF0Y2hDaGVja2JveCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NlYXJjaC1leGFjdC1tYXRjaCcpWzBdO1xuICBzZWFyY2hFeGFjdE1hdGNoQ2hlY2tib3gub25jbGljayA9IHNlYXJjaEV4YWN0TWF0Y2hFdmVudEhhbmRsZXI7XG5cbiAgbGV0IHNlYXJjaEZvcm1CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzZWFyY2gtYnV0dG9uJylbMF07XG4gIHNlYXJjaEZvcm1CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHNlYXJjaEV2ZW50SGFuZGxlcigpO1xuICB9KTtcblxuICBsZXQgdHJhbnNwYXJlbnRTZWFyY2hCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0cmFuc3BhcmVudC1zZWFyY2gtYnV0dG9uJylbMF07XG4gIHRyYW5zcGFyZW50U2VhcmNoQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0cmFuc3BhcmVudFNlYXJjaEV2ZW50SGFuZGxlcigpO1xuICB9KTtcbn0pKClcblxubGV0IGNvb3JkaW5hdGVzeCA9IFtdO1xubGV0IGNvb3JkaW5hdGVzeSA9IFtdO1xuXG4vLyBmdW5jdGlvbiBmb3IgcGxvdHRpbmdcbmZ1bmN0aW9uIGhpZ2hsaWdodGluZyh2YWxfc2VhcmNoLCB2YWxfdHJhbnNwLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpIHtcblxuICB2YXIgc3ZnLCBtMSwgbTIsIHhfbWF4LCB4X21pbiwgeV9tYXgsIHlfbWluO1xuICB2YXIgdGVtcDEgPSBbXSwgdGVtcDIgPSBbXSwgdGVtcDMgPSBbXTtcbiAgdmFyIGRpY3QxID0ge307XG5cbiAgICAvLyB0byByZW1vdmUgdGhlIGV4aXN0aW5nIHN2ZyBwbG90IGlmIGFueSBhbmQgY2xlYXIgc2lkZSB0YWJsZVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVtbzNcIikuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByZWRpY3RlZF93b3Jkc1wiKS5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJlcXVlbnRfd29yZHNcIikuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBkMy5zZWxlY3QoXCJzdmdcIikucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KFwidGFibGVcIikucmVtb3ZlKCk7XG5cbiAgICAvLyBmdW5jdGlvbiB6b29tKCkge1xuICAgIC8vICBzdmcuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGQzLmV2ZW50LnRyYW5zbGF0ZSArIFwiKXNjYWxlKFwiICsgZDMuZXZlbnQuc2NhbGUgKyBcIilcIik7XG4gICAgLy8gICAgfVxuXG4gICAgLy8gdGhlIGxvY2F0aW9uIG9mIHN2ZyBpbWFnZSB3aWxsIGJlIGRldGVybWluZWRcbiAgICBzdmcgPSBkMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcInN2Z1wiKVxuICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAuYXBwZW5kKFwiZ1wiKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIC8qIGh0dHBzOi8vZ2l0aHViLmNvbS9za29rZW5lcy9EMy1MYXNzby1QbHVnaW5cbiAgICBwbHVnaW4gYWxzbyBoYW5kbGVzIHNlbGVjdGVkIGFuZCBwb3NzaWJsZSBzZXR0aW5ncyAqL1xuICAgIC8vIExhc3NvIHN0YXJ0c1xuICAgIHZhciBsYXNzb19zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZDMuc2VsZWN0KFwidGFibGVcIikucmVtb3ZlKCk7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlbW8zXCIpLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICBsYXNzby5pdGVtcygpXG4gICAgICAgICAgICAuYXR0cihcInJcIiwzLjUpIC8vIHJlc2V0IHNpemVcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIixudWxsKSAvLyBjbGVhciBhbGwgb2YgdGhlIGZpbGxzIChncmV5cyBvdXQpXG4gICAgICAgICAgICAuY2xhc3NlZCh7XCJub3RfcG9zc2libGVcIjp0cnVlLFwic2VsZWN0ZWRcIjpmYWxzZX0pOyAvLyBzdHlsZSBhcyBub3QgcG9zc2libGVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGxhc3NvX2RyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gU3R5bGUgdGhlIHBvc3NpYmxlIGRvdHNcbiAgICAgICAgbGFzc28uaXRlbXMoKS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnBvc3NpYmxlPT09dHJ1ZX0pXG4gICAgICAgIC5jbGFzc2VkKHtcIm5vdF9wb3NzaWJsZVwiOmZhbHNlLFwicG9zc2libGVcIjp0cnVlfSk7XG5cbiAgICAgICAgLy8gU3R5bGUgdGhlIG5vdCBwb3NzaWJsZSBkb3RcbiAgICAgICAgbGFzc28uaXRlbXMoKS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnBvc3NpYmxlPT09ZmFsc2V9KVxuICAgICAgICAuY2xhc3NlZCh7XCJub3RfcG9zc2libGVcIjp0cnVlLFwicG9zc2libGVcIjpmYWxzZX0pXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwMDBcIik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbGFzc29fZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBjb2xvciBvZiBhbGwgZG90c1xuICAgICAgICBsYXNzby5pdGVtcygpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY29sb3IoZFtjb2xvcl9jb2x1bW5dKTsgfSk7XG5cbiAgICAgICAgLy8gU3R5bGUgdGhlIHNlbGVjdGVkIGRvdHNcbiAgICAgICAgbGFzc28uaXRlbXMoKS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnNlbGVjdGVkPT09dHJ1ZX0pXG4gICAgICAgIC5jbGFzc2VkKHtcIm5vdF9wb3NzaWJsZVwiOmZhbHNlLFwicG9zc2libGVcIjpmYWxzZX0pXG4gICAgICAgIC5hdHRyKFwiclwiLDYuNSk7XG5cbiAgICAgICAgLy8gZ2V0IHZhbHVlcyBmb3IgdGFibGUgLT4gYXJyYXkgaW5zaWRlIGEgbGlzdFxuICAgICAgICB2YXIgenN4ID0gbGFzc28uaXRlbXMoKS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnNlbGVjdGVkPT09dHJ1ZX0pO1xuICAgICAgICBsZXQgeF92YWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IHlfdmFsdWVzID0gW107XG4gICAgICAgIC8vIGFkanVzdCB0aGUgeCBhbmQgeSB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHpzeFswXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHhfdmFsdWVzLnB1c2goKCgoKHpzeFswXVtpXS5nZXRCQm94KCkueCs2LjUpICogKHhfbWF4IC0geF9taW4pKS93aWR0aCArIHhfbWluICkpKTtcbiAgICAgICAgICB5X3ZhbHVlcy5wdXNoKCgoKCh6c3hbMF1baV0uZ2V0QkJveCgpLnkrNi41KSAqICh5X21pbiAtIHlfbWF4KSkvaGVpZ2h0ICsgeV9tYXgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGVkX2RhdGE9W10sIHNlbGVjdGVkX2RhdGFfaW5kaWNlcz1bXTtcbiAgICAgICAgLy8gQ29tcGFyZSBldmVyeSBzZWxlY3RlZCBwb2ludCB0byBhbGwgcG9pbnRzICh0ZW1wWClcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gbWF0Y2ggY29vcmRpbmF0ZXMgd2l0aCBhY3R1YWwgZGF0YVxuICAgICAgICBmb3IgKHZhciBpaT0wO2lpPHhfdmFsdWVzLmxlbmd0aDtpaSsrKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJsYXNzb19lbmQgZ2F0aGVyaW5nIHNlbGVjdGVkIGRhdGFcIik7XG4gICAgICAgICAgY29uc29sZS5sb2codGVtcDEubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKHZhciBqaj0wO2pqPHRlbXAxLmxlbmd0aDtqaisrKSB7XG4gICAgICAgICAgICB4X3ZhbHVlc1tpaV0gPSArKHhfdmFsdWVzW2lpXS50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgIHlfdmFsdWVzW2lpXSA9ICsoeV92YWx1ZXNbaWldLnRvRml4ZWQoNSkpO1xuICAgICAgICAgICAgaWYgKCAoeF92YWx1ZXNbaWldID09PSArKHRlbXAxW2pqXS50b0ZpeGVkKDMpKSkgJiYgKHlfdmFsdWVzW2lpXSA9PT0gKyh0ZW1wMltqal0udG9GaXhlZCg1KSkpICkge1xuICAgICAgICAgICAgICBsZXQgYWxsX3ZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBrPTE7azxjYXRlZ29yaWVzLmxlbmd0aDtrKyspIHtcbiAgICAgICAgICAgICAgICBhbGxfdmFsdWVzW2NhdGVnb3JpZXNba11dID0gKGRpY3QxW2NhdGVnb3JpZXNba11dW2pqXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYoc2VhcmNoRGljKHNlbGVjdGVkX2RhdGEsYWxsX3ZhbHVlcyk9PXRydWUpe1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX2RhdGEucHVzaChhbGxfdmFsdWVzKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9kYXRhX2luZGljZXMucHVzaChqaik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVuZGVyIHRoZSB0YWJsZSBmb3IgdGhlIHBvaW50cyBzZWxlY3RlZCBieSBsYXNzb1xuICAgICAgICBpZiAoc2VsZWN0ZWRfZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJSZW5kZXJpbmcgdGFibGUuLi5cIik7XG4gICAgICAgICAgY29uc29sZS5sb2coc2VsZWN0ZWRfZGF0YSk7XG4gICAgICAgICAgY29uc29sZS5sb2coY29sdW1ucyk7XG4gICAgICAgICAgY29uc29sZS5sb2coeF92YWx1ZXMpO1xuICAgICAgICAgIHZhciBwZW9wbGVUYWJsZSA9IHRhYnVsYXRlKHNlbGVjdGVkX2RhdGEsIGNvbHVtbnMsIHhfdmFsdWVzKTtcbiAgICAgICAgICBpZiAoXCJzZW1hbnRpY19tb2RlbFwiIGluIGRpY3RzICYmIGRpY3RzW1wic2VtYW50aWNfbW9kZWxcIl0gPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJlZGljdGluZyB3b3Jkcy4uLlwiKTtcbiAgICAgICAgICAgIGNsYXNzaWZ5KHNlbGVjdGVkX2RhdGFfaW5kaWNlcywgdmVjdG9yc3BhY2VfMmRhcnJheSwgd2VpZ2h0c18yZGFycmF5LCBiaWFzZXNfMWRhcnJheSwgdm9jYWJfMWRhcnJheSk7XG4gICAgICAgICAgICBiZW5jaG1hcmsoc2VsZWN0ZWRfZGF0YV9pbmRpY2VzLCBib3dfMmRhcnJheSwgdm9jYWJfMWRhcnJheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIHN0eWxlIG9mIHRoZSBub3Qgc2VsZWN0ZWQgZG90cyAod2UgbWFkZSB0aGVtIDAuNSBzbWFsbGVyKVxuICAgICAgICBsYXNzby5pdGVtcygpLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGQuc2VsZWN0ZWQ9PT1mYWxzZX0pXG4gICAgICAgIC5jbGFzc2VkKHtcIm5vdF9wb3NzaWJsZVwiOmZhbHNlLFwicG9zc2libGVcIjpmYWxzZX0pXG4gICAgICAgIC5hdHRyKFwiclwiLDMpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwMDBcIik7XG4gICAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBhcmVhIHdoZXJlIHRoZSBsYXNzbyBldmVudCBjYW4gYmUgdHJpZ2dlcmVkXG4gICAgdmFyIGxhc3NvX2FyZWEgPSBzdmcuYXBwZW5kKFwicmVjdFwiKVxuICAgIC5hdHRyKFwid2lkdGhcIix3aWR0aClcbiAgICAuYXR0cihcImhlaWdodFwiLGhlaWdodClcbiAgICAuc3R5bGUoXCJvcGFjaXR5XCIsMCk7XG5cbiAgICAvLyBEZWZpbmUgdGhlIGxhc3NvXG4gICAgdmFyIGxhc3NvID0gZDMubGFzc28oKVxuICAgICAgICAuY2xvc2VQYXRoRGlzdGFuY2UoNzUpIC8vIG1heCBkaXN0YW5jZSBmb3IgdGhlIGxhc3NvIGxvb3AgdG8gYmUgY2xvc2VkXG4gICAgICAgIC5jbG9zZVBhdGhTZWxlY3QodHJ1ZSkgLy8gY2FuIGl0ZW1zIGJlIHNlbGVjdGVkIGJ5IGNsb3NpbmcgdGhlIHBhdGg/XG4gICAgICAgIC5ob3ZlclNlbGVjdCh0cnVlKSAvLyBjYW4gaXRlbXMgYnkgc2VsZWN0ZWQgYnkgaG92ZXJpbmcgb3ZlciB0aGVtP1xuICAgICAgICAuYXJlYShsYXNzb19hcmVhKSAvLyBhcmVhIHdoZXJlIHRoZSBsYXNzbyBjYW4gYmUgc3RhcnRlZFxuICAgICAgICAub24oXCJzdGFydFwiLGxhc3NvX3N0YXJ0KSAvLyBsYXNzbyBzdGFydCBmdW5jdGlvblxuICAgICAgICAub24oXCJkcmF3XCIsbGFzc29fZHJhdykgLy8gbGFzc28gZHJhdyBmdW5jdGlvblxuICAgICAgICAub24oXCJlbmRcIixsYXNzb19lbmQpOyAvLyBsYXNzbyBlbmQgZnVuY3Rpb25cblxuICAgIC8vIEluaXQgdGhlIGxhc3NvIG9iamVjdCBvbiB0aGUgc3ZnOmcgdGhhdCBjb250YWlucyB0aGUgZG90c1xuICAgIHN2Zy5jYWxsKGxhc3NvKTtcblxuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIG1haW4gZGF0YSwgYWdhaW4nKSAvLyBsb2FkIGRhdGFcbiAgICBkMy50c3YoZGF0YXNldCwgZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcblxuICAgICAgICAvLyBjaGFuZ2Ugc3RyaW5nIChmcm9tIENTVikgaW50byBudW1iZXIgZm9ybWF0XG4gICAgICAgIHZhciBudW1lcmljcyA9IHt9LCBzeW1ib2wgPSB7fTtcbiAgICAgICAgLy9PbWl0dGluZyBTZWxlY3QgKDApXG4gICAgICAgIGZvcih2YXIgaT0xO2k8Y2F0ZWdvcmllcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSB2YWx1ZSBmb3IgZWFjaCBjYXRlZ29yeSBrZXkgdG8gZW1wdHkgbGlzdFxuICAgICAgICAgICAgZGljdDFbY2F0ZWdvcmllc1tpXV0gPSBbXTtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgYWxsIGNhdGVnb3JpZXMgYXMgbnVtZXJpY1xuICAgICAgICAgICAgbnVtZXJpY3NbY2F0ZWdvcmllc1tpXV0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIC8vIGNvZXJjZSB0aGUgZGF0YSB0byBudW1iZXJzXG4gICAgICAgICAgICBkLnggPSArZC54O1xuICAgICAgICAgICAgZFtcInlcIl0gPSArZFtcInlcIl07XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0xO2k8Y2F0ZWdvcmllcy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgICAvLyBhZGQgZXZlcnkgYXR0cmlidXRlIG9mIHBvaW50IHRvIHRoZSB7Y2F0ZWdvcnk6W3ZhbDEsdmFsMiwuLi5dfVxuICAgICAgICAgICAgICAgIGRpY3QxW2NhdGVnb3JpZXNbaV1dLnB1c2goZFtjYXRlZ29yaWVzW2ldXSk7XG4gICAgICAgICAgICAgICAgLy8gcmV2b2tlIGEgY2F0ZWdvcnkncyBudW1lcmljcyBzdGF0dXMgaWYgZmluZCBhbiBlbnRyeSBoYXMgYSBub24tSW50IG9yIG5vbi1udWxsIHZhbHVlIGZvciB0aGF0IGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgbnVtZXJpY3NbY2F0ZWdvcmllc1tpXV0gPSBudW1lcmljc1tjYXRlZ29yaWVzW2ldXSAmJiAoZFtjYXRlZ29yaWVzW2ldXSA9PSBcIlwiIHx8IGRbY2F0ZWdvcmllc1tpXV0gPT0gcGFyc2VGbG9hdChkW2NhdGVnb3JpZXNbaV1dKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpbGwgdGhlIHN5bWJvbCBkaWN0aW9uYXJ5IHdpdGggYWxsIHBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgc2hhcGluZyBjb2x1bW4gYXMga2V5c1xuICAgICAgICAgICAgLy8gdmFsdWUgaXMgdGhlIG9yZGVyIG9mIHBvaW50c1xuICAgICAgICAgICAgaWYgKCEoZFtzaGFwaW5nX2NvbHVtbl0gaW4gc3ltYm9sKSkge1xuICAgICAgICAgICAgICBzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dID0gY291bnRlcjtcbiAgICAgICAgICAgICAgY291bnRlciA9IGNvdW50ZXIgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHVzaCBhbGwgeCB2YWx1ZXMsIHkgdmFsdWVzLCBhbmQgYWxsIGNhdGVnb3J5IHNlYXJjaCB2YWx1ZXMgaW50byB0ZW1wMS8yLzNcbiAgICAgICAgICAgIHRlbXAxLnB1c2goZC54KTtcbiAgICAgICAgICAgIHRlbXAyLnB1c2goZFtcInlcIl0pO1xuICAgICAgICAgICAgdGVtcDMucHVzaChkW2NhdGVnb3J5X3NlYXJjaF0pO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRbXCJ6XCJdID09IHBhcnNlSW50KGRbXCJ6XCJdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKG51bWVyaWNzKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhjb2xvcl9jb2x1bW4pO1xuICAgICAgICAvLyBzZXQgY29sb3IgYWNjb3JkaW5nIHRvIHNwZWN0cnVtXG4gICAgICAgIGlmIChudW1lcmljc1tjb2xvcl9jb2x1bW5dICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94MScpLmNoZWNrZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygndXNpbmcgc3BlY3RydW0nKTtcbiAgICAgICAgICAgIC8vIHRha2UgbG9nIGlmIGxvZyBjaGVja2JveCBjaGVja2VkXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gyJykuY2hlY2tlZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygndXNpbmcgbG9nJyk7XG4gICAgICAgICAgICAgIG0xID0gKGQzLm1pbihkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIE1hdGgubG9nKHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKSk7IH0pKSk7XG4gICAgICAgICAgICAgIG0yID0gKGQzLm1heChkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIE1hdGgubG9nKHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKSk7IH0pKSk7XG4gICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdub3QgdXNpbmcgbG9nJyk7XG4gICAgICAgICAgICAgIG0xID0gKGQzLm1pbihkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKX0pKSk7XG4gICAgICAgICAgICAgIG0yID0gKGQzLm1heChkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKX0pKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG0xLCBtMik7XG4gICAgICAgICAgICBtMSA9IE1hdGgubWF4KE51bWJlci5NSU5fVkFMVUUsIG0xKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG0xLCBtMik7XG5cbiAgICAgICAgICAgIGNvbG9yID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4obGluU3BhY2UobTEsIG0yLHNjYWxlLmxlbmd0aCkpXG4gICAgICAgICAgICAgIC8vLmRvbWFpbihsaW5TcGFjZShkMy5taW4oZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBwYXJzZUludChkW2NvbG9yX2NvbHVtbl0pfSkpLCBkMy5tYXgoZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBwYXJzZUludChkW2NvbG9yX2NvbHVtbl0pfSkpLHNjYWxlLmxlbmd0aCkpXG4gICAgICAgICAgICAgIC5yYW5nZShzY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm90IHVzaW5nIHNwZWN0cnVtJyk7XG4gICAgICAgICAgICAgIGNvbG9yID0gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjBfc2h1ZmZsZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbid0IHdhbnQgZG90cyBvdmVybGFwcGluZyBheGlzLCBzbyBhZGQgaW4gYnVmZmVyIHRvIGRhdGEgZG9tYWluXG4gICAgICAgIHZhciB6b29tID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCdab29tJyk7IC8vIHVudXNlZCwgY2FwaXRhbGl6ZWQgWiBhbnl3YXkgYXMgY2hhbmdlZCBhYm92ZVxuXG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNib3gzXCIpLmNoZWNrZWQ9PWZhbHNlKSB7XG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ6b29teHlcIikudmFsdWUgPSBcIlwiO1xuICAgICAgICAgIHpvb21lZCA9IDA7XG4gICAgICAgICAgbmVlZFpvb20gPSBmYWxzZTtcbiAgICAgICAgICB4X21heCA9IGQzLm1heChkYXRhLCB4VmFsdWUpKzE7XG4gICAgICAgICAgeF9taW4gPSBkMy5taW4oZGF0YSwgeFZhbHVlKS0xO1xuICAgICAgICAgIHlfbWF4ID0gZDMubWF4KGRhdGEsIHlWYWx1ZSkrMTtcbiAgICAgICAgICB5X21pbiA9IGQzLm1pbihkYXRhLCB5VmFsdWUpLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB6b29tIGlzIGNoZWNrZWQgYW5kIGNvbmRpdGlvbnMgYXJlIHNhdGlzZmllZFxuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYm94M1wiKS5jaGVja2VkPT10cnVlICAmJiBuZWVkWm9vbSA9PSB0cnVlICYmIGNvb3JkaW5hdGVzeC5sZW5ndGggPj0gMikge1xuXG4gICAgICAgICAgeF9tYXggPSB4U2NhbGUuaW52ZXJ0KE1hdGgubWF4KGNvb3JkaW5hdGVzeFswXSwgY29vcmRpbmF0ZXN4WzFdKSkrMTtcbiAgICAgICAgICB4X21pbiA9IHhTY2FsZS5pbnZlcnQoTWF0aC5taW4oY29vcmRpbmF0ZXN4WzBdLCBjb29yZGluYXRlc3hbMV0pKS0xO1xuICAgICAgICAgIHlfbWF4ID0geVNjYWxlLmludmVydChNYXRoLm1pbihjb29yZGluYXRlc3lbMF0sIGNvb3JkaW5hdGVzeVsxXSkpKzE7XG4gICAgICAgICAgeV9taW4gPSB5U2NhbGUuaW52ZXJ0KE1hdGgubWF4KGNvb3JkaW5hdGVzeVswXSwgY29vcmRpbmF0ZXN5WzFdKSktMTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKHhfbWF4LCB4X21pbiwgeV9tYXgsIHlfbWluKTtcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInpvb214eVwiKS52YWx1ZSA9IFwiWDpbXCIrcGFyc2VJbnQoeF9taW4pK1wiLCBcIitwYXJzZUludCh4X21heCkrXCJdIFk6W1wiK3BhcnNlSW50KHlfbWluKStcIiwgXCIrcGFyc2VJbnQoeV9tYXgpK1wiXVwiO1xuXG4gICAgICAgICAgem9vbWVkID0gMTtcbiAgICAgICAgICBuZWVkWm9vbSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2JveDNcIikuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHpvb20gPSB6b29tLnN1YnN0cigxLCB6b29tLmxlbmd0aC0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFJbmRleCA9IHpvb20uaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB4X21pbiA9IHBhcnNlRmxvYXQoem9vbS5zdWJzdHIoMCwgY29tbWFJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tID0gem9vbS5zdWJzdHIoY29tbWFJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFJbmRleCA9IHpvb20uaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB4X21heCA9IHBhcnNlRmxvYXQoem9vbS5zdWJzdHIoMCwgY29tbWFJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tID0gem9vbS5zdWJzdHIoY29tbWFJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFJbmRleCA9IHpvb20uaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5X21pbiA9IHBhcnNlRmxvYXQoem9vbS5zdWJzdHIoMCwgY29tbWFJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5X21heCA9IHBhcnNlRmxvYXQoem9vbS5zdWJzdHIoY29tbWFJbmRleCsxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4U2NhbGUuZG9tYWluKFt4X21pbiwgeF9tYXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlTY2FsZS5kb21haW4oW3lfbWluLCB5X21heF0pO1xuXG4gICAgICAgIC8vIHhTY2FsZS5kb21haW4oW2QzLm1pbihkYXRhLCB4VmFsdWUpLTEsIGQzLm1heChkYXRhLCB4VmFsdWUpKzFdKTtcbiAgICAgICAgLy8geVNjYWxlLmRvbWFpbihbZDMubWluKGRhdGEsIHlWYWx1ZSktMSwgZDMubWF4KGRhdGEsIHlWYWx1ZSkrMV0pO1xuXG4gICAgICAgIC8vIHgtYXhpc1xuICAgICAgICBsZXQgY3ggPSAwO1xuICAgICAgICBsZXQgY3kgPSAwO1xuICAgICAgICBsZXQgYW5zID0gMDtcblxuICAgICAgICAvLyBkcmF3IHRoZSB4LWF4aXMgb2YgcGxvdFxuICAgICAgICBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgLmNhbGwoeEF4aXMpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwieVwiLCAtNilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLnRleHQoXCJcIik7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgeS1heGlzIG9mIHBsb3RcbiAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInkgYXhpc1wiKVxuICAgICAgICAuY2FsbCh5QXhpcylcbiAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIilcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDYpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuNzFlbVwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAudGV4dChcIlwiKTtcblxuICAgICAgICAvLyB0byBpZGVudGlmeSB0aGUgY29uZGl0aW9uIG9mIHRyYW5zcGFyZW50IGNvbHVtbiB2YWx1ZXNcbiAgICAgICAgaWYgKHRyYW5zcGFyZW50X2NvbHVtbiAhPT0gXCJTZWxlY3RcIiAmJiB2YWxfdHJhbnNwICE9PSBcIlwiICYmIHZhbF9vcGFjaXR5Tm9NYXRjaCAhPT0gXCJcIikge1xuICAgICAgICAgIHRyYW5zcGFyZW50X2NvbHVtbiA9IHRyYW5zcGFyZW50X2NvbHVtbi50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFsX3RyYW5zcCA9IHZhbF90cmFuc3AudG9TdHJpbmcoKTsgLy8gPz8gbm8gdG8gbG93ZXIgY2FzZSBoZXJlP1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbF90cmFuc3AgPSB2YWxfdHJhbnNwLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRyYW5zcGFyID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKHZhbF90cmFuc3AgIT09IFwiXCIgJiYgdHlwZW9mIGQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBwb2ludCdzIHRyYW5zcCBjb2x1bW4gdmFsdWUgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIHNwZWNpZmllZCwgcmV0dXJuIHZhbF9vcGFjaXR5TWF0Y2gsIGVsc2UgdmFsX29wYWNpdHlOb01hdGNoXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDYnKS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVXNpbmcgZXhhY3QgbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZFt0cmFuc3BhcmVudF9jb2x1bW5dID09IHZhbF90cmFuc3A7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGRbdHJhbnNwYXJlbnRfY29sdW1uXSAmJiAoZFt0cmFuc3BhcmVudF9jb2x1bW5dLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWxfdHJhbnNwLnRvTG93ZXJDYXNlKCkpID4gLTEpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWxfb3BhY2l0eU1hdGNoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsX29wYWNpdHlOb01hdGNoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gc2VhcmNoaW5nIGFjY29yZGluZyB0byB0aGUgc3Vic3RyaW5nIGdpdmVuIGFuZCBzZWFyY2hpbmcgY29sdW1uXG4gICAgICAgIHZhciBzZWFyY2hGdW5jID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZFtjYXRlZ29yeV9zZWFyY2hdID09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9NYXRjaCB0cnV0aHkgaWYgbm90IGZvdW5kXG4gICAgICAgICAgICB2YXIgbm9NYXRjaDtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDUnKS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgIG5vTWF0Y2ggPSBkW2NhdGVnb3J5X3NlYXJjaF0gIT0gdmFsX3NlYXJjaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vTWF0Y2ggPSBkW2NhdGVnb3J5X3NlYXJjaF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbF9zZWFyY2gudG9Mb3dlckNhc2UoKSkgPCAwXG4gICAgICAgICAgICAgIHx8IHZhbF9zZWFyY2gubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vTWF0Y2ggPyAxIDogMjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHNlYXJjaEZ1bmMxID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vTWF0Y2ggdHJ1ZSBpZiBub3QgZm91bmRcbiAgICAgICAgICAgIHZhciBub01hdGNoO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94NScpLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgbm9NYXRjaCA9IGQgIT0gdmFsX3NlYXJjaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vTWF0Y2ggPSBkLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWxfc2VhcmNoLnRvTG93ZXJDYXNlKCkpIDwgMFxuICAgICAgICAgICAgICB8fCB2YWxfc2VhcmNoLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub01hdGNoID8gMSA6IDI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBzZWFyY2hlZF9kYXRhID0gW10sIHNlYXJjaGVkX2RhdGFfaW5kaWNlcyA9IFtdLCBkX3RlbXA7XG4gICAgICAgICAgLyogdGVtcDMgaG9sZHMgdGhlIHZhbHVlIG9mIGV2ZXJ5IHBvaW50IGZvciB0aGUgc2VhcmNoIGNvbHVtbiAqL1xuICAgICAgICAgIGZvciAodmFyIGk9MDtpPHRlbXAzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgIC8vIDAgaWYgZm91bmQgdmFsIGluIHRoaXMgcG9pbnQsIDEgaWYgbm90IGZvdW5kXG4gICAgICAgICAgICBpZiAoIHNlYXJjaEZ1bmMxKHRlbXAzW2ldKS0xICkge1xuICAgICAgICAgICAgICBkX3RlbXAgPSB7fTtcbiAgICAgICAgICAgICAgICAvLyBlbnRlciBhbGwgZGF0YSBpbnRvIGRpY3Rpb25hcnlcbiAgICAgICAgICAgICAgICBmb3IodmFyIGo9MTtqPGNhdGVnb3JpZXMubGVuZ3RoO2orKykge1xuICAgICAgICAgICAgICAgICAgZF90ZW1wW2NhdGVnb3JpZXNbal1dID0gZGljdDFbY2F0ZWdvcmllc1tqXV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRvIHNlYXJjaGVkX2RhdGEgaWYgbm90IGFscmVhZHkgaW5cbiAgICAgICAgICAgICAgICBpZihzZWFyY2hEaWMoc2VhcmNoZWRfZGF0YSwgZF90ZW1wKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgc2VhcmNoZWRfZGF0YS5wdXNoKGRfdGVtcCk7XG4gICAgICAgICAgICAgICAgICBzZWFyY2hlZF9kYXRhX2luZGljZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB0YWJsZVxuICAgICAgICBpZiAoIHZhbF9zZWFyY2ggIT0gXCJcIiAmJiBzZWFyY2hlZF9kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcGVvcGxlVGFibGUxID0gdGFidWxhdGUoc2VhcmNoZWRfZGF0YSwgY29sdW1ucyk7XG4gICAgICAgICAgaWYgKFwic2VtYW50aWNfbW9kZWxcIiBpbiBkaWN0cyAmJiBkaWN0c1tcInNlbWFudGljX21vZGVsXCJdID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByZWRpY3Rpbmcgd29yZHMuLi5cIik7XG4gICAgICAgICAgICBjbGFzc2lmeShzZWFyY2hlZF9kYXRhX2luZGljZXMsIHZlY3RvcnNwYWNlXzJkYXJyYXksIHdlaWdodHNfMmRhcnJheSwgYmlhc2VzXzFkYXJyYXksIHZvY2FiXzFkYXJyYXkpO1xuICAgICAgICAgICAgYmVuY2htYXJrKHNlYXJjaGVkX2RhdGFfaW5kaWNlcywgYm93XzJkYXJyYXksIHZvY2FiXzFkYXJyYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkZXRlcm1pbmVzIHRoZSByb3RhdGlvbiBvZiBzeW1ib2xzIHRoYXQgY2FuIGJlIGRvbmVcbiAgICAgICAgdmFyIHNpemVzID0ge31cbiAgICAgICAgc2l6ZXNbMF0gPSBbXCIwXCIsIFwiOTBcIiwgXCIwXCIsIFwiMFwiXVxuICAgICAgICBzaXplc1sxXSA9IFtcIjBcIiwgXCI0NVwiLCBcIjBcIiwgXCIwXCJdXG4gICAgICAgIHNpemVzWzJdID0gW1wiMFwiLCBcIjkwXCIsIFwiMFwiLCBcIjBcIl1cbiAgICAgICAgc2l6ZXNbM10gPSBbXCIwXCIsIFwiNDVcIiwgXCIwXCIsIFwiMFwiXVxuICAgICAgICBzaXplc1s0XSA9IFtcIjBcIiwgXCI5MFwiLCBcIjBcIiwgXCIwXCJdXG4gICAgICAgIHNpemVzWzVdID0gW1wiMFwiLCBcIjBcIiwgXCIwXCIsIFwiMFwiXVxuICAgICAgICB2YXIgc3ltYm9scyA9IFtcImRpYW1vbmRcIiwgXCJjcm9zc1wiLCBcInRyaWFuZ2xlLXVwXCIsIFwic3F1YXJlXCIsIFwidHJpYW5nbGUtZG93blwiLFwiY2lyY2xlXCJdO1xuXG4gICAgICAgIC8qKiogQkVHSU4gZHJhd2luZyBkb3RzICoqKi9cblxuICAgICAgICAvLyBzaGFwaW5nIG9mIHN5bWJvbHMgYWNjb3JkaW5nIHRvIHRoZSBzaGFwaW5nIGNvbHVtblxuICAgICAgICBpZiAoc2hhcGluZ19jb2x1bW4gIT09IFwiU2VsZWN0XCIgKSB7XG4gICAgICAgICAgLy8gY29sb3JfY29sdW1uID0gc2hhcGluZ19jb2x1bW47XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHN2Zy5zZWxlY3RBbGwoXCIuZG90XCIpXG4gICAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgICAuZW50ZXIoKTtcblxuICAgICAgICAgIHBvaW50cy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKXsgcmV0dXJuIChzZWFyY2hGdW5jKGQpID09IDEpOyB9KVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJwb2ludFwiKVxuICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwMDBcIilcbiAgICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMSlcbiAgICAgICAgICAvLyAuYXR0cihcImRcIiwgZDMuc3ZnLnN5bWJvbCgpLnR5cGUoZnVuY3Rpb24oZCkge3JldHVybiBzeW1ib2xzW3N5bWJvbFtkW3NoYXBpbmdfY29sdW1uXV0lNl07fSkuc2l6ZSggZnVuY3Rpb24oZCkge3JldHVybiBzaXplc1twYXJzZUludChzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dLzYpJTRdO30pKVxuICAgICAgICAgIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2XTt9KS5zaXplKGZ1bmN0aW9uKGQpIHtyZXR1cm4gc2VhcmNoRnVuYyhkKS0xID8gMTgwOjMwO30pKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeE1hcChkKSArIFwiLFwiICsgeU1hcChkKSArIFwiKSByb3RhdGUoXCIgKyBzaXplc1twYXJzZUludChzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dJTYpXVtwYXJzZUludChzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dLzYpJTRdICsgXCIpXCI7IH0pXG4gICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDInKS5jaGVja2VkID8gY29sb3IoY1ZhbHVlMihkKSkgOiBjb2xvcihjVmFsdWUoZCkpO30pXG4gICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRyYW5zcGFyKGQpO30pXG5cbiAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgdG9vbHRpcC5odG1sKFxuICAgICAgICAgICAgICBwcmludF9hcnJheShjYXRlZ29yeV9zZWFyY2hfZGF0YSwgZCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIDYwICsgXCJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidG9wXCIsIDMwICsgXCJweFwiKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKFwiclwiLCBmdW5jdGlvbihkKXsgcmV0dXJuIHNlYXJjaEZ1bmMoZCktMSA/IDc6MyA7IH0pXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGNvbG9yKGNWYWx1ZShkKSk7fSk7XG4gICAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLnRleHQoZFtmZWF0dXJlX2NvbHVtbl0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgKGQzLmV2ZW50LnBhZ2VYLTUwKSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAoZDMuZXZlbnQucGFnZVktMzUpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBvaW50cy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKXsgcmV0dXJuIChzZWFyY2hGdW5jKGQpID09IDIpOyB9KVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJwb2ludFwiKVxuICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcInllbGxvd1wiKVxuICAgICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyKVxuICAgICAgICAgIC8vIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2XTt9KS5zaXplKCBmdW5jdGlvbihkKSB7cmV0dXJuIHNpemVzW3BhcnNlSW50KHN5bWJvbFtkW3NoYXBpbmdfY29sdW1uXV0vNiklNF07fSkpXG4gICAgICAgICAgLmF0dHIoXCJkXCIsIGQzLnN2Zy5zeW1ib2woKS50eXBlKGZ1bmN0aW9uKGQpIHtyZXR1cm4gc3ltYm9sc1tzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dJTZdO30pLnNpemUoZnVuY3Rpb24oZCkge3JldHVybiBzZWFyY2hGdW5jKGQpLTEgPyAxODA6MzA7fSkpXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4TWFwKGQpICsgXCIsXCIgKyB5TWFwKGQpICsgXCIpIHJvdGF0ZShcIiArIHNpemVzW3BhcnNlSW50KHN5bWJvbFtkW3NoYXBpbmdfY29sdW1uXV0lNildW3BhcnNlSW50KHN5bWJvbFtkW3NoYXBpbmdfY29sdW1uXV0vNiklNF0gKyBcIilcIjsgfSlcbiAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94MicpLmNoZWNrZWQgPyBjb2xvcihjVmFsdWUyKGQpKSA6IGNvbG9yKGNWYWx1ZShkKSk7fSlcbiAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJhbnNwYXIoZCk7fSlcblxuICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB0b29sdGlwLmh0bWwoXG4gICAgICAgICAgICAgIHByaW50X2FycmF5KGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBkKSlcbiAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgNjAgKyBcInB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgMzAgKyBcInB4XCIpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoXCJyXCIsIGZ1bmN0aW9uKGQpeyByZXR1cm4gc2VhcmNoRnVuYyhkKS0xID8gNzozIDsgfSlcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY29sb3IoY1ZhbHVlKGQpKTt9KTtcbiAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAudGV4dChkW2ZlYXR1cmVfY29sdW1uXSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAoZDMuZXZlbnQucGFnZVgtNTApKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIChkMy5ldmVudC5wYWdlWS0zNSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRyYXcgZG90c1xuICAgICAgICAgIGxldCBtYXJrZWQgPSB7fVxuICAgICAgICAgIHZhciBwb2ludHMgPSBzdmcuc2VsZWN0QWxsKFwiLmRvdFwiKVxuICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgLmVudGVyKCk7XG5cbiAgICAgICAgICBwb2ludHMuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKXsgcmV0dXJuIChzZWFyY2hGdW5jKGQpID09IDEpOyB9KVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb3RcIilcbiAgICAgICAgICAuYXR0cihcInJcIiwgMylcbiAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMDAwXCIpXG4gICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDEpXG4gICAgICAgICAgLmF0dHIoXCJjeFwiLCB4TWFwKVxuICAgICAgICAgIC5hdHRyKFwiY3lcIiwgeU1hcClcbiAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94MicpLmNoZWNrZWQgPyBjb2xvcihjVmFsdWUyKGQpKSA6IGNvbG9yKGNWYWx1ZShkKSk7fSlcbiAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJhbnNwYXIoZCk7fSlcblxuICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB0b29sdGlwLmh0bWwocHJpbnRfYXJyYXkoY2F0ZWdvcnlfc2VhcmNoX2RhdGEsIGQpKVxuICAgICAgICAgICAgLnN0eWxlKFwibGVmdFwiLCA2MCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAzMCArIFwicHhcIik7XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKCEoW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV0gaW4gbWFya2VkKSkge1xuICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0xLCBkMy5ldmVudC5wYWdlWS0xXV0gPSB0cnVlO1xuICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYKzEsIGQzLmV2ZW50LnBhZ2VZKzFdXSA9IHRydWU7XG4gICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgtMSwgZDMuZXZlbnQucGFnZVkrMV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWCsxLCBkMy5ldmVudC5wYWdlWS0xXV0gPSB0cnVlO1xuICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYKzIsIGQzLmV2ZW50LnBhZ2VZLTJdXSA9IHRydWU7XG4gICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgtMiwgZDMuZXZlbnQucGFnZVktMl1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0yLCBkMy5ldmVudC5wYWdlWSsyXV0gPSB0cnVlO1xuICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYKzIsIGQzLmV2ZW50LnBhZ2VZKzJdXSA9IHRydWU7XG4gICAgICAgICAgICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgIC50ZXh0KGRbZmVhdHVyZV9jb2x1bW5dKVxuICAgICAgICAgICAgICAuYXR0cihcInhcIiwgKGQzLmV2ZW50LnBhZ2VYLTUwKSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIChkMy5ldmVudC5wYWdlWS0zNSkpO1xuICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDEudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRvb2x0aXAxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAxLmh0bWwoXCI8Yj5cIitkW2ZlYXR1cmVfY29sdW1uXStcIjwvYj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIChkMy5ldmVudC5wYWdlWCArIDEwKSArIFwicHhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgKGQzLmV2ZW50LnBhZ2VZIC0gMTApICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICBwb2ludHMuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKXsgcmV0dXJuIChzZWFyY2hGdW5jKGQpID09IDIpOyB9KVxuICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb3RcIilcbiAgICAgICAgICAuYXR0cihcInJcIiwgNylcbiAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJ5ZWxsb3dcIilcbiAgICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAgICAgICAuYXR0cihcImN4XCIsIHhNYXApXG4gICAgICAgICAgLmF0dHIoXCJjeVwiLCB5TWFwKVxuICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gyJykuY2hlY2tlZCA/IGNvbG9yKGNWYWx1ZTIoZCkpIDogY29sb3IoY1ZhbHVlKGQpKTt9KVxuICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIixmdW5jdGlvbihkKSB7IHJldHVybiB0cmFuc3BhcihkKTt9KVxuICAgICAgICAgICAgLy8gamFubjogaGVyZSBpcyB0aGUgbW91c2VvdmVyIGRpc3BsYXlcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICAgIHRvb2x0aXAuaHRtbChcbiAgICAgICAgICAgICAgICBwcmludF9hcnJheShjYXRlZ29yeV9zZWFyY2hfZGF0YSwgZCkpXG4gICAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgNjAgKyBcInB4XCIpXG4gICAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAzMCArIFwicHhcIik7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIGlmICghKFtkMy5ldmVudC5wYWdlWCwgZDMuZXZlbnQucGFnZVldIGluIG1hcmtlZCkpe1xuICAgICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgtMSwgZDMuZXZlbnQucGFnZVktMV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYKzEsIGQzLmV2ZW50LnBhZ2VZKzFdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0xLCBkMy5ldmVudC5wYWdlWSsxXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgrMSwgZDMuZXZlbnQucGFnZVktMV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYKzIsIGQzLmV2ZW50LnBhZ2VZLTJdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0yLCBkMy5ldmVudC5wYWdlWS0yXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgtMiwgZDMuZXZlbnQucGFnZVkrMl1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYKzIsIGQzLmV2ZW50LnBhZ2VZKzJdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAudGV4dChkW2ZlYXR1cmVfY29sdW1uXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgKGQzLmV2ZW50LnBhZ2VYLTUwKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgKGQzLmV2ZW50LnBhZ2VZLTM1KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqIEVORCBkcmF3aW5nIGRvdHMgKioqL1xuXG4gICAgICAgIC8vIHRoZSBldmVudCB0byBjYWxsIG9uIGNsaWNrIGV2ZW50XG4gICAgICAgIHN2Zy5vbihcImNsaWNrXCIsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gc3ZnLnNlbGVjdChcIiNteVRleHRcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgICB0b29sdGlwMS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgdmFyIGNvb3JkaW5hdGVzMSA9IGQzLm1vdXNlKHRoaXMpO1xuICAgICAgICAgIGNvb3JkaW5hdGVzeC51bnNoaWZ0KGNvb3JkaW5hdGVzMVswXSk7XG4gICAgICAgICAgY29vcmRpbmF0ZXN5LnVuc2hpZnQoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhjb29yZGluYXRlc3gsIGNvb3JkaW5hdGVzeSk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgLyogY2FuIG1vdmUgdXAgaW50byB0aGUgaWYvZWxzZSwgYnV0IG1vcmUgY2xlYXIgdG8gc2VwYXJhdGUgZnVuY3Rpb25hbGl0eSAqL1xuICAgICAgICBpZiAoc2hhcGluZ19jb2x1bW4gIT09IFwiU2VsZWN0XCIgKSB7XG4gICAgICAgICAgbGFzc28uaXRlbXMoZDMuc2VsZWN0QWxsKFwiLmRvdFwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzc28uaXRlbXMoZDMuc2VsZWN0QWxsKFwiLmRvdFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuID0gY29sb3IuZG9tYWluKCkubGVuZ3RoO1xuICAgICAgICAvLyBpZiBzcGVjdHJ1bVxuICAgICAgICBpZiAobnVtZXJpY3NbY29sb3JfY29sdW1uXSAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDEnKS5jaGVja2VkKSB7XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gyJykuY2hlY2tlZCkge1xuICAgICAgICAgICAgbTEgPSAoZDMubWluKGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtyZXR1cm4gTWF0aC5sb2cocGFyc2VGbG9hdChkW2NvbG9yX2NvbHVtbl0pKTsgfSkpKTtcbiAgICAgICAgICAgIG0yID0gKGQzLm1heChkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIE1hdGgubG9nKHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKSk7IH0pKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0xID0gKGQzLm1pbihkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKX0pKSk7XG4gICAgICAgICAgICBtMiA9IChkMy5tYXgoZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSl9KSkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUubG9nKG0xLCBtMik7XG4gICAgICAgICAgbTEgPSBNYXRoLm1heChOdW1iZXIuTUlOX1ZBTFVFLCBtMSk7XG4gICAgICAgICAgY29uc29sZS5sb2cobTEsIG0yKTtcblxuICAgICAgICAgIHZhciBsZWdlbmQgPSBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKVxuICAgICAgICAgIC5kYXRhKGNvbG9yLmRvbWFpbigpKVxuICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpO1xuXG4gICAgICAgICAgdmFyIGdyYWRpZW50ID0gbGVnZW5kLmFwcGVuZCgnZGVmcycpXG4gICAgICAgICAgLmFwcGVuZCgnbGluZWFyR3JhZGllbnQnKVxuICAgICAgICAgIC5hdHRyKCdpZCcsICdncmFkaWVudCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsICcwJScpIC8vIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAnMTAwJScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsICcwJScpIC8vIHRvIHRvcFxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCAnMCUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3ByZWFkTWV0aG9kJywgJ3BhZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwY3QgPSBsaW5TcGFjZSgwLCAxMDAsIHNjYWxlLmxlbmd0aCkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkKSArICclJztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG91clBjdCA9IGQzLnppcChwY3QsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyUGN0LmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFwcGVuZCgnc3RvcCcpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ29mZnNldCcsIGRbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0b3AtY29sb3InLCBkWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdG9wLW9wYWNpdHknLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDE4KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTUwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIDU4MiArIFwiLCAwKVwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAndXJsKCNncmFkaWVudCknKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVnZW5kU2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFttMSwgbTJdKVxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzE1MCwgMF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWdlbmRBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgICAgICAuc2NhbGUobGVnZW5kU2NhbGUpXG4gICAgICAgICAgICAgICAgICAgIC5vcmllbnQoXCJyaWdodFwiKVxuICAgICAgICAgICAgICAgIC8vIC50aWNrVmFsdWVzKFttMSwgbTJdKVxuICAgICAgICAgICAgICAgIC50aWNrcygxMCk7XG5cbiAgICAgICAgICAgICAgICBsZWdlbmQuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsZWdlbmQgYXhpc1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgNjAwICsgXCIsIDApXCIpXG4gICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kQXhpcyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIG5vIHNwZWN0cnVtXG4gICAgICAgICAgY29uc29sZS5sb2coT2JqZWN0KTtcbiAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN5bWJvbCk7XG4gICAgICAgICAgbGV0IGxlbmcgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZzwyMCAmJiBzaGFwaW5nX2NvbHVtbiAhPSBcIlNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgIC8vIGRyYXcgbGVnZW5kXG4gICAgICAgICAgICAgICAgLy8gPz8gTm90IHN1cmUgd2h5LCBidXQgdGhpcyBsZWdlbmQgYXBwZWFycyBub3QgdG8gc2hvd1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmQgPSBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGtleXMpXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoMzAsXCIgKyBpICogMjAgKyBcIilcIjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzaGFwaW5nX2NvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN5bWJvbHMpO1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgbGVnZW5kIGNvbG9yZWQgcmVjdGFuZ2xlc1xuICAgICAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgICAgIC8vIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2RdJTZdO30pLnNpemUoZnVuY3Rpb24oZCkge3JldHVybiBzaXplc1twYXJzZUludChzeW1ib2xbZF0vNiklM107fSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2RdJTZdO30pKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgd2lkdGggKyAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDE4KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxOClcbiAgICAgICAgICAgICAgICAgICAgLy8gLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAyMCArIFwiLFwiICsgaSoyMCArIFwiKVwiOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAyMCArIFwiLFwiICsgaSoyMCArIFwiKSByb3RhdGUoXCIgKyBzaXplc1twYXJzZUludChzeW1ib2xbZF0lNildW3BhcnNlSW50KHN5bWJvbFtkXS82KSU0XSArIFwiKVwiOyB9KTtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGxlZ2VuZCB0ZXh0XG4gICAgICAgICAgICAgICAgbGVnZW5kLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLy8gLmF0dHIoXCJ4XCIsIDEwMCArIDApXG4gICAgICAgICAgICAgICAgICAgIC8vIC5hdHRyKFwieVwiLCA0KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiLjM1ZW1cIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJiZWdpblwiKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkO30pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKDMwLFwiICsgaSAqIDIwICsgXCIpXCI7IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZihsZW4gPD0gMzAgJiYgY29sb3JfY29sdW1uICE9IFwiU2VsZWN0XCIpIHtcblxuICAgICAgICAgICAgICAgIC8vIGRyYXcgbGVnZW5kXG4gICAgICAgICAgICAgICAgdmFyIGxlZ2VuZCA9IHN2Zy5zZWxlY3RBbGwoXCIubGVnZW5kXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY29sb3IuZG9tYWluKCkpXG4gICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsZWdlbmRcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgaSAqIDIwICsgXCIpXCI7IH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gZHJhdyBsZWdlbmQgY29sb3JlZCByZWN0YW5nbGVzXG4gICAgICAgICAgICAgICAgbGVnZW5kLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgd2lkdGggKyA2KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgMTgpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMTgpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XG5cbiAgICAgICAgICAgICAgICAvLyBkcmF3IGxlZ2VuZCB0ZXh0XG4gICAgICAgICAgICAgICAgbGVnZW5kLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgd2lkdGggKyAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCA5KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICB9KTsgLy8gZW5kIGxvYWQgZGF0YVxufSAvLyBlbmQgaGlnaGxpZ2h0aW5nIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/modules/constants.js":
/*!**********************************!*\
  !*** ./src/modules/constants.js ***!
  \**********************************/
/*! exports provided: margin, width, height, d3_category20_shuffled, scale_d, scale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"margin\", function() { return margin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"width\", function() { return width; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"height\", function() { return height; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d3_category20_shuffled\", function() { return d3_category20_shuffled; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale_d\", function() { return scale_d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\nconst margin = { top: 90, right: 40, bottom: 40, left: 40 };\nconst width = 700 - margin.left - margin.right;\nconst height = 750 - margin.top - margin.bottom;\n\n// Can generate more with http://jnnnnn.github.io/category-colors-2L-inplace.html if want more\nconst d3_category20_shuffled = [\n\t\"#1f77b4\",\n\t\"#ff7f0e\",\n\t\"#2ca02c\",\n\t\"#d62728\",\n\t\"#9467bd\",\n\t\"#8c564b\",\n\t\"#e377c2\",\n\t\"#7f7f7f\",\n\t\"#bcbd22\",\n\t\"#17becf\",\n\t\"#aec7e8\",\n\t\"#ffbb78\",\n\t\"#98df8a\",\n\t\"#ff9896\",\n\t\"#c5b0d5\",\n\t\"#c49c94\",\n\t\"#f7b6d2\",\n\t\"#c7c7c7\",\n\t\"#dbdb8d\",\n\t\"#9edae5\"\n];\n\n// provides different colored spectrum\nconst scale_d = {\n  'puOr11': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n  'spectral8': ['#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#e6f598', '#abdda4', '#66c2a5', '#3288bd'],\n  'redBlackGreen': ['#ff0000', '#AA0000', '#550000', '#005500', '#00AA00', '#00ff00'],\n};\nconst scale = scale_d['spectral8'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9jb25zdGFudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9jb25zdGFudHMuanM/MzRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgbWFyZ2luID0geyB0b3A6IDkwLCByaWdodDogNDAsIGJvdHRvbTogNDAsIGxlZnQ6IDQwIH07XG5leHBvcnQgY29uc3Qgd2lkdGggPSA3MDAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbmV4cG9ydCBjb25zdCBoZWlnaHQgPSA3NTAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuLy8gQ2FuIGdlbmVyYXRlIG1vcmUgd2l0aCBodHRwOi8vam5ubm5uLmdpdGh1Yi5pby9jYXRlZ29yeS1jb2xvcnMtMkwtaW5wbGFjZS5odG1sIGlmIHdhbnQgbW9yZVxuZXhwb3J0IGNvbnN0IGQzX2NhdGVnb3J5MjBfc2h1ZmZsZWQgPSBbXG5cdFwiIzFmNzdiNFwiLFxuXHRcIiNmZjdmMGVcIixcblx0XCIjMmNhMDJjXCIsXG5cdFwiI2Q2MjcyOFwiLFxuXHRcIiM5NDY3YmRcIixcblx0XCIjOGM1NjRiXCIsXG5cdFwiI2UzNzdjMlwiLFxuXHRcIiM3ZjdmN2ZcIixcblx0XCIjYmNiZDIyXCIsXG5cdFwiIzE3YmVjZlwiLFxuXHRcIiNhZWM3ZThcIixcblx0XCIjZmZiYjc4XCIsXG5cdFwiIzk4ZGY4YVwiLFxuXHRcIiNmZjk4OTZcIixcblx0XCIjYzViMGQ1XCIsXG5cdFwiI2M0OWM5NFwiLFxuXHRcIiNmN2I2ZDJcIixcblx0XCIjYzdjN2M3XCIsXG5cdFwiI2RiZGI4ZFwiLFxuXHRcIiM5ZWRhZTVcIlxuXTtcblxuLy8gcHJvdmlkZXMgZGlmZmVyZW50IGNvbG9yZWQgc3BlY3RydW1cbmV4cG9ydCBjb25zdCBzY2FsZV9kID0ge1xuICAncHVPcjExJzogWycjN2YzYjA4JywgJyNiMzU4MDYnLCAnI2UwODIxNCcsICcjZmRiODYzJywgJyNmZWUwYjYnLCAnI2Y3ZjdmNycsICcjZDhkYWViJywgJyNiMmFiZDInLCAnIzgwNzNhYycsICcjNTQyNzg4JywgJyMyZDAwNGInXSxcbiAgJ3NwZWN0cmFsOCc6IFsnI2Q1M2U0ZicsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZTZmNTk4JywgJyNhYmRkYTQnLCAnIzY2YzJhNScsICcjMzI4OGJkJ10sXG4gICdyZWRCbGFja0dyZWVuJzogWycjZmYwMDAwJywgJyNBQTAwMDAnLCAnIzU1MDAwMCcsICcjMDA1NTAwJywgJyMwMEFBMDAnLCAnIzAwZmYwMCddLFxufTtcbmV4cG9ydCBjb25zdCBzY2FsZSA9IHNjYWxlX2RbJ3NwZWN0cmFsOCddOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/modules/constants.js\n");

/***/ }),

/***/ "./src/modules/table_creator.js":
/*!**************************************!*\
  !*** ./src/modules/table_creator.js ***!
  \**************************************/
/*! exports provided: classify, benchmark, tabulate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"classify\", function() { return classify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"benchmark\", function() { return benchmark; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tabulate\", function() { return tabulate; });\n// ****************************\n// Create Table functionality\n// ****************************\n\n// Utility function used for predicting words in semantic setting\n// Source: https://stackoverflow.com/a/11792230/7100714\nfunction findIndicesOfMax(inp, count) {\n  let outp = new Array();\n  for (let i = 0; i < inp.length; i++) {\n    outp.push(i);\n    if (outp.length > count) {\n      outp.sort((a, b) => (inp[b] - inp[a]));\n      outp.pop();\n    }\n  }\n  return outp;\n}\n\nfunction classify (indices, vs_source, weights_source, biases_source, vocab_source) {\n  let sum_vectors = vs_source[indices[0]];\n  for (i=1; i < indices.length; i++) {\n    sum_vectors = math.add(sum_vectors, vs_source[indices[i]]);\n  }\n  let avg_vector = sum_vectors.map((x) =>  ( x / indices.length ));\n  let mul = math.multiply(avg_vector, weights_source);\n  let add = math.add(mul, biases_source);\n  // get indices of 10 greatest elements\n  let topIndices = findIndicesOfMax(add, 10);\n  console.log(\"Top predicted vocab words:\");\n  let strbuilder = \"Predicted words:\";\n  for (i=0; i<10; i++) {\n    console.log((i+1) + \": \" + vocab_source[topIndices[i]]);\n    strbuilder += \" \" + vocab_source[topIndices[i]] + \",\";\n  }\n  document.getElementById(\"predicted_words\").innerHTML = strbuilder.slice(0, -1);\n};\n\nfunction benchmark (indices, bow_source, vocab_source) { // may need to adjust\n  var num_indices = indices.length;\n  var vocab_freq = bow_source[indices[0]];\n  for (i=1; i < num_indices; i++) {\n    vocab_freq = math.add(vocab_freq, bow_source[indices[i]]);\n  }\n  // get indices of 10 greatest elements\n  var topIndices = findIndicesOfMax(vocab_freq, 10);\n  console.log(\"Most frequent words:\");\n  var strbuilder = \"Most frequent words:\";\n  for (i=0; i<10; i++) {\n    console.log((i+1) + \": \" + vocab_source[topIndices[i]]);\n    strbuilder += \" \" + vocab_source[topIndices[i]] + \",\";\n  }\n  document.getElementById(\"frequent_words\").innerHTML = strbuilder.slice(0, -1);\n};\n\n// displays the summary in tabular form\nfunction tabulate (data_tab, columns) {\n  let table = d3.select(\"body\").append(\"table\").attr(\"class\", \"select3\"),\n      thead = table.append(\"thead\"),\n      tbody = table.append(\"tbody\");\n\n  // append the header row\n  thead.append(\"tr\")\n       .selectAll(\"th\")\n       .data(columns)\n       .enter()\n       .append(\"th\")\n       .text((column) => (column ));\n\n  // create a row for each object in the data\n  let rows = tbody.selectAll(\"tr\")\n                  .data(data_tab)\n                  .enter()\n                  .append(\"tr\");\n\n  // create a cell in each row for each column\n  let cells = rows.selectAll(\"td\")\n                  .data((row) => {\n                    return columns.map((column) => {\n                      return {column: column, value: row[column]};\n                    });\n                  })\n                  .enter()\n                  .append(\"td\")\n                  .attr(\"style\", \"font-family: Courier\") // sets the font style\n                  .html((d) => ( d.value ) );\n\n  /*\n    crossfilter dimensions and group by\n    http://animateddata.co.uk/articles/crossfilter/\n  */\n  let output = \"\";\n  let cf = crossfilter(data_tab);\n  /* crossfilter currently only supports up to 32 columns) */\n  for (var i=0;i<columns.length && i<32;i++) {\n    let byParty = cf.dimension((party) => ( party[columns[i]] ));\n    output = output + \"<b>\" + columns[i] + \"</b>\" + \"<br>\";\n    var groupByParty = byParty.group();\n    groupByParty.top(5).forEach(function(p, i) {\n      output = output + p.key + \": \" + p.value + \"<br>\";\n      console.log(p.key + \": \" + p.value);\n    });\n    output = output + \"<br>\";\n  }\n  // side table\n  document.getElementById(\"demo3\").innerHTML = output;\n  return table;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy90YWJsZV9jcmVhdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvdGFibGVfY3JlYXRvci5qcz85ZTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIENyZWF0ZSBUYWJsZSBmdW5jdGlvbmFsaXR5XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdXNlZCBmb3IgcHJlZGljdGluZyB3b3JkcyBpbiBzZW1hbnRpYyBzZXR0aW5nXG4vLyBTb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTc5MjIzMC83MTAwNzE0XG5mdW5jdGlvbiBmaW5kSW5kaWNlc09mTWF4KGlucCwgY291bnQpIHtcbiAgbGV0IG91dHAgPSBuZXcgQXJyYXkoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnAubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwLnB1c2goaSk7XG4gICAgaWYgKG91dHAubGVuZ3RoID4gY291bnQpIHtcbiAgICAgIG91dHAuc29ydCgoYSwgYikgPT4gKGlucFtiXSAtIGlucFthXSkpO1xuICAgICAgb3V0cC5wb3AoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc2lmeSAoaW5kaWNlcywgdnNfc291cmNlLCB3ZWlnaHRzX3NvdXJjZSwgYmlhc2VzX3NvdXJjZSwgdm9jYWJfc291cmNlKSB7XG4gIGxldCBzdW1fdmVjdG9ycyA9IHZzX3NvdXJjZVtpbmRpY2VzWzBdXTtcbiAgZm9yIChpPTE7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtX3ZlY3RvcnMgPSBtYXRoLmFkZChzdW1fdmVjdG9ycywgdnNfc291cmNlW2luZGljZXNbaV1dKTtcbiAgfVxuICBsZXQgYXZnX3ZlY3RvciA9IHN1bV92ZWN0b3JzLm1hcCgoeCkgPT4gICggeCAvIGluZGljZXMubGVuZ3RoICkpO1xuICBsZXQgbXVsID0gbWF0aC5tdWx0aXBseShhdmdfdmVjdG9yLCB3ZWlnaHRzX3NvdXJjZSk7XG4gIGxldCBhZGQgPSBtYXRoLmFkZChtdWwsIGJpYXNlc19zb3VyY2UpO1xuICAvLyBnZXQgaW5kaWNlcyBvZiAxMCBncmVhdGVzdCBlbGVtZW50c1xuICBsZXQgdG9wSW5kaWNlcyA9IGZpbmRJbmRpY2VzT2ZNYXgoYWRkLCAxMCk7XG4gIGNvbnNvbGUubG9nKFwiVG9wIHByZWRpY3RlZCB2b2NhYiB3b3JkczpcIik7XG4gIGxldCBzdHJidWlsZGVyID0gXCJQcmVkaWN0ZWQgd29yZHM6XCI7XG4gIGZvciAoaT0wOyBpPDEwOyBpKyspIHtcbiAgICBjb25zb2xlLmxvZygoaSsxKSArIFwiOiBcIiArIHZvY2FiX3NvdXJjZVt0b3BJbmRpY2VzW2ldXSk7XG4gICAgc3RyYnVpbGRlciArPSBcIiBcIiArIHZvY2FiX3NvdXJjZVt0b3BJbmRpY2VzW2ldXSArIFwiLFwiO1xuICB9XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJlZGljdGVkX3dvcmRzXCIpLmlubmVySFRNTCA9IHN0cmJ1aWxkZXIuc2xpY2UoMCwgLTEpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJlbmNobWFyayAoaW5kaWNlcywgYm93X3NvdXJjZSwgdm9jYWJfc291cmNlKSB7IC8vIG1heSBuZWVkIHRvIGFkanVzdFxuICB2YXIgbnVtX2luZGljZXMgPSBpbmRpY2VzLmxlbmd0aDtcbiAgdmFyIHZvY2FiX2ZyZXEgPSBib3dfc291cmNlW2luZGljZXNbMF1dO1xuICBmb3IgKGk9MTsgaSA8IG51bV9pbmRpY2VzOyBpKyspIHtcbiAgICB2b2NhYl9mcmVxID0gbWF0aC5hZGQodm9jYWJfZnJlcSwgYm93X3NvdXJjZVtpbmRpY2VzW2ldXSk7XG4gIH1cbiAgLy8gZ2V0IGluZGljZXMgb2YgMTAgZ3JlYXRlc3QgZWxlbWVudHNcbiAgdmFyIHRvcEluZGljZXMgPSBmaW5kSW5kaWNlc09mTWF4KHZvY2FiX2ZyZXEsIDEwKTtcbiAgY29uc29sZS5sb2coXCJNb3N0IGZyZXF1ZW50IHdvcmRzOlwiKTtcbiAgdmFyIHN0cmJ1aWxkZXIgPSBcIk1vc3QgZnJlcXVlbnQgd29yZHM6XCI7XG4gIGZvciAoaT0wOyBpPDEwOyBpKyspIHtcbiAgICBjb25zb2xlLmxvZygoaSsxKSArIFwiOiBcIiArIHZvY2FiX3NvdXJjZVt0b3BJbmRpY2VzW2ldXSk7XG4gICAgc3RyYnVpbGRlciArPSBcIiBcIiArIHZvY2FiX3NvdXJjZVt0b3BJbmRpY2VzW2ldXSArIFwiLFwiO1xuICB9XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJlcXVlbnRfd29yZHNcIikuaW5uZXJIVE1MID0gc3RyYnVpbGRlci5zbGljZSgwLCAtMSk7XG59O1xuXG4vLyBkaXNwbGF5cyB0aGUgc3VtbWFyeSBpbiB0YWJ1bGFyIGZvcm1cbmV4cG9ydCBmdW5jdGlvbiB0YWJ1bGF0ZSAoZGF0YV90YWIsIGNvbHVtbnMpIHtcbiAgbGV0IHRhYmxlID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJ0YWJsZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJzZWxlY3QzXCIpLFxuICAgICAgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKSxcbiAgICAgIHRib2R5ID0gdGFibGUuYXBwZW5kKFwidGJvZHlcIik7XG5cbiAgLy8gYXBwZW5kIHRoZSBoZWFkZXIgcm93XG4gIHRoZWFkLmFwcGVuZChcInRyXCIpXG4gICAgICAgLnNlbGVjdEFsbChcInRoXCIpXG4gICAgICAgLmRhdGEoY29sdW1ucylcbiAgICAgICAuZW50ZXIoKVxuICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgIC50ZXh0KChjb2x1bW4pID0+IChjb2x1bW4gKSk7XG5cbiAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICBsZXQgcm93cyA9IHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgICAgICAgICAgICAuZGF0YShkYXRhX3RhYilcbiAgICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidHJcIik7XG5cbiAgLy8gY3JlYXRlIGEgY2VsbCBpbiBlYWNoIHJvdyBmb3IgZWFjaCBjb2x1bW5cbiAgbGV0IGNlbGxzID0gcm93cy5zZWxlY3RBbGwoXCJ0ZFwiKVxuICAgICAgICAgICAgICAgICAgLmRhdGEoKHJvdykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGRcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwic3R5bGVcIiwgXCJmb250LWZhbWlseTogQ291cmllclwiKSAvLyBzZXRzIHRoZSBmb250IHN0eWxlXG4gICAgICAgICAgICAgICAgICAuaHRtbCgoZCkgPT4gKCBkLnZhbHVlICkgKTtcblxuICAvKlxuICAgIGNyb3NzZmlsdGVyIGRpbWVuc2lvbnMgYW5kIGdyb3VwIGJ5XG4gICAgaHR0cDovL2FuaW1hdGVkZGF0YS5jby51ay9hcnRpY2xlcy9jcm9zc2ZpbHRlci9cbiAgKi9cbiAgbGV0IG91dHB1dCA9IFwiXCI7XG4gIGxldCBjZiA9IGNyb3NzZmlsdGVyKGRhdGFfdGFiKTtcbiAgLyogY3Jvc3NmaWx0ZXIgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdXAgdG8gMzIgY29sdW1ucykgKi9cbiAgZm9yICh2YXIgaT0wO2k8Y29sdW1ucy5sZW5ndGggJiYgaTwzMjtpKyspIHtcbiAgICBsZXQgYnlQYXJ0eSA9IGNmLmRpbWVuc2lvbigocGFydHkpID0+ICggcGFydHlbY29sdW1uc1tpXV0gKSk7XG4gICAgb3V0cHV0ID0gb3V0cHV0ICsgXCI8Yj5cIiArIGNvbHVtbnNbaV0gKyBcIjwvYj5cIiArIFwiPGJyPlwiO1xuICAgIHZhciBncm91cEJ5UGFydHkgPSBieVBhcnR5Lmdyb3VwKCk7XG4gICAgZ3JvdXBCeVBhcnR5LnRvcCg1KS5mb3JFYWNoKGZ1bmN0aW9uKHAsIGkpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dCArIHAua2V5ICsgXCI6IFwiICsgcC52YWx1ZSArIFwiPGJyPlwiO1xuICAgICAgY29uc29sZS5sb2cocC5rZXkgKyBcIjogXCIgKyBwLnZhbHVlKTtcbiAgICB9KTtcbiAgICBvdXRwdXQgPSBvdXRwdXQgKyBcIjxicj5cIjtcbiAgfVxuICAvLyBzaWRlIHRhYmxlXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVtbzNcIikuaW5uZXJIVE1MID0gb3V0cHV0O1xuICByZXR1cm4gdGFibGU7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/table_creator.js\n");

/***/ }),

/***/ "./src/modules/utilities.js":
/*!**********************************!*\
  !*** ./src/modules/utilities.js ***!
  \**********************************/
/*! exports provided: searchDic, linSpace, getParameterByName, xValue, yValue, xScale, yScale, xMap, yMap, xAxis, yAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"searchDic\", function() { return searchDic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linSpace\", function() { return linSpace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getParameterByName\", function() { return getParameterByName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xValue\", function() { return xValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yValue\", function() { return yValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xScale\", function() { return xScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yScale\", function() { return yScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xMap\", function() { return xMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yMap\", function() { return yMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xAxis\", function() { return xAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yAxis\", function() { return yAxis; });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/modules/constants.js\");\n\n\n// used to search a particular substring in the list of requested feature column\n// used to determine whether we should add allValues to selectedData, hence the t/f -> f/t\nfunction searchDic(selectedData, allValues) {\n  for(let i=0; i < selectedData.length; i++) {\n    if (JSON.stringify(allValues) === JSON.stringify(selectedData[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction linSpace(start, end, n) {\n  var out = [];\n  var delta = (end - start) / (n - 1);\n  var i = 0;\n  while(i < (n - 1)) {\n    out.push(start + (i * delta));\n    i++;\n  }\n  out.push(end);\n  return out;\n}\n\n// Checks the url query for name=value and extracts the value\n// *************************************************************\n// TODO: This can likely be accomplished using newer browser APIS, e.g.:\n// let queryParams = (new URL(location)).searchParams;\nfunction getParameterByName(name, url) {\n  if (!url) url = window.location.href;\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n  results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\n\n// The following two functions are getter methods:\n// value accessor - returns the value to encode for a given data object.\n// Type Signature: data Object -> value\nfunction xValue(data) { return data.x };\nfunction yValue(data) { return data[\"y\"] };\n\n// The following two functions map a value to a visual display encoding, such as\n// a pixel position.\n// Type Signature: Value -> display Object\nlet xScale = d3.scale.linear().range([0, _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"]]);\nlet yScale = d3.scale.linear().range([_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"], 0]);\n\n// The following two functions map from data Object to display value (? not sure\n// if value of object)\n// Type Signature: data Object -> display Object (? Might be value)\nfunction xMap(data) { return xScale(xValue(data)) };\nfunction yMap(data) { return yScale(yValue(data)) };\n\n// The following two variables are the X and Y axis objects\nlet xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\");\nlet yAxis = d3.svg.axis().scale(yScale).orient(\"left\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy91dGlsaXRpZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91dGlsaXRpZXMuanM/OTc2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoZWlnaHQsIG1hcmdpbiwgd2lkdGggfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbi8vIHVzZWQgdG8gc2VhcmNoIGEgcGFydGljdWxhciBzdWJzdHJpbmcgaW4gdGhlIGxpc3Qgb2YgcmVxdWVzdGVkIGZlYXR1cmUgY29sdW1uXG4vLyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHdlIHNob3VsZCBhZGQgYWxsVmFsdWVzIHRvIHNlbGVjdGVkRGF0YSwgaGVuY2UgdGhlIHQvZiAtPiBmL3RcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hEaWMoc2VsZWN0ZWREYXRhLCBhbGxWYWx1ZXMpIHtcbiAgZm9yKGxldCBpPTA7IGkgPCBzZWxlY3RlZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoYWxsVmFsdWVzKSA9PT0gSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWREYXRhW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpblNwYWNlKHN0YXJ0LCBlbmQsIG4pIHtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgZGVsdGEgPSAoZW5kIC0gc3RhcnQpIC8gKG4gLSAxKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZShpIDwgKG4gLSAxKSkge1xuICAgIG91dC5wdXNoKHN0YXJ0ICsgKGkgKiBkZWx0YSkpO1xuICAgIGkrKztcbiAgfVxuICBvdXQucHVzaChlbmQpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vLyBDaGVja3MgdGhlIHVybCBxdWVyeSBmb3IgbmFtZT12YWx1ZSBhbmQgZXh0cmFjdHMgdGhlIHZhbHVlXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyBUT0RPOiBUaGlzIGNhbiBsaWtlbHkgYmUgYWNjb21wbGlzaGVkIHVzaW5nIG5ld2VyIGJyb3dzZXIgQVBJUywgZS5nLjpcbi8vIGxldCBxdWVyeVBhcmFtcyA9IChuZXcgVVJMKGxvY2F0aW9uKSkuc2VhcmNoUGFyYW1zO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtZXRlckJ5TmFtZShuYW1lLCB1cmwpIHtcbiAgaWYgKCF1cmwpIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxbXFxdXS9nLCBcIlxcXFwkJlwiKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIls/Jl1cIiArIG5hbWUgKyBcIig9KFteJiNdKil8JnwjfCQpXCIpLFxuICByZXN1bHRzID0gcmVnZXguZXhlYyh1cmwpO1xuICBpZiAoIXJlc3VsdHMpIHJldHVybiBudWxsO1xuICBpZiAoIXJlc3VsdHNbMl0pIHJldHVybiAnJztcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHRzWzJdLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikpO1xufVxuXG4vLyBUaGUgZm9sbG93aW5nIHR3byBmdW5jdGlvbnMgYXJlIGdldHRlciBtZXRob2RzOlxuLy8gdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4vLyBUeXBlIFNpZ25hdHVyZTogZGF0YSBPYmplY3QgLT4gdmFsdWVcbmV4cG9ydCBmdW5jdGlvbiB4VmFsdWUoZGF0YSkgeyByZXR1cm4gZGF0YS54IH07XG5leHBvcnQgZnVuY3Rpb24geVZhbHVlKGRhdGEpIHsgcmV0dXJuIGRhdGFbXCJ5XCJdIH07XG5cbi8vIFRoZSBmb2xsb3dpbmcgdHdvIGZ1bmN0aW9ucyBtYXAgYSB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzXG4vLyBhIHBpeGVsIHBvc2l0aW9uLlxuLy8gVHlwZSBTaWduYXR1cmU6IFZhbHVlIC0+IGRpc3BsYXkgT2JqZWN0XG5leHBvcnQgbGV0IHhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLnJhbmdlKFswLCB3aWR0aF0pO1xuZXhwb3J0IGxldCB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbi8vIFRoZSBmb2xsb3dpbmcgdHdvIGZ1bmN0aW9ucyBtYXAgZnJvbSBkYXRhIE9iamVjdCB0byBkaXNwbGF5IHZhbHVlICg/IG5vdCBzdXJlXG4vLyBpZiB2YWx1ZSBvZiBvYmplY3QpXG4vLyBUeXBlIFNpZ25hdHVyZTogZGF0YSBPYmplY3QgLT4gZGlzcGxheSBPYmplY3QgKD8gTWlnaHQgYmUgdmFsdWUpXG5leHBvcnQgZnVuY3Rpb24geE1hcChkYXRhKSB7IHJldHVybiB4U2NhbGUoeFZhbHVlKGRhdGEpKSB9O1xuZXhwb3J0IGZ1bmN0aW9uIHlNYXAoZGF0YSkgeyByZXR1cm4geVNjYWxlKHlWYWx1ZShkYXRhKSkgfTtcblxuLy8gVGhlIGZvbGxvd2luZyB0d28gdmFyaWFibGVzIGFyZSB0aGUgWCBhbmQgWSBheGlzIG9iamVjdHNcbmV4cG9ydCBsZXQgeEF4aXMgPSBkMy5zdmcuYXhpcygpLnNjYWxlKHhTY2FsZSkub3JpZW50KFwiYm90dG9tXCIpO1xuZXhwb3J0IGxldCB5QXhpcyA9IGQzLnN2Zy5heGlzKCkuc2NhbGUoeVNjYWxlKS5vcmllbnQoXCJsZWZ0XCIpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/utilities.js\n");

/***/ })

/******/ });