/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: dataset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dataset\", function() { return dataset; });\n/* harmony import */ var _modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/table_creator.js */ \"./src/modules/table_creator.js\");\n/* harmony import */ var _modules_tooltips_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/tooltips.js */ \"./src/modules/tooltips.js\");\n/* harmony import */ var _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/utilities.js */ \"./src/modules/utilities.js\");\n/* harmony import */ var _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/constants.js */ \"./src/modules/constants.js\");\n/* harmony import */ var _modules_dots_artist_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/dots_artist.js */ \"./src/modules/dots_artist.js\");\n/* harmony import */ var _modules_svg_initializer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/svg_initializer.js */ \"./src/modules/svg_initializer.js\");\n/* harmony import */ var _modules_dropdown_builder_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/dropdown_builder.js */ \"./src/modules/dropdown_builder.js\");\n/* harmony import */ var _vendors_url_search_params_polyfill_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vendors/url_search_params_polyfill.js */ \"./src/vendors/url_search_params_polyfill.js\");\n// *******************************************\n// Imports\n// *******************************************\n\n// TODO: Currently, we're importing everything into global scope. YUCK.\n// But as we disentangle scope violations and figure out better ways of incorporating\n// dependency injection, we can start to implement stronger encapsulation and message passing\n\n\n\n\n\n\n\n\n\n\n// *******************************************\n// Begin Script\n// *******************************************\n\nconst dataset = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get(\"dataset\") || \"joined_data.csv\";\n\n\nvar weights_2darray = [], biases_1darray = [], vocab_1darray = [], vectorspace_2darray = [], bow_2darray = [];\n// Semantic model option set up\nif (_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get(\"semantic_model\") === \"true\") {\n  console.log('Using semantic model.\\nGetting matrices...');\n  var weightsfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_weights.txt';\n  var biasesfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_biases.txt';\n  var vocabfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_vocab.txt';\n  var vectorfile = 'VS-' + dataset.split(\"_semantic\")[0]+'.txt';\n  var bowfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_bow.txt';\n\n  console.log(\"Reading \" + bowfile);\n  d3.tsv(bowfile, function(text){\n    bow_2darray = text.map( Object.values );\n    bow_2darray = bow_2darray.map(function(entry) {\n      return entry.map(function(elem) {\n        return Math.round(parseFloat(elem));\n      });\n    });\n  });\n\n  console.log(\"Reading \" + vectorfile);\n  d3.tsv(vectorfile, function(text){\n    vectorspace_2darray = text.map( Object.values );\n    vectorspace_2darray = vectorspace_2darray.map(function(arr) {\n            // username column ends up last in the dictionary, due to alphanumeric sort\n            return arr.slice(0,-1).map(function(elem) {\n              return parseFloat(elem);\n            });\n          });\n  });\n  console.log(\"Reading \" + weightsfile);\n  d3.tsv(weightsfile, function(text){\n    weights_2darray = text.map( Object.values );\n    weights_2darray = weights_2darray.map(function(entry) {\n      return entry.map(function(elem) {\n        return parseFloat(elem);\n      });\n    });\n  });\n  console.log(\"Reading \" + biasesfile);\n  d3.tsv(biasesfile, function(text){\n    biases_1darray = text.map( Object.values );\n    biases_1darray = Object.values(biases_1darray.map(Number));\n  });\n  console.log(\"Reading \" + vocabfile);\n  d3.tsv(vocabfile, function(text){\n    vocab_1darray = text.map( Object.values );\n    vocab_1darray = Object.values(vocab_1darray.map(String));\n  });\n}\n\n// categories stores the name of all the columns\nvar categories = [];\nlet defaultValue = 'Select';\ncategories.push(defaultValue);\n// Not sure this is really what we want -- if you enter the wrong parameter value,\n// it may make things screwy...we can probably make it a bit more fault tolerant\nif (_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get(\"color\")) categories.push(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get(\"color\"));\n\n// category_search stores the name of column according to which searching is to be done\nvar category_search_data = [];\n\n// check whether the searching column is provided in the url or not\nlet category_search = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get(\"search\");\nif (category_search) category_search_data.push(category_search);\n\n// setup fill color\n// color_column stores the name of column according to which coloring is to be done\n// check whether the coloring column is provided in the url or not\nlet color_column = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get(\"color\") || \"Select\";\n\n// categories_copy_color is just the copy of categories\nvar categories_copy_color = [];\ncategories_copy_color.push(color_column);\n\nvar columns = [];\n// column for the transparent value\nvar transparent_column = \"Select\", feature_column = \"\", shaping_column = \"Select\";\n\nfunction extractCategoryLabelsFromData(data) {\n  console.log('Loading main data')\n  function extractCategoryHeaders(data) {\n    let categoryHeadersFromFirstRowOfData = [];\n    categoryHeadersFromFirstRowOfData = Object.keys(data[0]);\n    // remove x and y\n    categoryHeadersFromFirstRowOfData.splice(\n      categoryHeadersFromFirstRowOfData.indexOf('x'), 1\n    );\n    categoryHeadersFromFirstRowOfData.splice(\n      categoryHeadersFromFirstRowOfData.indexOf('y'), 1\n    );\n    return categoryHeadersFromFirstRowOfData;\n  }\n  let categoryHeaders = extractCategoryHeaders(data);\n\n  for(var i=0;i<categoryHeaders.length;i++) {\n    if (categoryHeaders[i] != category_search) {\n      category_search_data.push(categoryHeaders[i]);\n    }\n  }\n\n  for(var i=0;i<categoryHeaders.length;i++) {\n    // color_column already pushed\n    if (categoryHeaders[i] != color_column) {\n      categories.push(categoryHeaders[i]);\n      categories_copy_color.push(categoryHeaders[i]);\n    }\n    columns.push(categoryHeaders[i]);\n  }\n  let dropdownBuilder = new _modules_dropdown_builder_js__WEBPACK_IMPORTED_MODULE_6__[\"DropdownBuilder\"]();\n  dropdownBuilder.build(category_search_data, categories_copy_color, categories);\n  dropdownBuilder.setDropdownEventHandlers(\n                   plotting,\n                   plotting2,\n                   plotting3,\n                   plotting4,\n                   plotting5\n                 );\n\n  category_search = category_search_data[0];\n  shaping_column = categories[0];\n  feature_column = category_search_data[0];\n  transparent_column = category_search_data[0];\n};\n\n// getting header from csv file to make drowdown menus\n// NOTE: tsv() is an async function\nd3.tsv(dataset, extractCategoryLabelsFromData);\n\nlet createColorValue = (targetColumn) => {\n  return (data) => {\n    return data[targetColumn];\n  };\n};\n// need to rename this function to be more descriptive\nlet createColorValue2 = (targetColumn) => {\n  return (data) => {\n    return Math.log(parseFloat(data[targetColumn]));\n  };\n};\nlet color = d3.scale.ordinal().range(_modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"d3_category20_shuffled\"]);\nlet colorValueFunction = createColorValue(color_column);\nlet colorValueFunction2 = createColorValue2(color_column);\n// Initial plot draw happens here:\nhighlighting(colorValueFunction, colorValueFunction2, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get(\"q\") || \"\", \"\", \"\")\n\n// the functions to call when the value of dropdown menu is changes\n// Click on feature\nfunction plotting4(){\n  feature_column = d3.event.target.value;\n}\n// Transparent\nfunction plotting3(){\n  transparent_column = d3.event.target.value;\n}\n// Searching\nfunction plotting2(){\n  category_search = d3.event.target.value;\n}\n\n// function to call for change event\n// Coloring\nfunction plotting(){\n  color_column = d3.event.target.value;\n  colorValueFunction = createColorValue(color_column);\n  colorValueFunction2 = createColorValue2(color_column);\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(colorValueFunction, colorValueFunction2, val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n}\n\n// function to call for change event\n// Shaping\nfunction plotting5(){\n  shaping_column = d3.event.target.value;\n  colorValueFunction = createColorValue(color_column);\n  colorValueFunction2 = createColorValue2(color_column);\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(colorValueFunction, colorValueFunction2, val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n}\n\nvar zoomed = 0;\nvar needZoom = false;\nvar needDrawCircle = false;\n\n// search event\n// it will be executed when search button is pressed and points that matches the searched string will be highlighted\nfunction searchEventHandler(event) {\n  console.log(document.getElementById(\"searchText\").value);\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(colorValueFunction, colorValueFunction2, val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n  return false;\n}\nfunction searchExactMatchEventHandler(event) {\n  if (document.getElementById(\"searchText\").value) searchEventHandler();\n}\n\n// transparent event\n// it will be executed when Transparent button is pressed and points that satisfies the condition will be highlighted\nfunction transparentSearchEventHandler(event) {\n  console.log(document.getElementById(\"transpText\").value);\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(colorValueFunction, colorValueFunction2, val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n  return false;\n}\nfunction handleCheck1(event) {\n  if (document.getElementById(\"transpText\").value) {\n    transparentSearchEventHandler();\n  }\n}\n\n// ?? I believe this function is unused, and draw also maps to zoomEventHandler\n// it will be executed when Draw button is pressed and the plot will highlight those points that covers fixed percentage of point from the point obtained by mouse click\nfunction handleClick2(event){\n  shaping_column = \"Select\";\n  color_column = \"Select\";\n  myForm.searchText.value = 0;\n  myForm1.transpText.value = 0;\n  myForm1.opacityMatch.value = 0;\n  myForm1.opacityNoMatch.value = 0;\n  shapingDropdown.property( \"value\", \"Select\" );\n  dropDown.property( \"value\", \"Select\" );\n  highlighting(colorValueFunction, colorValueFunction2, \"\", \"\", \"\");\n  return false;\n}\n\n// spectrum / log event\n// it will be executed when spectrum/log is checked\n// ?? Can we collapse transparentSearchEventHandler,3,4?\nfunction spectrumAndLogColoringEventHandler(event) {\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  highlighting(colorValueFunction, colorValueFunction2, val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n}\n\n// it will be executed when (?? draw and) zoom button is pressed and the plot will zoomed out according to the points obtained by mouse click event\nfunction zoomEventHandler(){\n  if (!document.getElementById('cbox3').checked) {\n    document.getElementById(\"zoomxy\").value = \"\"; // clear the textbox\n  }\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n  let val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  let val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  needZoom = true;\n  highlighting(colorValueFunction, colorValueFunction2, val_search, val_transp, val_opacityMatch, val_opacityNoMatch);\n}\n\n(function setEventHandlers() {\n  let zoomButton = document.getElementsByClassName('zoom-button')[0];\n  zoomButton.onclick = zoomEventHandler;\n\n  let colorOptions = document.getElementsByClassName('color-option');\n  for (let i = 0; i < 2; i++) {\n    colorOptions[i].onclick = spectrumAndLogColoringEventHandler;\n  };\n\n  let searchExactMatchCheckbox = document.getElementsByClassName('search-exact-match')[0];\n  searchExactMatchCheckbox.onclick = searchExactMatchEventHandler;\n\n  let searchFormButton = document.getElementsByClassName('search-button')[0];\n  searchFormButton.addEventListener('click', (event) => {\n    event.preventDefault();\n    searchEventHandler();\n  });\n\n  let transparentSearchButton = document.getElementsByClassName('transparent-search-button')[0];\n  transparentSearchButton.addEventListener('click', (event) => {\n    event.preventDefault();\n    transparentSearchEventHandler();\n  });\n\n  // let transparencyExactMatch = document.getElementsByClassName('transparency-exact-match')[0];\n  // transparencyExactMatch.addEventListener('change', (event) => {\n  //   event.preventDefault();\n  //   transparentSearchEventHandler();\n  // });\n})()\n\nlet coordinatesx = [];\nlet coordinatesy = [];\n\n// function for plotting\nfunction highlighting(cValue, cValue2, val_search, val_transp, val_opacityMatch, val_opacityNoMatch) {\n\n  let m1, m2, x_max, x_min, y_max, y_min;\n  var temp1 = [], temp2 = [], temp3 = [];\n  var dict1 = {};\n\n  // to remove the existing svg plot if any and clear side table\n  document.getElementById(\"demo3\").innerHTML = \"\";\n  document.getElementById(\"predicted_words\").innerHTML = \"\";\n  document.getElementById(\"frequent_words\").innerHTML = \"\";\n  d3.select(\"svg\").remove();\n  d3.select(\"table\").remove();\n\n  d3.tsv(dataset, function(error, data) {\n    console.log('Loading main data, again') // load data\n    // change string (from CSV) into number format\n    var numerics = {}, symbol = {};\n    //Omitting Select (0)\n    for(var i=1;i<categories.length;i++) {\n      // initialize the value for each category key to empty list\n      dict1[categories[i]] = [];\n      // initialize all categories as numeric\n      numerics[categories[i]] = 1;\n    }\n    let counter = 0;\n    data.forEach(function(d) {\n    // coerce the data to numbers\n    d.x = +d.x;\n    d[\"y\"] = +d[\"y\"];\n\n    for(var i=1;i<categories.length;i++){\n      // add every attribute of point to the {category:[val1,val2,...]}\n      dict1[categories[i]].push(d[categories[i]]);\n      // revoke a category's numerics status if find an entry has a non-Int or non-null value for that category\n      numerics[categories[i]] = numerics[categories[i]] && (d[categories[i]] == \"\" || d[categories[i]] == parseFloat(d[categories[i]]));\n    }\n    // fill the symbol dictionary with all possible values of the shaping column as keys\n    // value is the order of points\n    if (!(d[shaping_column] in symbol)) {\n      symbol[d[shaping_column]] = counter;\n      counter = counter + 1;\n    }\n    // push all x values, y values, and all category search values into temp1/2/3\n    temp1.push(d.x);\n    temp2.push(d[\"y\"]);\n    temp3.push(d[category_search]);\n    // console.log(d[\"z\"] == parseInt(d[\"z\"]));\n  });\n  console.log(\"Numerics: \", numerics);\n  console.log(\"Color Column: \",color_column);\n  // set color according to spectrum\n  if (numerics[color_column] && document.getElementById('cbox1').checked) {\n    console.log('using spectrum');\n    // take log if log checkbox checked\n    if (document.getElementById('cbox2').checked) {\n      console.log('using log');\n      m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n      m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n    } else{\n      console.log('not using log');\n      m1 = (d3.min(data.map(function(d) {return parseFloat(d[color_column])})));\n      m2 = (d3.max(data.map(function(d) {return parseFloat(d[color_column])})));\n    }\n\n    console.log(m1, m2);\n    m1 = Math.max(Number.MIN_VALUE, m1);\n    console.log(m1, m2);\n\n    color = d3.scale.linear()\n    .domain(Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"linSpace\"])(m1, m2,_modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"scale\"].length))\n      //.domain(linSpace(d3.min(data.map(function(d) {return parseInt(d[color_column])})), d3.max(data.map(function(d) {return parseInt(d[color_column])})),scale.length))\n      .range(_modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"scale\"]);\n  } else {\n    console.log('not using spectrum');\n    color = d3.scale.ordinal().range(_modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"d3_category20_shuffled\"]);\n  }\n\n  // don't want dots overlapping axis, so add in buffer to data domain\n  var zoom = Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"getParameterByName\"])('Zoom'); // unused, capitalized Z anyway as changed above\n\n  if (document.getElementById(\"cbox3\").checked==false) {\n    document.getElementById(\"zoomxy\").value = \"\";\n    zoomed = 0;\n    needZoom = false;\n    x_max = d3.max(data, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"xValue\"])+1;\n    x_min = d3.min(data, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"xValue\"])-1;\n    y_max = d3.max(data, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"yValue\"])+1;\n    y_min = d3.min(data, _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"yValue\"])-1;\n  }\n\n  // if zoom is checked and conditions are satisfied\n  if (document.getElementById(\"cbox3\").checked==true  && needZoom == true && coordinatesx.length >= 2) {\n\n    x_max = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"xScale\"].invert(Math.max(coordinatesx[0], coordinatesx[1]))+1;\n    x_min = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"xScale\"].invert(Math.min(coordinatesx[0], coordinatesx[1]))-1;\n    y_max = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"yScale\"].invert(Math.min(coordinatesy[0], coordinatesy[1]))+1;\n    y_min = _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"yScale\"].invert(Math.max(coordinatesy[0], coordinatesy[1]))-1;\n\n    console.log(x_max, x_min, y_max, y_min);\n    document.getElementById(\"zoomxy\").value = \"X:[\"+parseInt(x_min)+\", \"+parseInt(x_max)+\"] Y:[\"+parseInt(y_min)+\", \"+parseInt(y_max)+\"]\";\n\n    zoomed = 1;\n    needZoom = false;\n          // document.getElementById(\"cbox3\").checked = false;\n          /*\n                    zoom = zoom.substr(1, zoom.length-2);\n                    commaIndex = zoom.indexOf(',');\n                    x_min = parseFloat(zoom.substr(0, commaIndex));\n                    zoom = zoom.substr(commaIndex+1);\n                    commaIndex = zoom.indexOf(',');\n                    x_max = parseFloat(zoom.substr(0, commaIndex));\n                    zoom = zoom.substr(commaIndex+1);\n                    commaIndex = zoom.indexOf(',');\n                    y_min = parseFloat(zoom.substr(0, commaIndex));\n                    y_max = parseFloat(zoom.substr(commaIndex+1));\n                    */\n  }\n  _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"xScale\"].domain([x_min, x_max]);\n  _modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"yScale\"].domain([y_min, y_max]);\n\n  // xScale.domain([d3.min(data, xValue)-1, d3.max(data, xValue)+1]);\n  // yScale.domain([d3.min(data, yValue)-1, d3.max(data, yValue)+1]);\n\n\n  // I know it looks ugly injecting so many arguments into the initializer right now,\n  // but at least we're being explicit about dependencies as opposed to\n  // implicit/throwing everything into global state\n  let svgInitializer = new _modules_svg_initializer_js__WEBPACK_IMPORTED_MODULE_5__[\"SvgInitializer\"](color, color_column, x_max, x_min, y_max, y_min, temp1, temp2, categories, dict1, columns);\n  let svg = svgInitializer.initializeWithLasso();\n  let lasso = svgInitializer.lasso;\n\n  // x-axis\n  let cx = 0;\n  let cy = 0;\n  let ans = 0;\n\n  // draw the x-axis of plot\n  svg.append(\"g\")\n  .attr(\"class\", \"x axis\")\n  .attr(\"transform\", \"translate(0,\" + _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"height\"] + \")\")\n  .call(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"xAxis\"])\n  .append(\"text\")\n  .attr(\"class\", \"label\")\n  .attr(\"x\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"width\"])\n  .attr(\"y\", -6)\n  .style(\"text-anchor\", \"end\")\n  .text(\"\");\n\n  // draw the y-axis of plot\n  svg.append(\"g\")\n  .attr(\"class\", \"y axis\")\n  .call(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"yAxis\"])\n  .append(\"text\")\n  .attr(\"class\", \"label\")\n  .attr(\"transform\", \"rotate(-90)\")\n  .attr(\"y\", 6)\n  .attr(\"dy\", \".71em\")\n  .style(\"text-anchor\", \"end\")\n  .text(\"\");\n\n  // to identify the condition of transparent column values\n  if (transparent_column !== \"Select\" && val_transp !== \"\" && val_opacityNoMatch !== \"\") {\n    transparent_column = transparent_column.toString();\n    val_transp = val_transp.toString(); // ?? no to lower case here?\n  } else {\n    val_transp = val_transp.toString();\n  }\n\n  // searching according to the substring given and searching column\n\n  var searchFunc1 = function(d) {\n    if (typeof d == 'undefined' ) {\n      return 1;\n    }\n    // noMatch true if not found\n    var noMatch;\n    if (document.getElementById('cbox5').checked) {\n      noMatch = d != val_search;\n    } else {\n      noMatch = d.toLowerCase().indexOf(val_search.toLowerCase()) < 0\n      || val_search.length === 0;\n    }\n    return noMatch ? 1 : 2;\n  };\n\n  var searched_data = [], searched_data_indices = [], d_temp;\n  /* temp3 holds the value of every point for the search column */\n  for (var i=0;i<temp3.length;i++) {\n    // 0 if found val in this point, 1 if not found\n    if ( searchFunc1(temp3[i])-1 ) {\n      d_temp = {};\n      // enter all data into dictionary\n      for(var j=1;j<categories.length;j++) {\n        d_temp[categories[j]] = dict1[categories[j]][i];\n      }\n      // only add to searched_data if not already in\n      if(Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"searchDic\"])(searched_data, d_temp) === true) {\n        searched_data.push(d_temp);\n        searched_data_indices.push(i);\n      }\n    }\n  }\n  // create the table\n  if ( val_search != \"\" && searched_data.length > 0) {\n    var peopleTable1 = Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"tabulate\"])(searched_data, columns);\n    if (_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get('semantic_model') === \"true\") {\n      console.log(\"Predicting words...\");\n      Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"classify\"])(searched_data_indices, vectorspace_2darray, weights_2darray, biases_1darray, vocab_1darray);\n      Object(_modules_table_creator_js__WEBPACK_IMPORTED_MODULE_0__[\"benchmark\"])(searched_data_indices, bow_2darray, vocab_1darray);\n    }\n  };\n\n  // determines the rotation of symbols that can be done\n  \n\n  /*** BEGIN drawing dots ***/\n\n  // shaping of symbols according to the shaping column\n  if (shaping_column !== \"Select\" ) {\n    // color_column = shaping_column;\n    var points = svg.selectAll(\".dot\")\n    .data(data)\n    .enter();\n\n    points.append(\"path\")\n    .filter(function(d){ return (Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"dotSearchFilter\"])(d, category_search, val_search) == 1); })\n    .attr(\"class\", \"point\")\n    .style(\"stroke\", \"#000\")\n    .style(\"stroke-width\", 1)\n    // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))\n    .attr(\"d\", d3.svg.symbol().type(function(d) {return _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"symbols\"][symbol[d[shaping_column]]%6];}).size(function(d) {return Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"dotSearchFilter\"])(d, category_search, val_search)-1 ? 180:30;}))\n    .attr(\"transform\", function(d) { return \"translate(\" + Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"xMap\"])(d) + \",\" + Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"yMap\"])(d) + \") rotate(\" + _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"sizes\"][parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + \")\"; })\n    .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})\n    .style(\"opacity\",function(d) { return Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"transpar\"])(d, val_transp, transparent_column, val_opacityMatch, val_opacityNoMatch);})\n\n    .on(\"mouseover\", function(d) {\n      _modules_tooltips_js__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].transition()\n      .duration(200)\n      .style(\"opacity\", 1);\n      _modules_tooltips_js__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].html(\n        Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"printArray\"])(category_search_data, d))\n      .style(\"left\", 60 + \"px\")\n      .style(\"top\", 30 + \"px\");\n    })\n    .on(\"mouseout\", function(d) {\n      d3.select(this).attr(\"r\", function(d){ return Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"dotSearchFilter\"])(d, category_search, val_search)-1 ? 7:3 ; })\n      .style(\"fill\", function(d) { return color(cValue(d));});\n      _modules_tooltips_js__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].transition()\n      .duration(500)\n      .style(\"opacity\", 0);\n    })\n    .on(\"click\", function(d) {\n      svg.append(\"text\")\n      .text(d[feature_column])\n      .attr(\"x\", (d3.event.pageX-50))\n      .attr(\"y\", (d3.event.pageY-35));\n    });\n\n    points.append(\"path\")\n    .filter(function(d){ return (Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"dotSearchFilter\"])(d, category_search, val_search) == 2); })\n    .attr(\"class\", \"point\")\n    .style(\"stroke\", \"yellow\")\n    .style(\"stroke-width\", 2)\n    // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))\n    .attr(\"d\", d3.svg.symbol().type(function(d) {return _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"symbols\"][symbol[d[shaping_column]]%6];}).size(function(d) {return Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"dotSearchFilter\"])(d, category_search, val_search)-1 ? 180:30;}))\n    .attr(\"transform\", function(d) { return \"translate(\" + Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"xMap\"])(d) + \",\" + Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"yMap\"])(d) + \") rotate(\" + _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"sizes\"][parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + \")\"; })\n    .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(cValue(d));})\n    .style(\"opacity\",function(d) { return Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"transpar\"])(d, val_transp, transparent_column, val_opacityMatch, val_opacityNoMatch);})\n\n    .on(\"mouseover\", function(d) {\n      _modules_tooltips_js__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].transition()\n      .duration(200)\n      .style(\"opacity\", 1);\n      _modules_tooltips_js__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].html(\n        Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"printArray\"])(category_search_data, d))\n      .style(\"left\", 60 + \"px\")\n      .style(\"top\", 30 + \"px\");\n    })\n    .on(\"mouseout\", function(d) {\n      d3.select(this).attr(\"r\", function(d){ return Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"dotSearchFilter\"])(d, category_search, val_search)-1 ? 7:3 ; })\n      .style(\"fill\", function(d) { return color(cValue(d));});\n      _modules_tooltips_js__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].transition()\n      .duration(500)\n      .style(\"opacity\", 0);\n    })\n    .on(\"click\", function(d) {\n      svg.append(\"text\")\n      .text(d[feature_column])\n      .attr(\"x\", (d3.event.pageX-50))\n      .attr(\"y\", (d3.event.pageY-35));\n    });\n  } else {\n    let dotsArtist = new _modules_dots_artist_js__WEBPACK_IMPORTED_MODULE_4__[\"DotsArtist\"](\n      svg,\n      data,\n      category_search,\n      category_search_data,\n      val_search,\n      color,\n      cValue2,\n      cValue,\n      val_transp,\n      transparent_column,\n      val_opacityMatch,\n      val_opacityNoMatch\n    )\n    dotsArtist.drawUnmatchedDots();\n    dotsArtist.drawMatchedDots();\n\n    // the event to call on click event\n    svg.on(\"click\",function() {\n      // svg.select(\"#myText\").remove();\n\n      _modules_tooltips_js__WEBPACK_IMPORTED_MODULE_1__[\"tooltip1\"].style(\"opacity\", 0);\n      var coordinates1 = d3.mouse(this);\n      coordinatesx.unshift(coordinates1[0]);\n      coordinatesy.unshift(coordinates1[1]);\n      console.log(coordinatesx, coordinatesy);\n    })\n\n    /* can move up into the if/else, but more clear to separate functionality */\n    if (shaping_column !== \"Select\" ) {\n      lasso.items(d3.selectAll(\".dot\"));\n    } else {\n      lasso.items(d3.selectAll(\".dot\"));\n    }\n\n    var len = color.domain().length;\n    // if spectrum\n    if (numerics[color_column] && document.getElementById('cbox1').checked) {\n\n      if (document.getElementById('cbox2').checked) {\n        m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n        m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n      } else {\n        m1 = (d3.min(data.map(function(d) {return parseFloat(d[color_column])})));\n        m2 = (d3.max(data.map(function(d) {return parseFloat(d[color_column])})));\n      }\n      console.log(m1, m2);\n      m1 = Math.max(Number.MIN_VALUE, m1);\n      console.log(m1, m2);\n\n      var legend = svg.selectAll(\".legend\")\n      .data(color.domain())\n      .enter().append(\"g\")\n      .attr(\"class\", \"legend\");\n\n      var gradient = legend.append('defs')\n      .append('linearGradient')\n      .attr('id', 'gradient')\n      .attr('x1', '0%') // bottom\n      .attr('y1', '100%')\n      .attr('x2', '0%') // to top\n      .attr('y2', '0%')\n      .attr('spreadMethod', 'pad');\n\n      var pct = Object(_modules_utilities_js__WEBPACK_IMPORTED_MODULE_2__[\"linSpace\"])(0, 100, _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"scale\"].length).map(function(d) {\n        return Math.round(d) + '%';\n      });\n\n      var colourPct = d3.zip(pct, _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"scale\"]);\n      colourPct.forEach(function(d) {\n        gradient.append('stop')\n        .attr('offset', d[0])\n        .attr('stop-color', d[1])\n        .attr('stop-opacity', 1);\n      });\n\n      legend.append('rect')\n      .attr('x1', 0)\n      .attr('y1', 0)\n      .attr('width', 18)\n      .attr('height', 150)\n      .attr(\"transform\", \"translate(\" + 582 + \", 0)\")\n      .style('fill', 'url(#gradient)');\n\n      var legendScale = d3.scale.linear()\n      .domain([m1, m2])\n      .range([150, 0]);\n\n      var legendAxis = d3.svg.axis()\n      .scale(legendScale)\n      .orient(\"right\")\n      // .tickValues([m1, m2])\n      .ticks(10);\n\n      legend.append(\"g\")\n      .attr(\"class\", \"legend axis\")\n      .attr(\"transform\", \"translate(\" + 600 + \", 0)\")\n      .call(legendAxis);\n    } else { // no spectrum\n      console.log(Object);\n      var keys = Object.keys(symbol);\n      let leng = keys.length;\n      if (leng<20 && shaping_column != \"Select\") {\n        // draw legend\n        // ?? Not sure why, but this legend appears not to show\n        var legend = svg.selectAll(\".legend\")\n        .data(keys)\n        .enter().append(\"g\");\n        // .attr(\"class\", \"legend\");\n        // .attr(\"transform\", function(d, i) { return \"translate(30,\" + i * 20 + \")\"; });\n        console.log(keys);\n        console.log(shaping_column);\n        console.log(symbol);\n        console.log(_modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"symbols\"]);\n        // draw legend colored rectangles\n        legend.append(\"path\")\n            // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}).size(function(d) {return sizes[parseInt(symbol[d]/6)%3];}))\n            .attr(\"d\", d3.svg.symbol().type(function(d) {return _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"symbols\"][symbol[d]%6];}))\n            .attr(\"x\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"width\"] + 0)\n            .attr(\"width\", 18)\n            .attr(\"height\", 18)\n            // .attr(\"transform\", function(d, i) { return \"translate(\" + 20 + \",\" + i*20 + \")\"; });\n            .attr(\"transform\", function(d, i) { return \"translate(\" + 20 + \",\" + i*20 + \") rotate(\" + _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"sizes\"][parseInt(symbol[d]%6)][parseInt(symbol[d]/6)%4] + \")\"; });\n        // draw legend text\n        legend.append(\"text\")\n            // .attr(\"x\", 100 + 0)\n            // .attr(\"y\", 4)\n            .attr(\"dy\", \".35em\")\n            .style(\"text-anchor\", \"begin\")\n            .text(function(d) { return d;})\n            .attr(\"transform\", function(d, i) { return \"translate(30,\" + i * 20 + \")\"; });\n      }\n\n      if(len <= 30 && color_column != \"Select\") {\n\n        // draw legend\n        var legend = svg.selectAll(\".legend\")\n        .data(color.domain())\n        .enter().append(\"g\")\n        .attr(\"class\", \"legend\")\n        .attr(\"transform\", function(d, i) { return \"translate(0,\" + i * 20 + \")\"; });\n\n        // draw legend colored rectangles\n        legend.append(\"rect\")\n        .attr(\"x\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"width\"] + 6)\n        .attr(\"width\", 18)\n        .attr(\"height\", 18)\n        .style(\"fill\", color);\n\n        // draw legend text\n        legend.append(\"text\")\n        .attr(\"x\", _modules_constants_js__WEBPACK_IMPORTED_MODULE_3__[\"width\"] + 0)\n        .attr(\"y\", 9)\n        .attr(\"dy\", \".35em\")\n        .style(\"text-anchor\", \"end\")\n        .text(function(d) { return d;});\n      }\n    };\n  };\n  }); // end load data\n} // end highlighting//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYWluLmpzPzU2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gSW1wb3J0c1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vLyBUT0RPOiBDdXJyZW50bHksIHdlJ3JlIGltcG9ydGluZyBldmVyeXRoaW5nIGludG8gZ2xvYmFsIHNjb3BlLiBZVUNLLlxuLy8gQnV0IGFzIHdlIGRpc2VudGFuZ2xlIHNjb3BlIHZpb2xhdGlvbnMgYW5kIGZpZ3VyZSBvdXQgYmV0dGVyIHdheXMgb2YgaW5jb3Jwb3JhdGluZ1xuLy8gZGVwZW5kZW5jeSBpbmplY3Rpb24sIHdlIGNhbiBzdGFydCB0byBpbXBsZW1lbnQgc3Ryb25nZXIgZW5jYXBzdWxhdGlvbiBhbmQgbWVzc2FnZSBwYXNzaW5nXG5cbmltcG9ydCB7IGNsYXNzaWZ5LCBiZW5jaG1hcmssIHRhYnVsYXRlIH0gZnJvbSAnLi9tb2R1bGVzL3RhYmxlX2NyZWF0b3IuanMnO1xuaW1wb3J0IHsgdG9vbHRpcCwgdG9vbHRpcDEgfSBmcm9tICcuL21vZHVsZXMvdG9vbHRpcHMuanMnO1xuaW1wb3J0IHtcbiAgZ2V0UGFyYW1ldGVyQnlOYW1lLFxuICBsaW5TcGFjZSxcbiAgcHJpbnRBcnJheSxcbiAgcXVlcnlQYXJhbXMsXG4gIHNlYXJjaERpYyxcbiAgZG90U2VhcmNoRmlsdGVyLFxuICB0cmFuc3BhcixcbiAgeEF4aXMsXG4gIHhNYXAsXG4gIHhTY2FsZSxcbiAgeFZhbHVlLFxuICB5QXhpcyxcbiAgeU1hcCxcbiAgeVNjYWxlLFxuICB5VmFsdWVcbn0gZnJvbSAnLi9tb2R1bGVzL3V0aWxpdGllcy5qcyc7XG5pbXBvcnQge1xuICBkM19jYXRlZ29yeTIwX3NodWZmbGVkLFxuICBoZWlnaHQsXG4gIG1hcmdpbixcbiAgc2NhbGUsXG4gIHNjYWxlX2QsXG4gIHNpemVzLFxuICBzeW1ib2xzLFxuICB3aWR0aFxufSBmcm9tICcuL21vZHVsZXMvY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IERvdHNBcnRpc3QgfSBmcm9tICcuL21vZHVsZXMvZG90c19hcnRpc3QuanMnO1xuaW1wb3J0IHsgU3ZnSW5pdGlhbGl6ZXIgfSBmcm9tICcuL21vZHVsZXMvc3ZnX2luaXRpYWxpemVyLmpzJztcbmltcG9ydCB7IERyb3Bkb3duQnVpbGRlciB9IGZyb20gJy4vbW9kdWxlcy9kcm9wZG93bl9idWlsZGVyLmpzJztcbmltcG9ydCB7IFVSTFNlYXJjaFBhcmFtc1BvbHlmaWxsIH0gZnJvbSAnLi92ZW5kb3JzL3VybF9zZWFyY2hfcGFyYW1zX3BvbHlmaWxsLmpzJztcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gQmVnaW4gU2NyaXB0XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbmV4cG9ydCBjb25zdCBkYXRhc2V0ID0gcXVlcnlQYXJhbXMuZ2V0KFwiZGF0YXNldFwiKSB8fCBcImpvaW5lZF9kYXRhLmNzdlwiO1xuXG5cbnZhciB3ZWlnaHRzXzJkYXJyYXkgPSBbXSwgYmlhc2VzXzFkYXJyYXkgPSBbXSwgdm9jYWJfMWRhcnJheSA9IFtdLCB2ZWN0b3JzcGFjZV8yZGFycmF5ID0gW10sIGJvd18yZGFycmF5ID0gW107XG4vLyBTZW1hbnRpYyBtb2RlbCBvcHRpb24gc2V0IHVwXG5pZiAocXVlcnlQYXJhbXMuZ2V0KFwic2VtYW50aWNfbW9kZWxcIikgPT09IFwidHJ1ZVwiKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBzZW1hbnRpYyBtb2RlbC5cXG5HZXR0aW5nIG1hdHJpY2VzLi4uJyk7XG4gIHZhciB3ZWlnaHRzZmlsZSA9IGRhdGFzZXQuc3BsaXQoL1xcLnRbYS16XXsyfSQvKVswXSsnX3dlaWdodHMudHh0JztcbiAgdmFyIGJpYXNlc2ZpbGUgPSBkYXRhc2V0LnNwbGl0KC9cXC50W2Etel17Mn0kLylbMF0rJ19iaWFzZXMudHh0JztcbiAgdmFyIHZvY2FiZmlsZSA9IGRhdGFzZXQuc3BsaXQoL1xcLnRbYS16XXsyfSQvKVswXSsnX3ZvY2FiLnR4dCc7XG4gIHZhciB2ZWN0b3JmaWxlID0gJ1ZTLScgKyBkYXRhc2V0LnNwbGl0KFwiX3NlbWFudGljXCIpWzBdKycudHh0JztcbiAgdmFyIGJvd2ZpbGUgPSBkYXRhc2V0LnNwbGl0KC9cXC50W2Etel17Mn0kLylbMF0rJ19ib3cudHh0JztcblxuICBjb25zb2xlLmxvZyhcIlJlYWRpbmcgXCIgKyBib3dmaWxlKTtcbiAgZDMudHN2KGJvd2ZpbGUsIGZ1bmN0aW9uKHRleHQpe1xuICAgIGJvd18yZGFycmF5ID0gdGV4dC5tYXAoIE9iamVjdC52YWx1ZXMgKTtcbiAgICBib3dfMmRhcnJheSA9IGJvd18yZGFycmF5Lm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5Lm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZWxlbSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnNvbGUubG9nKFwiUmVhZGluZyBcIiArIHZlY3RvcmZpbGUpO1xuICBkMy50c3YodmVjdG9yZmlsZSwgZnVuY3Rpb24odGV4dCl7XG4gICAgdmVjdG9yc3BhY2VfMmRhcnJheSA9IHRleHQubWFwKCBPYmplY3QudmFsdWVzICk7XG4gICAgdmVjdG9yc3BhY2VfMmRhcnJheSA9IHZlY3RvcnNwYWNlXzJkYXJyYXkubWFwKGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgLy8gdXNlcm5hbWUgY29sdW1uIGVuZHMgdXAgbGFzdCBpbiB0aGUgZGljdGlvbmFyeSwgZHVlIHRvIGFscGhhbnVtZXJpYyBzb3J0XG4gICAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKDAsLTEpLm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGVsZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gIH0pO1xuICBjb25zb2xlLmxvZyhcIlJlYWRpbmcgXCIgKyB3ZWlnaHRzZmlsZSk7XG4gIGQzLnRzdih3ZWlnaHRzZmlsZSwgZnVuY3Rpb24odGV4dCl7XG4gICAgd2VpZ2h0c18yZGFycmF5ID0gdGV4dC5tYXAoIE9iamVjdC52YWx1ZXMgKTtcbiAgICB3ZWlnaHRzXzJkYXJyYXkgPSB3ZWlnaHRzXzJkYXJyYXkubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICByZXR1cm4gZW50cnkubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZWxlbSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnNvbGUubG9nKFwiUmVhZGluZyBcIiArIGJpYXNlc2ZpbGUpO1xuICBkMy50c3YoYmlhc2VzZmlsZSwgZnVuY3Rpb24odGV4dCl7XG4gICAgYmlhc2VzXzFkYXJyYXkgPSB0ZXh0Lm1hcCggT2JqZWN0LnZhbHVlcyApO1xuICAgIGJpYXNlc18xZGFycmF5ID0gT2JqZWN0LnZhbHVlcyhiaWFzZXNfMWRhcnJheS5tYXAoTnVtYmVyKSk7XG4gIH0pO1xuICBjb25zb2xlLmxvZyhcIlJlYWRpbmcgXCIgKyB2b2NhYmZpbGUpO1xuICBkMy50c3Yodm9jYWJmaWxlLCBmdW5jdGlvbih0ZXh0KXtcbiAgICB2b2NhYl8xZGFycmF5ID0gdGV4dC5tYXAoIE9iamVjdC52YWx1ZXMgKTtcbiAgICB2b2NhYl8xZGFycmF5ID0gT2JqZWN0LnZhbHVlcyh2b2NhYl8xZGFycmF5Lm1hcChTdHJpbmcpKTtcbiAgfSk7XG59XG5cbi8vIGNhdGVnb3JpZXMgc3RvcmVzIHRoZSBuYW1lIG9mIGFsbCB0aGUgY29sdW1uc1xudmFyIGNhdGVnb3JpZXMgPSBbXTtcbmxldCBkZWZhdWx0VmFsdWUgPSAnU2VsZWN0JztcbmNhdGVnb3JpZXMucHVzaChkZWZhdWx0VmFsdWUpO1xuLy8gTm90IHN1cmUgdGhpcyBpcyByZWFsbHkgd2hhdCB3ZSB3YW50IC0tIGlmIHlvdSBlbnRlciB0aGUgd3JvbmcgcGFyYW1ldGVyIHZhbHVlLFxuLy8gaXQgbWF5IG1ha2UgdGhpbmdzIHNjcmV3eS4uLndlIGNhbiBwcm9iYWJseSBtYWtlIGl0IGEgYml0IG1vcmUgZmF1bHQgdG9sZXJhbnRcbmlmIChxdWVyeVBhcmFtcy5nZXQoXCJjb2xvclwiKSkgY2F0ZWdvcmllcy5wdXNoKHF1ZXJ5UGFyYW1zLmdldChcImNvbG9yXCIpKTtcblxuLy8gY2F0ZWdvcnlfc2VhcmNoIHN0b3JlcyB0aGUgbmFtZSBvZiBjb2x1bW4gYWNjb3JkaW5nIHRvIHdoaWNoIHNlYXJjaGluZyBpcyB0byBiZSBkb25lXG52YXIgY2F0ZWdvcnlfc2VhcmNoX2RhdGEgPSBbXTtcblxuLy8gY2hlY2sgd2hldGhlciB0aGUgc2VhcmNoaW5nIGNvbHVtbiBpcyBwcm92aWRlZCBpbiB0aGUgdXJsIG9yIG5vdFxubGV0IGNhdGVnb3J5X3NlYXJjaCA9IHF1ZXJ5UGFyYW1zLmdldChcInNlYXJjaFwiKTtcbmlmIChjYXRlZ29yeV9zZWFyY2gpIGNhdGVnb3J5X3NlYXJjaF9kYXRhLnB1c2goY2F0ZWdvcnlfc2VhcmNoKTtcblxuLy8gc2V0dXAgZmlsbCBjb2xvclxuLy8gY29sb3JfY29sdW1uIHN0b3JlcyB0aGUgbmFtZSBvZiBjb2x1bW4gYWNjb3JkaW5nIHRvIHdoaWNoIGNvbG9yaW5nIGlzIHRvIGJlIGRvbmVcbi8vIGNoZWNrIHdoZXRoZXIgdGhlIGNvbG9yaW5nIGNvbHVtbiBpcyBwcm92aWRlZCBpbiB0aGUgdXJsIG9yIG5vdFxubGV0IGNvbG9yX2NvbHVtbiA9IHF1ZXJ5UGFyYW1zLmdldChcImNvbG9yXCIpIHx8IFwiU2VsZWN0XCI7XG5cbi8vIGNhdGVnb3JpZXNfY29weV9jb2xvciBpcyBqdXN0IHRoZSBjb3B5IG9mIGNhdGVnb3JpZXNcbnZhciBjYXRlZ29yaWVzX2NvcHlfY29sb3IgPSBbXTtcbmNhdGVnb3JpZXNfY29weV9jb2xvci5wdXNoKGNvbG9yX2NvbHVtbik7XG5cbnZhciBjb2x1bW5zID0gW107XG4vLyBjb2x1bW4gZm9yIHRoZSB0cmFuc3BhcmVudCB2YWx1ZVxudmFyIHRyYW5zcGFyZW50X2NvbHVtbiA9IFwiU2VsZWN0XCIsIGZlYXR1cmVfY29sdW1uID0gXCJcIiwgc2hhcGluZ19jb2x1bW4gPSBcIlNlbGVjdFwiO1xuXG5mdW5jdGlvbiBleHRyYWN0Q2F0ZWdvcnlMYWJlbHNGcm9tRGF0YShkYXRhKSB7XG4gIGNvbnNvbGUubG9nKCdMb2FkaW5nIG1haW4gZGF0YScpXG4gIGZ1bmN0aW9uIGV4dHJhY3RDYXRlZ29yeUhlYWRlcnMoZGF0YSkge1xuICAgIGxldCBjYXRlZ29yeUhlYWRlcnNGcm9tRmlyc3RSb3dPZkRhdGEgPSBbXTtcbiAgICBjYXRlZ29yeUhlYWRlcnNGcm9tRmlyc3RSb3dPZkRhdGEgPSBPYmplY3Qua2V5cyhkYXRhWzBdKTtcbiAgICAvLyByZW1vdmUgeCBhbmQgeVxuICAgIGNhdGVnb3J5SGVhZGVyc0Zyb21GaXJzdFJvd09mRGF0YS5zcGxpY2UoXG4gICAgICBjYXRlZ29yeUhlYWRlcnNGcm9tRmlyc3RSb3dPZkRhdGEuaW5kZXhPZigneCcpLCAxXG4gICAgKTtcbiAgICBjYXRlZ29yeUhlYWRlcnNGcm9tRmlyc3RSb3dPZkRhdGEuc3BsaWNlKFxuICAgICAgY2F0ZWdvcnlIZWFkZXJzRnJvbUZpcnN0Um93T2ZEYXRhLmluZGV4T2YoJ3knKSwgMVxuICAgICk7XG4gICAgcmV0dXJuIGNhdGVnb3J5SGVhZGVyc0Zyb21GaXJzdFJvd09mRGF0YTtcbiAgfVxuICBsZXQgY2F0ZWdvcnlIZWFkZXJzID0gZXh0cmFjdENhdGVnb3J5SGVhZGVycyhkYXRhKTtcblxuICBmb3IodmFyIGk9MDtpPGNhdGVnb3J5SGVhZGVycy5sZW5ndGg7aSsrKSB7XG4gICAgaWYgKGNhdGVnb3J5SGVhZGVyc1tpXSAhPSBjYXRlZ29yeV9zZWFyY2gpIHtcbiAgICAgIGNhdGVnb3J5X3NlYXJjaF9kYXRhLnB1c2goY2F0ZWdvcnlIZWFkZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICBmb3IodmFyIGk9MDtpPGNhdGVnb3J5SGVhZGVycy5sZW5ndGg7aSsrKSB7XG4gICAgLy8gY29sb3JfY29sdW1uIGFscmVhZHkgcHVzaGVkXG4gICAgaWYgKGNhdGVnb3J5SGVhZGVyc1tpXSAhPSBjb2xvcl9jb2x1bW4pIHtcbiAgICAgIGNhdGVnb3JpZXMucHVzaChjYXRlZ29yeUhlYWRlcnNbaV0pO1xuICAgICAgY2F0ZWdvcmllc19jb3B5X2NvbG9yLnB1c2goY2F0ZWdvcnlIZWFkZXJzW2ldKTtcbiAgICB9XG4gICAgY29sdW1ucy5wdXNoKGNhdGVnb3J5SGVhZGVyc1tpXSk7XG4gIH1cbiAgbGV0IGRyb3Bkb3duQnVpbGRlciA9IG5ldyBEcm9wZG93bkJ1aWxkZXIoKTtcbiAgZHJvcGRvd25CdWlsZGVyLmJ1aWxkKGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBjYXRlZ29yaWVzX2NvcHlfY29sb3IsIGNhdGVnb3JpZXMpO1xuICBkcm9wZG93bkJ1aWxkZXIuc2V0RHJvcGRvd25FdmVudEhhbmRsZXJzKFxuICAgICAgICAgICAgICAgICAgIHBsb3R0aW5nLFxuICAgICAgICAgICAgICAgICAgIHBsb3R0aW5nMixcbiAgICAgICAgICAgICAgICAgICBwbG90dGluZzMsXG4gICAgICAgICAgICAgICAgICAgcGxvdHRpbmc0LFxuICAgICAgICAgICAgICAgICAgIHBsb3R0aW5nNVxuICAgICAgICAgICAgICAgICApO1xuXG4gIGNhdGVnb3J5X3NlYXJjaCA9IGNhdGVnb3J5X3NlYXJjaF9kYXRhWzBdO1xuICBzaGFwaW5nX2NvbHVtbiA9IGNhdGVnb3JpZXNbMF07XG4gIGZlYXR1cmVfY29sdW1uID0gY2F0ZWdvcnlfc2VhcmNoX2RhdGFbMF07XG4gIHRyYW5zcGFyZW50X2NvbHVtbiA9IGNhdGVnb3J5X3NlYXJjaF9kYXRhWzBdO1xufTtcblxuLy8gZ2V0dGluZyBoZWFkZXIgZnJvbSBjc3YgZmlsZSB0byBtYWtlIGRyb3dkb3duIG1lbnVzXG4vLyBOT1RFOiB0c3YoKSBpcyBhbiBhc3luYyBmdW5jdGlvblxuZDMudHN2KGRhdGFzZXQsIGV4dHJhY3RDYXRlZ29yeUxhYmVsc0Zyb21EYXRhKTtcblxubGV0IGNyZWF0ZUNvbG9yVmFsdWUgPSAodGFyZ2V0Q29sdW1uKSA9PiB7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBkYXRhW3RhcmdldENvbHVtbl07XG4gIH07XG59O1xuLy8gbmVlZCB0byByZW5hbWUgdGhpcyBmdW5jdGlvbiB0byBiZSBtb3JlIGRlc2NyaXB0aXZlXG5sZXQgY3JlYXRlQ29sb3JWYWx1ZTIgPSAodGFyZ2V0Q29sdW1uKSA9PiB7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBNYXRoLmxvZyhwYXJzZUZsb2F0KGRhdGFbdGFyZ2V0Q29sdW1uXSkpO1xuICB9O1xufTtcbmxldCBjb2xvciA9IGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwX3NodWZmbGVkKTtcbmxldCBjb2xvclZhbHVlRnVuY3Rpb24gPSBjcmVhdGVDb2xvclZhbHVlKGNvbG9yX2NvbHVtbik7XG5sZXQgY29sb3JWYWx1ZUZ1bmN0aW9uMiA9IGNyZWF0ZUNvbG9yVmFsdWUyKGNvbG9yX2NvbHVtbik7XG4vLyBJbml0aWFsIHBsb3QgZHJhdyBoYXBwZW5zIGhlcmU6XG5oaWdobGlnaHRpbmcoY29sb3JWYWx1ZUZ1bmN0aW9uLCBjb2xvclZhbHVlRnVuY3Rpb24yLCBxdWVyeVBhcmFtcy5nZXQoXCJxXCIpIHx8IFwiXCIsIFwiXCIsIFwiXCIpXG5cbi8vIHRoZSBmdW5jdGlvbnMgdG8gY2FsbCB3aGVuIHRoZSB2YWx1ZSBvZiBkcm9wZG93biBtZW51IGlzIGNoYW5nZXNcbi8vIENsaWNrIG9uIGZlYXR1cmVcbmZ1bmN0aW9uIHBsb3R0aW5nNCgpe1xuICBmZWF0dXJlX2NvbHVtbiA9IGQzLmV2ZW50LnRhcmdldC52YWx1ZTtcbn1cbi8vIFRyYW5zcGFyZW50XG5mdW5jdGlvbiBwbG90dGluZzMoKXtcbiAgdHJhbnNwYXJlbnRfY29sdW1uID0gZDMuZXZlbnQudGFyZ2V0LnZhbHVlO1xufVxuLy8gU2VhcmNoaW5nXG5mdW5jdGlvbiBwbG90dGluZzIoKXtcbiAgY2F0ZWdvcnlfc2VhcmNoID0gZDMuZXZlbnQudGFyZ2V0LnZhbHVlO1xufVxuXG4vLyBmdW5jdGlvbiB0byBjYWxsIGZvciBjaGFuZ2UgZXZlbnRcbi8vIENvbG9yaW5nXG5mdW5jdGlvbiBwbG90dGluZygpe1xuICBjb2xvcl9jb2x1bW4gPSBkMy5ldmVudC50YXJnZXQudmFsdWU7XG4gIGNvbG9yVmFsdWVGdW5jdGlvbiA9IGNyZWF0ZUNvbG9yVmFsdWUoY29sb3JfY29sdW1uKTtcbiAgY29sb3JWYWx1ZUZ1bmN0aW9uMiA9IGNyZWF0ZUNvbG9yVmFsdWUyKGNvbG9yX2NvbHVtbik7XG4gIGxldCB2YWxfc2VhcmNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hUZXh0XCIpLnZhbHVlO1xuICBsZXQgdmFsX3RyYW5zcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhbnNwVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF9vcGFjaXR5TWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlNYXRjaFwiKS52YWx1ZTtcbiAgbGV0IHZhbF9vcGFjaXR5Tm9NYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU5vTWF0Y2hcIikudmFsdWU7XG4gIGhpZ2hsaWdodGluZyhjb2xvclZhbHVlRnVuY3Rpb24sIGNvbG9yVmFsdWVGdW5jdGlvbjIsIHZhbF9zZWFyY2gsIHZhbF90cmFuc3AsIHZhbF9vcGFjaXR5TWF0Y2gsIHZhbF9vcGFjaXR5Tm9NYXRjaCk7XG59XG5cbi8vIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGNoYW5nZSBldmVudFxuLy8gU2hhcGluZ1xuZnVuY3Rpb24gcGxvdHRpbmc1KCl7XG4gIHNoYXBpbmdfY29sdW1uID0gZDMuZXZlbnQudGFyZ2V0LnZhbHVlO1xuICBjb2xvclZhbHVlRnVuY3Rpb24gPSBjcmVhdGVDb2xvclZhbHVlKGNvbG9yX2NvbHVtbik7XG4gIGNvbG9yVmFsdWVGdW5jdGlvbjIgPSBjcmVhdGVDb2xvclZhbHVlMihjb2xvcl9jb2x1bW4pO1xuICBsZXQgdmFsX3NlYXJjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF90cmFuc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zcFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU1hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5TWF0Y2hcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICBoaWdobGlnaHRpbmcoY29sb3JWYWx1ZUZ1bmN0aW9uLCBjb2xvclZhbHVlRnVuY3Rpb24yLCB2YWxfc2VhcmNoLCB2YWxfdHJhbnNwLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpO1xufVxuXG52YXIgem9vbWVkID0gMDtcbnZhciBuZWVkWm9vbSA9IGZhbHNlO1xudmFyIG5lZWREcmF3Q2lyY2xlID0gZmFsc2U7XG5cbi8vIHNlYXJjaCBldmVudFxuLy8gaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHNlYXJjaCBidXR0b24gaXMgcHJlc3NlZCBhbmQgcG9pbnRzIHRoYXQgbWF0Y2hlcyB0aGUgc2VhcmNoZWQgc3RyaW5nIHdpbGwgYmUgaGlnaGxpZ2h0ZWRcbmZ1bmN0aW9uIHNlYXJjaEV2ZW50SGFuZGxlcihldmVudCkge1xuICBjb25zb2xlLmxvZyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlYXJjaFRleHRcIikudmFsdWUpO1xuICBsZXQgdmFsX3NlYXJjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF90cmFuc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zcFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU1hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5TWF0Y2hcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICBoaWdobGlnaHRpbmcoY29sb3JWYWx1ZUZ1bmN0aW9uLCBjb2xvclZhbHVlRnVuY3Rpb24yLCB2YWxfc2VhcmNoLCB2YWxfdHJhbnNwLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWFyY2hFeGFjdE1hdGNoRXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlYXJjaFRleHRcIikudmFsdWUpIHNlYXJjaEV2ZW50SGFuZGxlcigpO1xufVxuXG4vLyB0cmFuc3BhcmVudCBldmVudFxuLy8gaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRyYW5zcGFyZW50IGJ1dHRvbiBpcyBwcmVzc2VkIGFuZCBwb2ludHMgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiB3aWxsIGJlIGhpZ2hsaWdodGVkXG5mdW5jdGlvbiB0cmFuc3BhcmVudFNlYXJjaEV2ZW50SGFuZGxlcihldmVudCkge1xuICBjb25zb2xlLmxvZyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zcFRleHRcIikudmFsdWUpO1xuICBsZXQgdmFsX3NlYXJjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF90cmFuc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zcFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU1hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5TWF0Y2hcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICBoaWdobGlnaHRpbmcoY29sb3JWYWx1ZUZ1bmN0aW9uLCBjb2xvclZhbHVlRnVuY3Rpb24yLCB2YWxfc2VhcmNoLCB2YWxfdHJhbnNwLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYW5kbGVDaGVjazEoZXZlbnQpIHtcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhbnNwVGV4dFwiKS52YWx1ZSkge1xuICAgIHRyYW5zcGFyZW50U2VhcmNoRXZlbnRIYW5kbGVyKCk7XG4gIH1cbn1cblxuLy8gPz8gSSBiZWxpZXZlIHRoaXMgZnVuY3Rpb24gaXMgdW51c2VkLCBhbmQgZHJhdyBhbHNvIG1hcHMgdG8gem9vbUV2ZW50SGFuZGxlclxuLy8gaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIERyYXcgYnV0dG9uIGlzIHByZXNzZWQgYW5kIHRoZSBwbG90IHdpbGwgaGlnaGxpZ2h0IHRob3NlIHBvaW50cyB0aGF0IGNvdmVycyBmaXhlZCBwZXJjZW50YWdlIG9mIHBvaW50IGZyb20gdGhlIHBvaW50IG9idGFpbmVkIGJ5IG1vdXNlIGNsaWNrXG5mdW5jdGlvbiBoYW5kbGVDbGljazIoZXZlbnQpe1xuICBzaGFwaW5nX2NvbHVtbiA9IFwiU2VsZWN0XCI7XG4gIGNvbG9yX2NvbHVtbiA9IFwiU2VsZWN0XCI7XG4gIG15Rm9ybS5zZWFyY2hUZXh0LnZhbHVlID0gMDtcbiAgbXlGb3JtMS50cmFuc3BUZXh0LnZhbHVlID0gMDtcbiAgbXlGb3JtMS5vcGFjaXR5TWF0Y2gudmFsdWUgPSAwO1xuICBteUZvcm0xLm9wYWNpdHlOb01hdGNoLnZhbHVlID0gMDtcbiAgc2hhcGluZ0Ryb3Bkb3duLnByb3BlcnR5KCBcInZhbHVlXCIsIFwiU2VsZWN0XCIgKTtcbiAgZHJvcERvd24ucHJvcGVydHkoIFwidmFsdWVcIiwgXCJTZWxlY3RcIiApO1xuICBoaWdobGlnaHRpbmcoY29sb3JWYWx1ZUZ1bmN0aW9uLCBjb2xvclZhbHVlRnVuY3Rpb24yLCBcIlwiLCBcIlwiLCBcIlwiKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcGVjdHJ1bSAvIGxvZyBldmVudFxuLy8gaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHNwZWN0cnVtL2xvZyBpcyBjaGVja2VkXG4vLyA/PyBDYW4gd2UgY29sbGFwc2UgdHJhbnNwYXJlbnRTZWFyY2hFdmVudEhhbmRsZXIsMyw0P1xuZnVuY3Rpb24gc3BlY3RydW1BbmRMb2dDb2xvcmluZ0V2ZW50SGFuZGxlcihldmVudCkge1xuICBsZXQgdmFsX3NlYXJjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF90cmFuc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zcFRleHRcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU1hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5TWF0Y2hcIikudmFsdWU7XG4gIGxldCB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICBoaWdobGlnaHRpbmcoY29sb3JWYWx1ZUZ1bmN0aW9uLCBjb2xvclZhbHVlRnVuY3Rpb24yLCB2YWxfc2VhcmNoLCB2YWxfdHJhbnNwLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpO1xufVxuXG4vLyBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gKD8/IGRyYXcgYW5kKSB6b29tIGJ1dHRvbiBpcyBwcmVzc2VkIGFuZCB0aGUgcGxvdCB3aWxsIHpvb21lZCBvdXQgYWNjb3JkaW5nIHRvIHRoZSBwb2ludHMgb2J0YWluZWQgYnkgbW91c2UgY2xpY2sgZXZlbnRcbmZ1bmN0aW9uIHpvb21FdmVudEhhbmRsZXIoKXtcbiAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDMnKS5jaGVja2VkKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ6b29teHlcIikudmFsdWUgPSBcIlwiOyAvLyBjbGVhciB0aGUgdGV4dGJveFxuICB9XG4gIGxldCB2YWxfc2VhcmNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hUZXh0XCIpLnZhbHVlO1xuICBsZXQgdmFsX3RyYW5zcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhbnNwVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF9vcGFjaXR5TWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlNYXRjaFwiKS52YWx1ZTtcbiAgbGV0IHZhbF9vcGFjaXR5Tm9NYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU5vTWF0Y2hcIikudmFsdWU7XG4gIG5lZWRab29tID0gdHJ1ZTtcbiAgaGlnaGxpZ2h0aW5nKGNvbG9yVmFsdWVGdW5jdGlvbiwgY29sb3JWYWx1ZUZ1bmN0aW9uMiwgdmFsX3NlYXJjaCwgdmFsX3RyYW5zcCwgdmFsX29wYWNpdHlNYXRjaCwgdmFsX29wYWNpdHlOb01hdGNoKTtcbn1cblxuKGZ1bmN0aW9uIHNldEV2ZW50SGFuZGxlcnMoKSB7XG4gIGxldCB6b29tQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnem9vbS1idXR0b24nKVswXTtcbiAgem9vbUJ1dHRvbi5vbmNsaWNrID0gem9vbUV2ZW50SGFuZGxlcjtcblxuICBsZXQgY29sb3JPcHRpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29sb3Itb3B0aW9uJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgY29sb3JPcHRpb25zW2ldLm9uY2xpY2sgPSBzcGVjdHJ1bUFuZExvZ0NvbG9yaW5nRXZlbnRIYW5kbGVyO1xuICB9O1xuXG4gIGxldCBzZWFyY2hFeGFjdE1hdGNoQ2hlY2tib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzZWFyY2gtZXhhY3QtbWF0Y2gnKVswXTtcbiAgc2VhcmNoRXhhY3RNYXRjaENoZWNrYm94Lm9uY2xpY2sgPSBzZWFyY2hFeGFjdE1hdGNoRXZlbnRIYW5kbGVyO1xuXG4gIGxldCBzZWFyY2hGb3JtQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc2VhcmNoLWJ1dHRvbicpWzBdO1xuICBzZWFyY2hGb3JtQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBzZWFyY2hFdmVudEhhbmRsZXIoKTtcbiAgfSk7XG5cbiAgbGV0IHRyYW5zcGFyZW50U2VhcmNoQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndHJhbnNwYXJlbnQtc2VhcmNoLWJ1dHRvbicpWzBdO1xuICB0cmFuc3BhcmVudFNlYXJjaEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdHJhbnNwYXJlbnRTZWFyY2hFdmVudEhhbmRsZXIoKTtcbiAgfSk7XG5cbiAgLy8gbGV0IHRyYW5zcGFyZW5jeUV4YWN0TWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0cmFuc3BhcmVuY3ktZXhhY3QtbWF0Y2gnKVswXTtcbiAgLy8gdHJhbnNwYXJlbmN5RXhhY3RNYXRjaC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZlbnQpID0+IHtcbiAgLy8gICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAvLyAgIHRyYW5zcGFyZW50U2VhcmNoRXZlbnRIYW5kbGVyKCk7XG4gIC8vIH0pO1xufSkoKVxuXG5sZXQgY29vcmRpbmF0ZXN4ID0gW107XG5sZXQgY29vcmRpbmF0ZXN5ID0gW107XG5cbi8vIGZ1bmN0aW9uIGZvciBwbG90dGluZ1xuZnVuY3Rpb24gaGlnaGxpZ2h0aW5nKGNWYWx1ZSwgY1ZhbHVlMiwgdmFsX3NlYXJjaCwgdmFsX3RyYW5zcCwgdmFsX29wYWNpdHlNYXRjaCwgdmFsX29wYWNpdHlOb01hdGNoKSB7XG5cbiAgbGV0IG0xLCBtMiwgeF9tYXgsIHhfbWluLCB5X21heCwgeV9taW47XG4gIHZhciB0ZW1wMSA9IFtdLCB0ZW1wMiA9IFtdLCB0ZW1wMyA9IFtdO1xuICB2YXIgZGljdDEgPSB7fTtcblxuICAvLyB0byByZW1vdmUgdGhlIGV4aXN0aW5nIHN2ZyBwbG90IGlmIGFueSBhbmQgY2xlYXIgc2lkZSB0YWJsZVxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlbW8zXCIpLmlubmVySFRNTCA9IFwiXCI7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJlZGljdGVkX3dvcmRzXCIpLmlubmVySFRNTCA9IFwiXCI7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJlcXVlbnRfd29yZHNcIikuaW5uZXJIVE1MID0gXCJcIjtcbiAgZDMuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuICBkMy5zZWxlY3QoXCJ0YWJsZVwiKS5yZW1vdmUoKTtcblxuICBkMy50c3YoZGF0YXNldCwgZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICBjb25zb2xlLmxvZygnTG9hZGluZyBtYWluIGRhdGEsIGFnYWluJykgLy8gbG9hZCBkYXRhXG4gICAgLy8gY2hhbmdlIHN0cmluZyAoZnJvbSBDU1YpIGludG8gbnVtYmVyIGZvcm1hdFxuICAgIHZhciBudW1lcmljcyA9IHt9LCBzeW1ib2wgPSB7fTtcbiAgICAvL09taXR0aW5nIFNlbGVjdCAoMClcbiAgICBmb3IodmFyIGk9MTtpPGNhdGVnb3JpZXMubGVuZ3RoO2krKykge1xuICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgdmFsdWUgZm9yIGVhY2ggY2F0ZWdvcnkga2V5IHRvIGVtcHR5IGxpc3RcbiAgICAgIGRpY3QxW2NhdGVnb3JpZXNbaV1dID0gW107XG4gICAgICAvLyBpbml0aWFsaXplIGFsbCBjYXRlZ29yaWVzIGFzIG51bWVyaWNcbiAgICAgIG51bWVyaWNzW2NhdGVnb3JpZXNbaV1dID0gMTtcbiAgICB9XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgLy8gY29lcmNlIHRoZSBkYXRhIHRvIG51bWJlcnNcbiAgICBkLnggPSArZC54O1xuICAgIGRbXCJ5XCJdID0gK2RbXCJ5XCJdO1xuXG4gICAgZm9yKHZhciBpPTE7aTxjYXRlZ29yaWVzLmxlbmd0aDtpKyspe1xuICAgICAgLy8gYWRkIGV2ZXJ5IGF0dHJpYnV0ZSBvZiBwb2ludCB0byB0aGUge2NhdGVnb3J5Olt2YWwxLHZhbDIsLi4uXX1cbiAgICAgIGRpY3QxW2NhdGVnb3JpZXNbaV1dLnB1c2goZFtjYXRlZ29yaWVzW2ldXSk7XG4gICAgICAvLyByZXZva2UgYSBjYXRlZ29yeSdzIG51bWVyaWNzIHN0YXR1cyBpZiBmaW5kIGFuIGVudHJ5IGhhcyBhIG5vbi1JbnQgb3Igbm9uLW51bGwgdmFsdWUgZm9yIHRoYXQgY2F0ZWdvcnlcbiAgICAgIG51bWVyaWNzW2NhdGVnb3JpZXNbaV1dID0gbnVtZXJpY3NbY2F0ZWdvcmllc1tpXV0gJiYgKGRbY2F0ZWdvcmllc1tpXV0gPT0gXCJcIiB8fCBkW2NhdGVnb3JpZXNbaV1dID09IHBhcnNlRmxvYXQoZFtjYXRlZ29yaWVzW2ldXSkpO1xuICAgIH1cbiAgICAvLyBmaWxsIHRoZSBzeW1ib2wgZGljdGlvbmFyeSB3aXRoIGFsbCBwb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIHNoYXBpbmcgY29sdW1uIGFzIGtleXNcbiAgICAvLyB2YWx1ZSBpcyB0aGUgb3JkZXIgb2YgcG9pbnRzXG4gICAgaWYgKCEoZFtzaGFwaW5nX2NvbHVtbl0gaW4gc3ltYm9sKSkge1xuICAgICAgc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSA9IGNvdW50ZXI7XG4gICAgICBjb3VudGVyID0gY291bnRlciArIDE7XG4gICAgfVxuICAgIC8vIHB1c2ggYWxsIHggdmFsdWVzLCB5IHZhbHVlcywgYW5kIGFsbCBjYXRlZ29yeSBzZWFyY2ggdmFsdWVzIGludG8gdGVtcDEvMi8zXG4gICAgdGVtcDEucHVzaChkLngpO1xuICAgIHRlbXAyLnB1c2goZFtcInlcIl0pO1xuICAgIHRlbXAzLnB1c2goZFtjYXRlZ29yeV9zZWFyY2hdKTtcbiAgICAvLyBjb25zb2xlLmxvZyhkW1wielwiXSA9PSBwYXJzZUludChkW1wielwiXSkpO1xuICB9KTtcbiAgY29uc29sZS5sb2coXCJOdW1lcmljczogXCIsIG51bWVyaWNzKTtcbiAgY29uc29sZS5sb2coXCJDb2xvciBDb2x1bW46IFwiLGNvbG9yX2NvbHVtbik7XG4gIC8vIHNldCBjb2xvciBhY2NvcmRpbmcgdG8gc3BlY3RydW1cbiAgaWYgKG51bWVyaWNzW2NvbG9yX2NvbHVtbl0gJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gxJykuY2hlY2tlZCkge1xuICAgIGNvbnNvbGUubG9nKCd1c2luZyBzcGVjdHJ1bScpO1xuICAgIC8vIHRha2UgbG9nIGlmIGxvZyBjaGVja2JveCBjaGVja2VkXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94MicpLmNoZWNrZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd1c2luZyBsb2cnKTtcbiAgICAgIG0xID0gKGQzLm1pbihkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIE1hdGgubG9nKHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKSk7IH0pKSk7XG4gICAgICBtMiA9IChkMy5tYXgoZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBNYXRoLmxvZyhwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSkpOyB9KSkpO1xuICAgIH0gZWxzZXtcbiAgICAgIGNvbnNvbGUubG9nKCdub3QgdXNpbmcgbG9nJyk7XG4gICAgICBtMSA9IChkMy5taW4oZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSl9KSkpO1xuICAgICAgbTIgPSAoZDMubWF4KGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtyZXR1cm4gcGFyc2VGbG9hdChkW2NvbG9yX2NvbHVtbl0pfSkpKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhtMSwgbTIpO1xuICAgIG0xID0gTWF0aC5tYXgoTnVtYmVyLk1JTl9WQUxVRSwgbTEpO1xuICAgIGNvbnNvbGUubG9nKG0xLCBtMik7XG5cbiAgICBjb2xvciA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgLmRvbWFpbihsaW5TcGFjZShtMSwgbTIsc2NhbGUubGVuZ3RoKSlcbiAgICAgIC8vLmRvbWFpbihsaW5TcGFjZShkMy5taW4oZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBwYXJzZUludChkW2NvbG9yX2NvbHVtbl0pfSkpLCBkMy5tYXgoZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBwYXJzZUludChkW2NvbG9yX2NvbHVtbl0pfSkpLHNjYWxlLmxlbmd0aCkpXG4gICAgICAucmFuZ2Uoc2NhbGUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdub3QgdXNpbmcgc3BlY3RydW0nKTtcbiAgICBjb2xvciA9IGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwX3NodWZmbGVkKTtcbiAgfVxuXG4gIC8vIGRvbid0IHdhbnQgZG90cyBvdmVybGFwcGluZyBheGlzLCBzbyBhZGQgaW4gYnVmZmVyIHRvIGRhdGEgZG9tYWluXG4gIHZhciB6b29tID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCdab29tJyk7IC8vIHVudXNlZCwgY2FwaXRhbGl6ZWQgWiBhbnl3YXkgYXMgY2hhbmdlZCBhYm92ZVxuXG4gIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNib3gzXCIpLmNoZWNrZWQ9PWZhbHNlKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ6b29teHlcIikudmFsdWUgPSBcIlwiO1xuICAgIHpvb21lZCA9IDA7XG4gICAgbmVlZFpvb20gPSBmYWxzZTtcbiAgICB4X21heCA9IGQzLm1heChkYXRhLCB4VmFsdWUpKzE7XG4gICAgeF9taW4gPSBkMy5taW4oZGF0YSwgeFZhbHVlKS0xO1xuICAgIHlfbWF4ID0gZDMubWF4KGRhdGEsIHlWYWx1ZSkrMTtcbiAgICB5X21pbiA9IGQzLm1pbihkYXRhLCB5VmFsdWUpLTE7XG4gIH1cblxuICAvLyBpZiB6b29tIGlzIGNoZWNrZWQgYW5kIGNvbmRpdGlvbnMgYXJlIHNhdGlzZmllZFxuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYm94M1wiKS5jaGVja2VkPT10cnVlICAmJiBuZWVkWm9vbSA9PSB0cnVlICYmIGNvb3JkaW5hdGVzeC5sZW5ndGggPj0gMikge1xuXG4gICAgeF9tYXggPSB4U2NhbGUuaW52ZXJ0KE1hdGgubWF4KGNvb3JkaW5hdGVzeFswXSwgY29vcmRpbmF0ZXN4WzFdKSkrMTtcbiAgICB4X21pbiA9IHhTY2FsZS5pbnZlcnQoTWF0aC5taW4oY29vcmRpbmF0ZXN4WzBdLCBjb29yZGluYXRlc3hbMV0pKS0xO1xuICAgIHlfbWF4ID0geVNjYWxlLmludmVydChNYXRoLm1pbihjb29yZGluYXRlc3lbMF0sIGNvb3JkaW5hdGVzeVsxXSkpKzE7XG4gICAgeV9taW4gPSB5U2NhbGUuaW52ZXJ0KE1hdGgubWF4KGNvb3JkaW5hdGVzeVswXSwgY29vcmRpbmF0ZXN5WzFdKSktMTtcblxuICAgIGNvbnNvbGUubG9nKHhfbWF4LCB4X21pbiwgeV9tYXgsIHlfbWluKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInpvb214eVwiKS52YWx1ZSA9IFwiWDpbXCIrcGFyc2VJbnQoeF9taW4pK1wiLCBcIitwYXJzZUludCh4X21heCkrXCJdIFk6W1wiK3BhcnNlSW50KHlfbWluKStcIiwgXCIrcGFyc2VJbnQoeV9tYXgpK1wiXVwiO1xuXG4gICAgem9vbWVkID0gMTtcbiAgICBuZWVkWm9vbSA9IGZhbHNlO1xuICAgICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2JveDNcIikuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIHpvb20gPSB6b29tLnN1YnN0cigxLCB6b29tLmxlbmd0aC0yKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFJbmRleCA9IHpvb20uaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgICAgICAgICB4X21pbiA9IHBhcnNlRmxvYXQoem9vbS5zdWJzdHIoMCwgY29tbWFJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB6b29tID0gem9vbS5zdWJzdHIoY29tbWFJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFJbmRleCA9IHpvb20uaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgICAgICAgICB4X21heCA9IHBhcnNlRmxvYXQoem9vbS5zdWJzdHIoMCwgY29tbWFJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB6b29tID0gem9vbS5zdWJzdHIoY29tbWFJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFJbmRleCA9IHpvb20uaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgICAgICAgICB5X21pbiA9IHBhcnNlRmxvYXQoem9vbS5zdWJzdHIoMCwgY29tbWFJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB5X21heCA9IHBhcnNlRmxvYXQoem9vbS5zdWJzdHIoY29tbWFJbmRleCsxKSk7XG4gICAgICAgICAgICAgICAgICAgICovXG4gIH1cbiAgeFNjYWxlLmRvbWFpbihbeF9taW4sIHhfbWF4XSk7XG4gIHlTY2FsZS5kb21haW4oW3lfbWluLCB5X21heF0pO1xuXG4gIC8vIHhTY2FsZS5kb21haW4oW2QzLm1pbihkYXRhLCB4VmFsdWUpLTEsIGQzLm1heChkYXRhLCB4VmFsdWUpKzFdKTtcbiAgLy8geVNjYWxlLmRvbWFpbihbZDMubWluKGRhdGEsIHlWYWx1ZSktMSwgZDMubWF4KGRhdGEsIHlWYWx1ZSkrMV0pO1xuXG5cbiAgLy8gSSBrbm93IGl0IGxvb2tzIHVnbHkgaW5qZWN0aW5nIHNvIG1hbnkgYXJndW1lbnRzIGludG8gdGhlIGluaXRpYWxpemVyIHJpZ2h0IG5vdyxcbiAgLy8gYnV0IGF0IGxlYXN0IHdlJ3JlIGJlaW5nIGV4cGxpY2l0IGFib3V0IGRlcGVuZGVuY2llcyBhcyBvcHBvc2VkIHRvXG4gIC8vIGltcGxpY2l0L3Rocm93aW5nIGV2ZXJ5dGhpbmcgaW50byBnbG9iYWwgc3RhdGVcbiAgbGV0IHN2Z0luaXRpYWxpemVyID0gbmV3IFN2Z0luaXRpYWxpemVyKGNvbG9yLCBjb2xvcl9jb2x1bW4sIHhfbWF4LCB4X21pbiwgeV9tYXgsIHlfbWluLCB0ZW1wMSwgdGVtcDIsIGNhdGVnb3JpZXMsIGRpY3QxLCBjb2x1bW5zKTtcbiAgbGV0IHN2ZyA9IHN2Z0luaXRpYWxpemVyLmluaXRpYWxpemVXaXRoTGFzc28oKTtcbiAgbGV0IGxhc3NvID0gc3ZnSW5pdGlhbGl6ZXIubGFzc287XG5cbiAgLy8geC1heGlzXG4gIGxldCBjeCA9IDA7XG4gIGxldCBjeSA9IDA7XG4gIGxldCBhbnMgPSAwO1xuXG4gIC8vIGRyYXcgdGhlIHgtYXhpcyBvZiBwbG90XG4gIHN2Zy5hcHBlbmQoXCJnXCIpXG4gIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAuY2FsbCh4QXhpcylcbiAgLmFwcGVuZChcInRleHRcIilcbiAgLmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsXCIpXG4gIC5hdHRyKFwieFwiLCB3aWR0aClcbiAgLmF0dHIoXCJ5XCIsIC02KVxuICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAudGV4dChcIlwiKTtcblxuICAvLyBkcmF3IHRoZSB5LWF4aXMgb2YgcGxvdFxuICBzdmcuYXBwZW5kKFwiZ1wiKVxuICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzXCIpXG4gIC5jYWxsKHlBeGlzKVxuICAuYXBwZW5kKFwidGV4dFwiKVxuICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIilcbiAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTkwKVwiKVxuICAuYXR0cihcInlcIiwgNilcbiAgLmF0dHIoXCJkeVwiLCBcIi43MWVtXCIpXG4gIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gIC50ZXh0KFwiXCIpO1xuXG4gIC8vIHRvIGlkZW50aWZ5IHRoZSBjb25kaXRpb24gb2YgdHJhbnNwYXJlbnQgY29sdW1uIHZhbHVlc1xuICBpZiAodHJhbnNwYXJlbnRfY29sdW1uICE9PSBcIlNlbGVjdFwiICYmIHZhbF90cmFuc3AgIT09IFwiXCIgJiYgdmFsX29wYWNpdHlOb01hdGNoICE9PSBcIlwiKSB7XG4gICAgdHJhbnNwYXJlbnRfY29sdW1uID0gdHJhbnNwYXJlbnRfY29sdW1uLnRvU3RyaW5nKCk7XG4gICAgdmFsX3RyYW5zcCA9IHZhbF90cmFuc3AudG9TdHJpbmcoKTsgLy8gPz8gbm8gdG8gbG93ZXIgY2FzZSBoZXJlP1xuICB9IGVsc2Uge1xuICAgIHZhbF90cmFuc3AgPSB2YWxfdHJhbnNwLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyBzZWFyY2hpbmcgYWNjb3JkaW5nIHRvIHRoZSBzdWJzdHJpbmcgZ2l2ZW4gYW5kIHNlYXJjaGluZyBjb2x1bW5cblxuICB2YXIgc2VhcmNoRnVuYzEgPSBmdW5jdGlvbihkKSB7XG4gICAgaWYgKHR5cGVvZiBkID09ICd1bmRlZmluZWQnICkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIG5vTWF0Y2ggdHJ1ZSBpZiBub3QgZm91bmRcbiAgICB2YXIgbm9NYXRjaDtcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3g1JykuY2hlY2tlZCkge1xuICAgICAgbm9NYXRjaCA9IGQgIT0gdmFsX3NlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9NYXRjaCA9IGQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbF9zZWFyY2gudG9Mb3dlckNhc2UoKSkgPCAwXG4gICAgICB8fCB2YWxfc2VhcmNoLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG5vTWF0Y2ggPyAxIDogMjtcbiAgfTtcblxuICB2YXIgc2VhcmNoZWRfZGF0YSA9IFtdLCBzZWFyY2hlZF9kYXRhX2luZGljZXMgPSBbXSwgZF90ZW1wO1xuICAvKiB0ZW1wMyBob2xkcyB0aGUgdmFsdWUgb2YgZXZlcnkgcG9pbnQgZm9yIHRoZSBzZWFyY2ggY29sdW1uICovXG4gIGZvciAodmFyIGk9MDtpPHRlbXAzLmxlbmd0aDtpKyspIHtcbiAgICAvLyAwIGlmIGZvdW5kIHZhbCBpbiB0aGlzIHBvaW50LCAxIGlmIG5vdCBmb3VuZFxuICAgIGlmICggc2VhcmNoRnVuYzEodGVtcDNbaV0pLTEgKSB7XG4gICAgICBkX3RlbXAgPSB7fTtcbiAgICAgIC8vIGVudGVyIGFsbCBkYXRhIGludG8gZGljdGlvbmFyeVxuICAgICAgZm9yKHZhciBqPTE7ajxjYXRlZ29yaWVzLmxlbmd0aDtqKyspIHtcbiAgICAgICAgZF90ZW1wW2NhdGVnb3JpZXNbal1dID0gZGljdDFbY2F0ZWdvcmllc1tqXV1baV07XG4gICAgICB9XG4gICAgICAvLyBvbmx5IGFkZCB0byBzZWFyY2hlZF9kYXRhIGlmIG5vdCBhbHJlYWR5IGluXG4gICAgICBpZihzZWFyY2hEaWMoc2VhcmNoZWRfZGF0YSwgZF90ZW1wKSA9PT0gdHJ1ZSkge1xuICAgICAgICBzZWFyY2hlZF9kYXRhLnB1c2goZF90ZW1wKTtcbiAgICAgICAgc2VhcmNoZWRfZGF0YV9pbmRpY2VzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNyZWF0ZSB0aGUgdGFibGVcbiAgaWYgKCB2YWxfc2VhcmNoICE9IFwiXCIgJiYgc2VhcmNoZWRfZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHBlb3BsZVRhYmxlMSA9IHRhYnVsYXRlKHNlYXJjaGVkX2RhdGEsIGNvbHVtbnMpO1xuICAgIGlmIChxdWVyeVBhcmFtcy5nZXQoJ3NlbWFudGljX21vZGVsJykgPT09IFwidHJ1ZVwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlByZWRpY3Rpbmcgd29yZHMuLi5cIik7XG4gICAgICBjbGFzc2lmeShzZWFyY2hlZF9kYXRhX2luZGljZXMsIHZlY3RvcnNwYWNlXzJkYXJyYXksIHdlaWdodHNfMmRhcnJheSwgYmlhc2VzXzFkYXJyYXksIHZvY2FiXzFkYXJyYXkpO1xuICAgICAgYmVuY2htYXJrKHNlYXJjaGVkX2RhdGFfaW5kaWNlcywgYm93XzJkYXJyYXksIHZvY2FiXzFkYXJyYXkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBkZXRlcm1pbmVzIHRoZSByb3RhdGlvbiBvZiBzeW1ib2xzIHRoYXQgY2FuIGJlIGRvbmVcbiAgXG5cbiAgLyoqKiBCRUdJTiBkcmF3aW5nIGRvdHMgKioqL1xuXG4gIC8vIHNoYXBpbmcgb2Ygc3ltYm9scyBhY2NvcmRpbmcgdG8gdGhlIHNoYXBpbmcgY29sdW1uXG4gIGlmIChzaGFwaW5nX2NvbHVtbiAhPT0gXCJTZWxlY3RcIiApIHtcbiAgICAvLyBjb2xvcl9jb2x1bW4gPSBzaGFwaW5nX2NvbHVtbjtcbiAgICB2YXIgcG9pbnRzID0gc3ZnLnNlbGVjdEFsbChcIi5kb3RcIilcbiAgICAuZGF0YShkYXRhKVxuICAgIC5lbnRlcigpO1xuXG4gICAgcG9pbnRzLmFwcGVuZChcInBhdGhcIilcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKGQpeyByZXR1cm4gKGRvdFNlYXJjaEZpbHRlcihkLCBjYXRlZ29yeV9zZWFyY2gsIHZhbF9zZWFyY2gpID09IDEpOyB9KVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJwb2ludFwiKVxuICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwMDBcIilcbiAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMSlcbiAgICAvLyAuYXR0cihcImRcIiwgZDMuc3ZnLnN5bWJvbCgpLnR5cGUoZnVuY3Rpb24oZCkge3JldHVybiBzeW1ib2xzW3N5bWJvbFtkW3NoYXBpbmdfY29sdW1uXV0lNl07fSkuc2l6ZSggZnVuY3Rpb24oZCkge3JldHVybiBzaXplc1twYXJzZUludChzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dLzYpJTRdO30pKVxuICAgIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2XTt9KS5zaXplKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZG90U2VhcmNoRmlsdGVyKGQsIGNhdGVnb3J5X3NlYXJjaCwgdmFsX3NlYXJjaCktMSA/IDE4MDozMDt9KSlcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIHhNYXAoZCkgKyBcIixcIiArIHlNYXAoZCkgKyBcIikgcm90YXRlKFwiICsgc2l6ZXNbcGFyc2VJbnQoc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2KV1bcGFyc2VJbnQoc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXS82KSU0XSArIFwiKVwiOyB9KVxuICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gyJykuY2hlY2tlZCA/IGNvbG9yKGNWYWx1ZTIoZCkpIDogY29sb3IoY1ZhbHVlKGQpKTt9KVxuICAgIC5zdHlsZShcIm9wYWNpdHlcIixmdW5jdGlvbihkKSB7IHJldHVybiB0cmFuc3BhcihkLCB2YWxfdHJhbnNwLCB0cmFuc3BhcmVudF9jb2x1bW4sIHZhbF9vcGFjaXR5TWF0Y2gsIHZhbF9vcGFjaXR5Tm9NYXRjaCk7fSlcblxuICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICB0b29sdGlwLmh0bWwoXG4gICAgICAgIHByaW50QXJyYXkoY2F0ZWdvcnlfc2VhcmNoX2RhdGEsIGQpKVxuICAgICAgLnN0eWxlKFwibGVmdFwiLCA2MCArIFwicHhcIilcbiAgICAgIC5zdHlsZShcInRvcFwiLCAzMCArIFwicHhcIik7XG4gICAgfSlcbiAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICBkMy5zZWxlY3QodGhpcykuYXR0cihcInJcIiwgZnVuY3Rpb24oZCl7IHJldHVybiBkb3RTZWFyY2hGaWx0ZXIoZCwgY2F0ZWdvcnlfc2VhcmNoLCB2YWxfc2VhcmNoKS0xID8gNzozIDsgfSlcbiAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY29sb3IoY1ZhbHVlKGQpKTt9KTtcbiAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICB9KVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAudGV4dChkW2ZlYXR1cmVfY29sdW1uXSlcbiAgICAgIC5hdHRyKFwieFwiLCAoZDMuZXZlbnQucGFnZVgtNTApKVxuICAgICAgLmF0dHIoXCJ5XCIsIChkMy5ldmVudC5wYWdlWS0zNSkpO1xuICAgIH0pO1xuXG4gICAgcG9pbnRzLmFwcGVuZChcInBhdGhcIilcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKGQpeyByZXR1cm4gKGRvdFNlYXJjaEZpbHRlcihkLCBjYXRlZ29yeV9zZWFyY2gsIHZhbF9zZWFyY2gpID09IDIpOyB9KVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJwb2ludFwiKVxuICAgIC5zdHlsZShcInN0cm9rZVwiLCBcInllbGxvd1wiKVxuICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyKVxuICAgIC8vIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2XTt9KS5zaXplKCBmdW5jdGlvbihkKSB7cmV0dXJuIHNpemVzW3BhcnNlSW50KHN5bWJvbFtkW3NoYXBpbmdfY29sdW1uXV0vNiklNF07fSkpXG4gICAgLmF0dHIoXCJkXCIsIGQzLnN2Zy5zeW1ib2woKS50eXBlKGZ1bmN0aW9uKGQpIHtyZXR1cm4gc3ltYm9sc1tzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dJTZdO30pLnNpemUoZnVuY3Rpb24oZCkge3JldHVybiBkb3RTZWFyY2hGaWx0ZXIoZCwgY2F0ZWdvcnlfc2VhcmNoLCB2YWxfc2VhcmNoKS0xID8gMTgwOjMwO30pKVxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeE1hcChkKSArIFwiLFwiICsgeU1hcChkKSArIFwiKSByb3RhdGUoXCIgKyBzaXplc1twYXJzZUludChzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dJTYpXVtwYXJzZUludChzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dLzYpJTRdICsgXCIpXCI7IH0pXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDInKS5jaGVja2VkID8gY29sb3IoY1ZhbHVlMihkKSkgOiBjb2xvcihjVmFsdWUoZCkpO30pXG4gICAgLnN0eWxlKFwib3BhY2l0eVwiLGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRyYW5zcGFyKGQsIHZhbF90cmFuc3AsIHRyYW5zcGFyZW50X2NvbHVtbiwgdmFsX29wYWNpdHlNYXRjaCwgdmFsX29wYWNpdHlOb01hdGNoKTt9KVxuXG4gICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMjAwKVxuICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgIHRvb2x0aXAuaHRtbChcbiAgICAgICAgcHJpbnRBcnJheShjYXRlZ29yeV9zZWFyY2hfZGF0YSwgZCkpXG4gICAgICAuc3R5bGUoXCJsZWZ0XCIsIDYwICsgXCJweFwiKVxuICAgICAgLnN0eWxlKFwidG9wXCIsIDMwICsgXCJweFwiKTtcbiAgICB9KVxuICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKFwiclwiLCBmdW5jdGlvbihkKXsgcmV0dXJuIGRvdFNlYXJjaEZpbHRlcihkLCBjYXRlZ29yeV9zZWFyY2gsIHZhbF9zZWFyY2gpLTEgPyA3OjMgOyB9KVxuICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBjb2xvcihjVmFsdWUoZCkpO30pO1xuICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgIH0pXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgIC50ZXh0KGRbZmVhdHVyZV9jb2x1bW5dKVxuICAgICAgLmF0dHIoXCJ4XCIsIChkMy5ldmVudC5wYWdlWC01MCkpXG4gICAgICAuYXR0cihcInlcIiwgKGQzLmV2ZW50LnBhZ2VZLTM1KSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGRvdHNBcnRpc3QgPSBuZXcgRG90c0FydGlzdChcbiAgICAgIHN2ZyxcbiAgICAgIGRhdGEsXG4gICAgICBjYXRlZ29yeV9zZWFyY2gsXG4gICAgICBjYXRlZ29yeV9zZWFyY2hfZGF0YSxcbiAgICAgIHZhbF9zZWFyY2gsXG4gICAgICBjb2xvcixcbiAgICAgIGNWYWx1ZTIsXG4gICAgICBjVmFsdWUsXG4gICAgICB2YWxfdHJhbnNwLFxuICAgICAgdHJhbnNwYXJlbnRfY29sdW1uLFxuICAgICAgdmFsX29wYWNpdHlNYXRjaCxcbiAgICAgIHZhbF9vcGFjaXR5Tm9NYXRjaFxuICAgIClcbiAgICBkb3RzQXJ0aXN0LmRyYXdVbm1hdGNoZWREb3RzKCk7XG4gICAgZG90c0FydGlzdC5kcmF3TWF0Y2hlZERvdHMoKTtcblxuICAgIC8vIHRoZSBldmVudCB0byBjYWxsIG9uIGNsaWNrIGV2ZW50XG4gICAgc3ZnLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpIHtcbiAgICAgIC8vIHN2Zy5zZWxlY3QoXCIjbXlUZXh0XCIpLnJlbW92ZSgpO1xuXG4gICAgICB0b29sdGlwMS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMxID0gZDMubW91c2UodGhpcyk7XG4gICAgICBjb29yZGluYXRlc3gudW5zaGlmdChjb29yZGluYXRlczFbMF0pO1xuICAgICAgY29vcmRpbmF0ZXN5LnVuc2hpZnQoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICAgIGNvbnNvbGUubG9nKGNvb3JkaW5hdGVzeCwgY29vcmRpbmF0ZXN5KTtcbiAgICB9KVxuXG4gICAgLyogY2FuIG1vdmUgdXAgaW50byB0aGUgaWYvZWxzZSwgYnV0IG1vcmUgY2xlYXIgdG8gc2VwYXJhdGUgZnVuY3Rpb25hbGl0eSAqL1xuICAgIGlmIChzaGFwaW5nX2NvbHVtbiAhPT0gXCJTZWxlY3RcIiApIHtcbiAgICAgIGxhc3NvLml0ZW1zKGQzLnNlbGVjdEFsbChcIi5kb3RcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXNzby5pdGVtcyhkMy5zZWxlY3RBbGwoXCIuZG90XCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gY29sb3IuZG9tYWluKCkubGVuZ3RoO1xuICAgIC8vIGlmIHNwZWN0cnVtXG4gICAgaWYgKG51bWVyaWNzW2NvbG9yX2NvbHVtbl0gJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gxJykuY2hlY2tlZCkge1xuXG4gICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gyJykuY2hlY2tlZCkge1xuICAgICAgICBtMSA9IChkMy5taW4oZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBNYXRoLmxvZyhwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSkpOyB9KSkpO1xuICAgICAgICBtMiA9IChkMy5tYXgoZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBNYXRoLmxvZyhwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSkpOyB9KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbTEgPSAoZDMubWluKGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtyZXR1cm4gcGFyc2VGbG9hdChkW2NvbG9yX2NvbHVtbl0pfSkpKTtcbiAgICAgICAgbTIgPSAoZDMubWF4KGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtyZXR1cm4gcGFyc2VGbG9hdChkW2NvbG9yX2NvbHVtbl0pfSkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKG0xLCBtMik7XG4gICAgICBtMSA9IE1hdGgubWF4KE51bWJlci5NSU5fVkFMVUUsIG0xKTtcbiAgICAgIGNvbnNvbGUubG9nKG0xLCBtMik7XG5cbiAgICAgIHZhciBsZWdlbmQgPSBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKVxuICAgICAgLmRhdGEoY29sb3IuZG9tYWluKCkpXG4gICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpO1xuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBsZWdlbmQuYXBwZW5kKCdkZWZzJylcbiAgICAgIC5hcHBlbmQoJ2xpbmVhckdyYWRpZW50JylcbiAgICAgIC5hdHRyKCdpZCcsICdncmFkaWVudCcpXG4gICAgICAuYXR0cigneDEnLCAnMCUnKSAvLyBib3R0b21cbiAgICAgIC5hdHRyKCd5MScsICcxMDAlJylcbiAgICAgIC5hdHRyKCd4MicsICcwJScpIC8vIHRvIHRvcFxuICAgICAgLmF0dHIoJ3kyJywgJzAlJylcbiAgICAgIC5hdHRyKCdzcHJlYWRNZXRob2QnLCAncGFkJyk7XG5cbiAgICAgIHZhciBwY3QgPSBsaW5TcGFjZSgwLCAxMDAsIHNjYWxlLmxlbmd0aCkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZCkgKyAnJSc7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNvbG91clBjdCA9IGQzLnppcChwY3QsIHNjYWxlKTtcbiAgICAgIGNvbG91clBjdC5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgZ3JhZGllbnQuYXBwZW5kKCdzdG9wJylcbiAgICAgICAgLmF0dHIoJ29mZnNldCcsIGRbMF0pXG4gICAgICAgIC5hdHRyKCdzdG9wLWNvbG9yJywgZFsxXSlcbiAgICAgICAgLmF0dHIoJ3N0b3Atb3BhY2l0eScsIDEpO1xuICAgICAgfSk7XG5cbiAgICAgIGxlZ2VuZC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgLmF0dHIoJ3gxJywgMClcbiAgICAgIC5hdHRyKCd5MScsIDApXG4gICAgICAuYXR0cignd2lkdGgnLCAxOClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCAxNTApXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIDU4MiArIFwiLCAwKVwiKVxuICAgICAgLnN0eWxlKCdmaWxsJywgJ3VybCgjZ3JhZGllbnQpJyk7XG5cbiAgICAgIHZhciBsZWdlbmRTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAuZG9tYWluKFttMSwgbTJdKVxuICAgICAgLnJhbmdlKFsxNTAsIDBdKTtcblxuICAgICAgdmFyIGxlZ2VuZEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAuc2NhbGUobGVnZW5kU2NhbGUpXG4gICAgICAub3JpZW50KFwicmlnaHRcIilcbiAgICAgIC8vIC50aWNrVmFsdWVzKFttMSwgbTJdKVxuICAgICAgLnRpY2tzKDEwKTtcblxuICAgICAgbGVnZW5kLmFwcGVuZChcImdcIilcbiAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsZWdlbmQgYXhpc1wiKVxuICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyA2MDAgKyBcIiwgMClcIilcbiAgICAgIC5jYWxsKGxlZ2VuZEF4aXMpO1xuICAgIH0gZWxzZSB7IC8vIG5vIHNwZWN0cnVtXG4gICAgICBjb25zb2xlLmxvZyhPYmplY3QpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzeW1ib2wpO1xuICAgICAgbGV0IGxlbmcgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5nPDIwICYmIHNoYXBpbmdfY29sdW1uICE9IFwiU2VsZWN0XCIpIHtcbiAgICAgICAgLy8gZHJhdyBsZWdlbmRcbiAgICAgICAgLy8gPz8gTm90IHN1cmUgd2h5LCBidXQgdGhpcyBsZWdlbmQgYXBwZWFycyBub3QgdG8gc2hvd1xuICAgICAgICB2YXIgbGVnZW5kID0gc3ZnLnNlbGVjdEFsbChcIi5sZWdlbmRcIilcbiAgICAgICAgLmRhdGEoa2V5cylcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgLy8gLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKTtcbiAgICAgICAgLy8gLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoMzAsXCIgKyBpICogMjAgKyBcIilcIjsgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGtleXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhzaGFwaW5nX2NvbHVtbik7XG4gICAgICAgIGNvbnNvbGUubG9nKHN5bWJvbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHN5bWJvbHMpO1xuICAgICAgICAvLyBkcmF3IGxlZ2VuZCBjb2xvcmVkIHJlY3RhbmdsZXNcbiAgICAgICAgbGVnZW5kLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC8vIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2RdJTZdO30pLnNpemUoZnVuY3Rpb24oZCkge3JldHVybiBzaXplc1twYXJzZUludChzeW1ib2xbZF0vNiklM107fSkpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZDMuc3ZnLnN5bWJvbCgpLnR5cGUoZnVuY3Rpb24oZCkge3JldHVybiBzeW1ib2xzW3N5bWJvbFtkXSU2XTt9KSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCB3aWR0aCArIDApXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDE4KVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMTgpXG4gICAgICAgICAgICAvLyAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIDIwICsgXCIsXCIgKyBpKjIwICsgXCIpXCI7IH0pO1xuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAyMCArIFwiLFwiICsgaSoyMCArIFwiKSByb3RhdGUoXCIgKyBzaXplc1twYXJzZUludChzeW1ib2xbZF0lNildW3BhcnNlSW50KHN5bWJvbFtkXS82KSU0XSArIFwiKVwiOyB9KTtcbiAgICAgICAgLy8gZHJhdyBsZWdlbmQgdGV4dFxuICAgICAgICBsZWdlbmQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLy8gLmF0dHIoXCJ4XCIsIDEwMCArIDApXG4gICAgICAgICAgICAvLyAuYXR0cihcInlcIiwgNClcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJiZWdpblwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoMzAsXCIgKyBpICogMjAgKyBcIilcIjsgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGxlbiA8PSAzMCAmJiBjb2xvcl9jb2x1bW4gIT0gXCJTZWxlY3RcIikge1xuXG4gICAgICAgIC8vIGRyYXcgbGVnZW5kXG4gICAgICAgIHZhciBsZWdlbmQgPSBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKVxuICAgICAgICAuZGF0YShjb2xvci5kb21haW4oKSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyBpICogMjAgKyBcIilcIjsgfSk7XG5cbiAgICAgICAgLy8gZHJhdyBsZWdlbmQgY29sb3JlZCByZWN0YW5nbGVzXG4gICAgICAgIGxlZ2VuZC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCB3aWR0aCArIDYpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgMTgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDE4KVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcblxuICAgICAgICAvLyBkcmF3IGxlZ2VuZCB0ZXh0XG4gICAgICAgIGxlZ2VuZC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCB3aWR0aCArIDApXG4gICAgICAgIC5hdHRyKFwieVwiLCA5KVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjM1ZW1cIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICB9KTsgLy8gZW5kIGxvYWQgZGF0YVxufSAvLyBlbmQgaGlnaGxpZ2h0aW5nIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/modules/constants.js":
/*!**********************************!*\
  !*** ./src/modules/constants.js ***!
  \**********************************/
/*! exports provided: margin, width, height, d3_category20_shuffled, scale_d, scale, sizes, symbols */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"margin\", function() { return margin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"width\", function() { return width; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"height\", function() { return height; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d3_category20_shuffled\", function() { return d3_category20_shuffled; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale_d\", function() { return scale_d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sizes\", function() { return sizes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"symbols\", function() { return symbols; });\nconst margin = { top: 90, right: 40, bottom: 40, left: 40 };\nconst width = 700 - margin.left - margin.right;\nconst height = 750 - margin.top - margin.bottom;\n\n// Can generate more with http://jnnnnn.github.io/category-colors-2L-inplace.html if want more\nconst d3_category20_shuffled = [\n\t\"#1f77b4\",\n\t\"#ff7f0e\",\n\t\"#2ca02c\",\n\t\"#d62728\",\n\t\"#9467bd\",\n\t\"#8c564b\",\n\t\"#e377c2\",\n\t\"#7f7f7f\",\n\t\"#bcbd22\",\n\t\"#17becf\",\n\t\"#aec7e8\",\n\t\"#ffbb78\",\n\t\"#98df8a\",\n\t\"#ff9896\",\n\t\"#c5b0d5\",\n\t\"#c49c94\",\n\t\"#f7b6d2\",\n\t\"#c7c7c7\",\n\t\"#dbdb8d\",\n\t\"#9edae5\"\n];\n\n// provides different colored spectrum\nconst scale_d = {\n  'puOr11': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n  'spectral8': ['#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#e6f598', '#abdda4', '#66c2a5', '#3288bd'],\n  'redBlackGreen': ['#ff0000', '#AA0000', '#550000', '#005500', '#00AA00', '#00ff00'],\n};\nconst scale = scale_d['spectral8'];\n\nconst sizes = {};\nsizes[0] = [\"0\", \"90\", \"0\", \"0\"];\nsizes[1] = [\"0\", \"45\", \"0\", \"0\"];\nsizes[2] = [\"0\", \"90\", \"0\", \"0\"];\nsizes[3] = [\"0\", \"45\", \"0\", \"0\"];\nsizes[4] = [\"0\", \"90\", \"0\", \"0\"];\nsizes[5] = [\"0\", \"0\", \"0\", \"0\"];\nconst symbols = [\"diamond\", \"cross\", \"triangle-up\", \"square\", \"triangle-down\",\"circle\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9jb25zdGFudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9jb25zdGFudHMuanM/MzRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgbWFyZ2luID0geyB0b3A6IDkwLCByaWdodDogNDAsIGJvdHRvbTogNDAsIGxlZnQ6IDQwIH07XG5leHBvcnQgY29uc3Qgd2lkdGggPSA3MDAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbmV4cG9ydCBjb25zdCBoZWlnaHQgPSA3NTAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuLy8gQ2FuIGdlbmVyYXRlIG1vcmUgd2l0aCBodHRwOi8vam5ubm5uLmdpdGh1Yi5pby9jYXRlZ29yeS1jb2xvcnMtMkwtaW5wbGFjZS5odG1sIGlmIHdhbnQgbW9yZVxuZXhwb3J0IGNvbnN0IGQzX2NhdGVnb3J5MjBfc2h1ZmZsZWQgPSBbXG5cdFwiIzFmNzdiNFwiLFxuXHRcIiNmZjdmMGVcIixcblx0XCIjMmNhMDJjXCIsXG5cdFwiI2Q2MjcyOFwiLFxuXHRcIiM5NDY3YmRcIixcblx0XCIjOGM1NjRiXCIsXG5cdFwiI2UzNzdjMlwiLFxuXHRcIiM3ZjdmN2ZcIixcblx0XCIjYmNiZDIyXCIsXG5cdFwiIzE3YmVjZlwiLFxuXHRcIiNhZWM3ZThcIixcblx0XCIjZmZiYjc4XCIsXG5cdFwiIzk4ZGY4YVwiLFxuXHRcIiNmZjk4OTZcIixcblx0XCIjYzViMGQ1XCIsXG5cdFwiI2M0OWM5NFwiLFxuXHRcIiNmN2I2ZDJcIixcblx0XCIjYzdjN2M3XCIsXG5cdFwiI2RiZGI4ZFwiLFxuXHRcIiM5ZWRhZTVcIlxuXTtcblxuLy8gcHJvdmlkZXMgZGlmZmVyZW50IGNvbG9yZWQgc3BlY3RydW1cbmV4cG9ydCBjb25zdCBzY2FsZV9kID0ge1xuICAncHVPcjExJzogWycjN2YzYjA4JywgJyNiMzU4MDYnLCAnI2UwODIxNCcsICcjZmRiODYzJywgJyNmZWUwYjYnLCAnI2Y3ZjdmNycsICcjZDhkYWViJywgJyNiMmFiZDInLCAnIzgwNzNhYycsICcjNTQyNzg4JywgJyMyZDAwNGInXSxcbiAgJ3NwZWN0cmFsOCc6IFsnI2Q1M2U0ZicsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZTZmNTk4JywgJyNhYmRkYTQnLCAnIzY2YzJhNScsICcjMzI4OGJkJ10sXG4gICdyZWRCbGFja0dyZWVuJzogWycjZmYwMDAwJywgJyNBQTAwMDAnLCAnIzU1MDAwMCcsICcjMDA1NTAwJywgJyMwMEFBMDAnLCAnIzAwZmYwMCddLFxufTtcbmV4cG9ydCBjb25zdCBzY2FsZSA9IHNjYWxlX2RbJ3NwZWN0cmFsOCddO1xuXG5leHBvcnQgY29uc3Qgc2l6ZXMgPSB7fTtcbnNpemVzWzBdID0gW1wiMFwiLCBcIjkwXCIsIFwiMFwiLCBcIjBcIl07XG5zaXplc1sxXSA9IFtcIjBcIiwgXCI0NVwiLCBcIjBcIiwgXCIwXCJdO1xuc2l6ZXNbMl0gPSBbXCIwXCIsIFwiOTBcIiwgXCIwXCIsIFwiMFwiXTtcbnNpemVzWzNdID0gW1wiMFwiLCBcIjQ1XCIsIFwiMFwiLCBcIjBcIl07XG5zaXplc1s0XSA9IFtcIjBcIiwgXCI5MFwiLCBcIjBcIiwgXCIwXCJdO1xuc2l6ZXNbNV0gPSBbXCIwXCIsIFwiMFwiLCBcIjBcIiwgXCIwXCJdO1xuZXhwb3J0IGNvbnN0IHN5bWJvbHMgPSBbXCJkaWFtb25kXCIsIFwiY3Jvc3NcIiwgXCJ0cmlhbmdsZS11cFwiLCBcInNxdWFyZVwiLCBcInRyaWFuZ2xlLWRvd25cIixcImNpcmNsZVwiXTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/constants.js\n");

/***/ }),

/***/ "./src/modules/dots_artist.js":
/*!************************************!*\
  !*** ./src/modules/dots_artist.js ***!
  \************************************/
/*! exports provided: DotsArtist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DotsArtist\", function() { return DotsArtist; });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ \"./src/modules/utilities.js\");\n/* harmony import */ var _tooltips__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tooltips */ \"./src/modules/tooltips.js\");\n\n\n\nfunction DotsArtist (svg, data, categorySearch, categorySearchData, valSearch, color, cValue2, cValue, valTransp, transparentColumn, valOpacityMatch, valOpacityNoMatch) {\n  this.marked = {}; // store X,Y coordinates of data points that have been clicked;\n  this.points = svg.selectAll(\".dot\").data(data).enter();\n\n  // ******************************************\n  // Utility Functions\n  // ******************************************\n  this.matchedDots = (categorySearch, valSearch, match) => {\n    if (match) {\n      return (dot) => {\n        return Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"dotSearchFilter\"])(dot, categorySearch, valSearch) === 2;\n      }\n    }\n    return (dot) => {\n      return Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"dotSearchFilter\"])(dot, categorySearch, valSearch) === 1;\n    }\n  };\n\n  let mouseoverCallback = (categorySearchData) => {\n    return (dot) => {\n      _tooltips__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].transition()\n             .duration(200)\n             .style(\"opacity\", 1);\n      _tooltips__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].html(Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"printArray\"])(categorySearchData, dot))\n             .style(\"left\", \"60 px\")\n             .style(\"top\", \"30 px\");\n    };\n  };\n\n  let mouseoutCallback = (dot) => {\n    _tooltips__WEBPACK_IMPORTED_MODULE_1__[\"tooltip\"].transition()\n           .duration(500)\n           .style(\"opacity\", 0);\n  };\n\n  let clickCallback = () => {\n    let desensitizeClickArea = () => {\n      this.marked[[d3.event.pageX, d3.event.pageY]] = true;\n      for (let i = 1; i < 4; i++) {\n        this.marked[[d3.event.pageX - i, d3.event.pageY - i]] = true;\n        this.marked[[d3.event.pageX + i, d3.event.pageY + i]] = true;\n        this.marked[[d3.event.pageX - i, d3.event.pageY + i]] = true;\n        this.marked[[d3.event.pageX + i, d3.event.pageY - i]] = true;\n      }\n    };\n\n    let featureColumn = document.getElementsByClassName('click-on-feature')[0].value;\n    return (dot) => {\n      if (!([d3.event.pageX, d3.event.pageY] in this.marked)) {\n        desensitizeClickArea();\n        svg.append(\"text\")\n           .text(dot[featureColumn])\n           .attr(\"x\", (d3.event.pageX - 50))\n           .attr(\"y\", (d3.event.pageY - 35))\n           .on(\"mouseover\", mouseoverCallback(categorySearchData))\n           .on(\"mouseout\", mouseoutCallback)\n           .on(\"click\", clickCallback)\n      }\n    }\n  };\n\n  let drawDots = (dots, attributes) => {\n    let fill = (dot) => {\n      if (document.getElementById('cbox2').checked) return color(cValue2(dot));\n      return color(cValue(dot));\n    };\n    let opacity = (dot) => {\n      return Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"transpar\"])(dot, valTransp, transparentColumn, valOpacityMatch, valOpacityNoMatch)\n    };\n    // consistent attributes\n    dots.attr('class', 'dot')\n        .attr(\"cx\", _utilities__WEBPACK_IMPORTED_MODULE_0__[\"xMap\"])\n        .attr(\"cy\", _utilities__WEBPACK_IMPORTED_MODULE_0__[\"yMap\"])\n        .on(\"mouseover\", mouseoverCallback(categorySearchData))\n        .on(\"mouseout\", mouseoutCallback)\n        .on(\"click\", clickCallback())\n        .style('fill', fill)\n        .style('opacity', opacity)\n\n    // customized attributes\n    dots.attr('r', attributes['radiusSize']) //radius size\n        .style('stroke', attributes['borderColor']) // border color\n        .style('stroke-width', attributes['borderWidth'])\n  };\n\n  // ******************************************\n  // Dot Attributes\n  // ******************************************\n  let unmatchedDotsAttributes = {\n    radiusSize: 3,\n    borderColor: '#000',\n    borderWidth: 1,\n  };\n\n  let matchedDotsAttributes = {\n    radiusSize: 7,\n    borderColor: 'yellow',\n    borderWidth: 2\n  };\n\n  // ******************************************\n  // Draw Functions\n  // ******************************************\n  // dots that were not a match for search parameters (consider function rename?)\n  this.drawUnmatchedDots = () => {\n    let unmatchedDots = this.points\n                            .append(\"circle\")\n                            .filter(this.matchedDots(categorySearch, valSearch, false));\n    drawDots(unmatchedDots, unmatchedDotsAttributes);\n  };\n\n  this.drawMatchedDots = () => {\n    let matchedDots = this.points\n                          .append('circle')\n                          .filter(this.matchedDots(categorySearch, valSearch, true));\n   drawDots(matchedDots, matchedDotsAttributes);\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9kb3RzX2FydGlzdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL2RvdHNfYXJ0aXN0LmpzPzdlMmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZG90U2VhcmNoRmlsdGVyLFxuICBwcmludEFycmF5LFxuICB0cmFuc3BhcixcbiAgeE1hcCxcbiAgeU1hcFxufSBmcm9tICcuL3V0aWxpdGllcyc7XG5pbXBvcnQgeyB0b29sdGlwIH0gZnJvbSAnLi90b29sdGlwcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBEb3RzQXJ0aXN0IChzdmcsIGRhdGEsIGNhdGVnb3J5U2VhcmNoLCBjYXRlZ29yeVNlYXJjaERhdGEsIHZhbFNlYXJjaCwgY29sb3IsIGNWYWx1ZTIsIGNWYWx1ZSwgdmFsVHJhbnNwLCB0cmFuc3BhcmVudENvbHVtbiwgdmFsT3BhY2l0eU1hdGNoLCB2YWxPcGFjaXR5Tm9NYXRjaCkge1xuICB0aGlzLm1hcmtlZCA9IHt9OyAvLyBzdG9yZSBYLFkgY29vcmRpbmF0ZXMgb2YgZGF0YSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gY2xpY2tlZDtcbiAgdGhpcy5wb2ludHMgPSBzdmcuc2VsZWN0QWxsKFwiLmRvdFwiKS5kYXRhKGRhdGEpLmVudGVyKCk7XG5cbiAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICB0aGlzLm1hdGNoZWREb3RzID0gKGNhdGVnb3J5U2VhcmNoLCB2YWxTZWFyY2gsIG1hdGNoKSA9PiB7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gKGRvdCkgPT4ge1xuICAgICAgICByZXR1cm4gZG90U2VhcmNoRmlsdGVyKGRvdCwgY2F0ZWdvcnlTZWFyY2gsIHZhbFNlYXJjaCkgPT09IDI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoZG90KSA9PiB7XG4gICAgICByZXR1cm4gZG90U2VhcmNoRmlsdGVyKGRvdCwgY2F0ZWdvcnlTZWFyY2gsIHZhbFNlYXJjaCkgPT09IDE7XG4gICAgfVxuICB9O1xuXG4gIGxldCBtb3VzZW92ZXJDYWxsYmFjayA9IChjYXRlZ29yeVNlYXJjaERhdGEpID0+IHtcbiAgICByZXR1cm4gKGRvdCkgPT4ge1xuICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAuZHVyYXRpb24oMjAwKVxuICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICB0b29sdGlwLmh0bWwocHJpbnRBcnJheShjYXRlZ29yeVNlYXJjaERhdGEsIGRvdCkpXG4gICAgICAgICAgICAgLnN0eWxlKFwibGVmdFwiLCBcIjYwIHB4XCIpXG4gICAgICAgICAgICAgLnN0eWxlKFwidG9wXCIsIFwiMzAgcHhcIik7XG4gICAgfTtcbiAgfTtcblxuICBsZXQgbW91c2VvdXRDYWxsYmFjayA9IChkb3QpID0+IHtcbiAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICB9O1xuXG4gIGxldCBjbGlja0NhbGxiYWNrID0gKCkgPT4ge1xuICAgIGxldCBkZXNlbnNpdGl6ZUNsaWNrQXJlYSA9ICgpID0+IHtcbiAgICAgIHRoaXMubWFya2VkW1tkMy5ldmVudC5wYWdlWCwgZDMuZXZlbnQucGFnZVldXSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICB0aGlzLm1hcmtlZFtbZDMuZXZlbnQucGFnZVggLSBpLCBkMy5ldmVudC5wYWdlWSAtIGldXSA9IHRydWU7XG4gICAgICAgIHRoaXMubWFya2VkW1tkMy5ldmVudC5wYWdlWCArIGksIGQzLmV2ZW50LnBhZ2VZICsgaV1dID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXJrZWRbW2QzLmV2ZW50LnBhZ2VYIC0gaSwgZDMuZXZlbnQucGFnZVkgKyBpXV0gPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcmtlZFtbZDMuZXZlbnQucGFnZVggKyBpLCBkMy5ldmVudC5wYWdlWSAtIGldXSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBmZWF0dXJlQ29sdW1uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2xpY2stb24tZmVhdHVyZScpWzBdLnZhbHVlO1xuICAgIHJldHVybiAoZG90KSA9PiB7XG4gICAgICBpZiAoIShbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXSBpbiB0aGlzLm1hcmtlZCkpIHtcbiAgICAgICAgZGVzZW5zaXRpemVDbGlja0FyZWEoKTtcbiAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgLnRleHQoZG90W2ZlYXR1cmVDb2x1bW5dKVxuICAgICAgICAgICAuYXR0cihcInhcIiwgKGQzLmV2ZW50LnBhZ2VYIC0gNTApKVxuICAgICAgICAgICAuYXR0cihcInlcIiwgKGQzLmV2ZW50LnBhZ2VZIC0gMzUpKVxuICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgbW91c2VvdmVyQ2FsbGJhY2soY2F0ZWdvcnlTZWFyY2hEYXRhKSlcbiAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgbW91c2VvdXRDYWxsYmFjaylcbiAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgY2xpY2tDYWxsYmFjaylcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbGV0IGRyYXdEb3RzID0gKGRvdHMsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICBsZXQgZmlsbCA9IChkb3QpID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDInKS5jaGVja2VkKSByZXR1cm4gY29sb3IoY1ZhbHVlMihkb3QpKTtcbiAgICAgIHJldHVybiBjb2xvcihjVmFsdWUoZG90KSk7XG4gICAgfTtcbiAgICBsZXQgb3BhY2l0eSA9IChkb3QpID0+IHtcbiAgICAgIHJldHVybiB0cmFuc3Bhcihkb3QsIHZhbFRyYW5zcCwgdHJhbnNwYXJlbnRDb2x1bW4sIHZhbE9wYWNpdHlNYXRjaCwgdmFsT3BhY2l0eU5vTWF0Y2gpXG4gICAgfTtcbiAgICAvLyBjb25zaXN0ZW50IGF0dHJpYnV0ZXNcbiAgICBkb3RzLmF0dHIoJ2NsYXNzJywgJ2RvdCcpXG4gICAgICAgIC5hdHRyKFwiY3hcIiwgeE1hcClcbiAgICAgICAgLmF0dHIoXCJjeVwiLCB5TWFwKVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgbW91c2VvdmVyQ2FsbGJhY2soY2F0ZWdvcnlTZWFyY2hEYXRhKSlcbiAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgbW91c2VvdXRDYWxsYmFjaylcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgY2xpY2tDYWxsYmFjaygpKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmaWxsKVxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBvcGFjaXR5KVxuXG4gICAgLy8gY3VzdG9taXplZCBhdHRyaWJ1dGVzXG4gICAgZG90cy5hdHRyKCdyJywgYXR0cmlidXRlc1sncmFkaXVzU2l6ZSddKSAvL3JhZGl1cyBzaXplXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgYXR0cmlidXRlc1snYm9yZGVyQ29sb3InXSkgLy8gYm9yZGVyIGNvbG9yXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgYXR0cmlidXRlc1snYm9yZGVyV2lkdGgnXSlcbiAgfTtcblxuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgLy8gRG90IEF0dHJpYnV0ZXNcbiAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIGxldCB1bm1hdGNoZWREb3RzQXR0cmlidXRlcyA9IHtcbiAgICByYWRpdXNTaXplOiAzLFxuICAgIGJvcmRlckNvbG9yOiAnIzAwMCcsXG4gICAgYm9yZGVyV2lkdGg6IDEsXG4gIH07XG5cbiAgbGV0IG1hdGNoZWREb3RzQXR0cmlidXRlcyA9IHtcbiAgICByYWRpdXNTaXplOiA3LFxuICAgIGJvcmRlckNvbG9yOiAneWVsbG93JyxcbiAgICBib3JkZXJXaWR0aDogMlxuICB9O1xuXG4gIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAvLyBEcmF3IEZ1bmN0aW9uc1xuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgLy8gZG90cyB0aGF0IHdlcmUgbm90IGEgbWF0Y2ggZm9yIHNlYXJjaCBwYXJhbWV0ZXJzIChjb25zaWRlciBmdW5jdGlvbiByZW5hbWU/KVxuICB0aGlzLmRyYXdVbm1hdGNoZWREb3RzID0gKCkgPT4ge1xuICAgIGxldCB1bm1hdGNoZWREb3RzID0gdGhpcy5wb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih0aGlzLm1hdGNoZWREb3RzKGNhdGVnb3J5U2VhcmNoLCB2YWxTZWFyY2gsIGZhbHNlKSk7XG4gICAgZHJhd0RvdHModW5tYXRjaGVkRG90cywgdW5tYXRjaGVkRG90c0F0dHJpYnV0ZXMpO1xuICB9O1xuXG4gIHRoaXMuZHJhd01hdGNoZWREb3RzID0gKCkgPT4ge1xuICAgIGxldCBtYXRjaGVkRG90cyA9IHRoaXMucG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIodGhpcy5tYXRjaGVkRG90cyhjYXRlZ29yeVNlYXJjaCwgdmFsU2VhcmNoLCB0cnVlKSk7XG4gICBkcmF3RG90cyhtYXRjaGVkRG90cywgbWF0Y2hlZERvdHNBdHRyaWJ1dGVzKTtcbiAgfTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/modules/dots_artist.js\n");

/***/ }),

/***/ "./src/modules/dropdown_builder.js":
/*!*****************************************!*\
  !*** ./src/modules/dropdown_builder.js ***!
  \*****************************************/
/*! exports provided: DropdownBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DropdownBuilder\", function() { return DropdownBuilder; });\nfunction DropdownBuilder() {\n  let createDowndownMenu = (nameAttribute, containerClass, dropdownClass) => {\n    return d3.select(\"body\")\n             .select(`div.${containerClass}`)\n             .append(\"select\")\n             .attr(\"name\", nameAttribute)\n             .attr('class', dropdownClass);\n  }\n\n  let populateDropdownOptions = (dropdown, data) => {\n    return dropdown.selectAll('option')\n                   .data(data)\n                   .enter()\n                   .append('option')\n                   .text((featureName) => (featureName));\n  };\n  let createAllDropdowns = () => {\n    this.clickOnFeatureDropdown = createDowndownMenu(\n      'color_column',\n      'click-on-feature-container',\n      'click-on-feature'\n    );\n    this.coloringDropdown = createDowndownMenu(\n      'color_column',\n      'color-by-feature-container',\n      'color-by-feature'\n    );\n    this.searchDropdown = createDowndownMenu(\n      'color_column',\n      'search-by-feature-container',\n      'search-by-feature'\n    );\n    this.shapingDropdown = createDowndownMenu(\n      'color_column',\n      'shape-by-feature-container',\n      'shape-by-feature'\n    );\n    this.transparentDropdown = createDowndownMenu(\n      'color_column',\n      'transparency-by-feature-dropdown-container',\n      'transparency-by-feature'\n    );\n  };\n  this.build = (categorySearchData, categoriesCopyColor, categories) => {\n    createAllDropdowns();\n    // Searching\n    populateDropdownOptions(this.searchDropdown, categorySearchData)\n    // Coloring\n    populateDropdownOptions(this.coloringDropdown, categoriesCopyColor)\n    // Transparent\n    populateDropdownOptions(this.transparentDropdown, categorySearchData)\n    // Click on feature\n    populateDropdownOptions(this.clickOnFeatureDropdown, categorySearchData)\n    // Shaping\n    populateDropdownOptions(this.shapingDropdown, categories)\n  };\n  this.setDropdownEventHandlers = (plotting, plotting2, plotting3, plotting4, plotting5) => {\n    this.coloringDropdown.on(\"change\", plotting);\n\n    // Searching\n    this.searchDropdown.on(\"change\", plotting2);\n\n    // Transparent\n    this.transparentDropdown.on(\"change\", plotting3);\n\n    // Click on feature\n    this.clickOnFeatureDropdown.on(\"change\", plotting4);\n\n    // Shaping\n    this.shapingDropdown.on(\"change\", plotting5);\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9kcm9wZG93bl9idWlsZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvZHJvcGRvd25fYnVpbGRlci5qcz8xYmVkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBEcm9wZG93bkJ1aWxkZXIoKSB7XG4gIGxldCBjcmVhdGVEb3duZG93bk1lbnUgPSAobmFtZUF0dHJpYnV0ZSwgY29udGFpbmVyQ2xhc3MsIGRyb3Bkb3duQ2xhc3MpID0+IHtcbiAgICByZXR1cm4gZDMuc2VsZWN0KFwiYm9keVwiKVxuICAgICAgICAgICAgIC5zZWxlY3QoYGRpdi4ke2NvbnRhaW5lckNsYXNzfWApXG4gICAgICAgICAgICAgLmFwcGVuZChcInNlbGVjdFwiKVxuICAgICAgICAgICAgIC5hdHRyKFwibmFtZVwiLCBuYW1lQXR0cmlidXRlKVxuICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGRyb3Bkb3duQ2xhc3MpO1xuICB9XG5cbiAgbGV0IHBvcHVsYXRlRHJvcGRvd25PcHRpb25zID0gKGRyb3Bkb3duLCBkYXRhKSA9PiB7XG4gICAgcmV0dXJuIGRyb3Bkb3duLnNlbGVjdEFsbCgnb3B0aW9uJylcbiAgICAgICAgICAgICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnb3B0aW9uJylcbiAgICAgICAgICAgICAgICAgICAudGV4dCgoZmVhdHVyZU5hbWUpID0+IChmZWF0dXJlTmFtZSkpO1xuICB9O1xuICBsZXQgY3JlYXRlQWxsRHJvcGRvd25zID0gKCkgPT4ge1xuICAgIHRoaXMuY2xpY2tPbkZlYXR1cmVEcm9wZG93biA9IGNyZWF0ZURvd25kb3duTWVudShcbiAgICAgICdjb2xvcl9jb2x1bW4nLFxuICAgICAgJ2NsaWNrLW9uLWZlYXR1cmUtY29udGFpbmVyJyxcbiAgICAgICdjbGljay1vbi1mZWF0dXJlJ1xuICAgICk7XG4gICAgdGhpcy5jb2xvcmluZ0Ryb3Bkb3duID0gY3JlYXRlRG93bmRvd25NZW51KFxuICAgICAgJ2NvbG9yX2NvbHVtbicsXG4gICAgICAnY29sb3ItYnktZmVhdHVyZS1jb250YWluZXInLFxuICAgICAgJ2NvbG9yLWJ5LWZlYXR1cmUnXG4gICAgKTtcbiAgICB0aGlzLnNlYXJjaERyb3Bkb3duID0gY3JlYXRlRG93bmRvd25NZW51KFxuICAgICAgJ2NvbG9yX2NvbHVtbicsXG4gICAgICAnc2VhcmNoLWJ5LWZlYXR1cmUtY29udGFpbmVyJyxcbiAgICAgICdzZWFyY2gtYnktZmVhdHVyZSdcbiAgICApO1xuICAgIHRoaXMuc2hhcGluZ0Ryb3Bkb3duID0gY3JlYXRlRG93bmRvd25NZW51KFxuICAgICAgJ2NvbG9yX2NvbHVtbicsXG4gICAgICAnc2hhcGUtYnktZmVhdHVyZS1jb250YWluZXInLFxuICAgICAgJ3NoYXBlLWJ5LWZlYXR1cmUnXG4gICAgKTtcbiAgICB0aGlzLnRyYW5zcGFyZW50RHJvcGRvd24gPSBjcmVhdGVEb3duZG93bk1lbnUoXG4gICAgICAnY29sb3JfY29sdW1uJyxcbiAgICAgICd0cmFuc3BhcmVuY3ktYnktZmVhdHVyZS1kcm9wZG93bi1jb250YWluZXInLFxuICAgICAgJ3RyYW5zcGFyZW5jeS1ieS1mZWF0dXJlJ1xuICAgICk7XG4gIH07XG4gIHRoaXMuYnVpbGQgPSAoY2F0ZWdvcnlTZWFyY2hEYXRhLCBjYXRlZ29yaWVzQ29weUNvbG9yLCBjYXRlZ29yaWVzKSA9PiB7XG4gICAgY3JlYXRlQWxsRHJvcGRvd25zKCk7XG4gICAgLy8gU2VhcmNoaW5nXG4gICAgcG9wdWxhdGVEcm9wZG93bk9wdGlvbnModGhpcy5zZWFyY2hEcm9wZG93biwgY2F0ZWdvcnlTZWFyY2hEYXRhKVxuICAgIC8vIENvbG9yaW5nXG4gICAgcG9wdWxhdGVEcm9wZG93bk9wdGlvbnModGhpcy5jb2xvcmluZ0Ryb3Bkb3duLCBjYXRlZ29yaWVzQ29weUNvbG9yKVxuICAgIC8vIFRyYW5zcGFyZW50XG4gICAgcG9wdWxhdGVEcm9wZG93bk9wdGlvbnModGhpcy50cmFuc3BhcmVudERyb3Bkb3duLCBjYXRlZ29yeVNlYXJjaERhdGEpXG4gICAgLy8gQ2xpY2sgb24gZmVhdHVyZVxuICAgIHBvcHVsYXRlRHJvcGRvd25PcHRpb25zKHRoaXMuY2xpY2tPbkZlYXR1cmVEcm9wZG93biwgY2F0ZWdvcnlTZWFyY2hEYXRhKVxuICAgIC8vIFNoYXBpbmdcbiAgICBwb3B1bGF0ZURyb3Bkb3duT3B0aW9ucyh0aGlzLnNoYXBpbmdEcm9wZG93biwgY2F0ZWdvcmllcylcbiAgfTtcbiAgdGhpcy5zZXREcm9wZG93bkV2ZW50SGFuZGxlcnMgPSAocGxvdHRpbmcsIHBsb3R0aW5nMiwgcGxvdHRpbmczLCBwbG90dGluZzQsIHBsb3R0aW5nNSkgPT4ge1xuICAgIHRoaXMuY29sb3JpbmdEcm9wZG93bi5vbihcImNoYW5nZVwiLCBwbG90dGluZyk7XG5cbiAgICAvLyBTZWFyY2hpbmdcbiAgICB0aGlzLnNlYXJjaERyb3Bkb3duLm9uKFwiY2hhbmdlXCIsIHBsb3R0aW5nMik7XG5cbiAgICAvLyBUcmFuc3BhcmVudFxuICAgIHRoaXMudHJhbnNwYXJlbnREcm9wZG93bi5vbihcImNoYW5nZVwiLCBwbG90dGluZzMpO1xuXG4gICAgLy8gQ2xpY2sgb24gZmVhdHVyZVxuICAgIHRoaXMuY2xpY2tPbkZlYXR1cmVEcm9wZG93bi5vbihcImNoYW5nZVwiLCBwbG90dGluZzQpO1xuXG4gICAgLy8gU2hhcGluZ1xuICAgIHRoaXMuc2hhcGluZ0Ryb3Bkb3duLm9uKFwiY2hhbmdlXCIsIHBsb3R0aW5nNSk7XG4gIH07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/dropdown_builder.js\n");

/***/ }),

/***/ "./src/modules/svg_initializer.js":
/*!****************************************!*\
  !*** ./src/modules/svg_initializer.js ***!
  \****************************************/
/*! exports provided: SvgInitializer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SvgInitializer\", function() { return SvgInitializer; });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/modules/constants.js\");\n/* harmony import */ var _table_creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./table_creator.js */ \"./src/modules/table_creator.js\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utilities */ \"./src/modules/utilities.js\");\n\n\n\n\n\nfunction LassoInitializer(svg, color, color_column, x_max, x_min, y_max, y_min, allXValues, allYValues, categories, dict1, columns) {\n  this.svg = svg;\n\n  // *************************************\n  // UTILITY FUNCTIONS\n  // *************************************\n\n  let removeTable = () => {\n    d3.select(\"table\").remove();\n    document.getElementById(\"demo3\").innerHTML = \"\";\n  };\n\n  // *************************************\n  // LASSO AREA AND CALLBACKS\n  // *************************************\n\n  let createLassoArea = () => {\n    return this.svg.append(\"rect\")\n                   .attr(\"width\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"])\n                   .attr(\"height\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"])\n                   .style(\"opacity\", 0);\n  };\n\n  let lassoStart = () => {\n    removeTable();\n    this.lasso.items()\n         .attr(\"r\", 3.5) // reset size\n         .style(\"fill\", null) // clear all of the fills (greys out)\n         .classed({ \"not_possible\": true, \"selected\": false }); // style as not possible\n  };\n\n  let lassoDraw = () => {\n    // Style the possible dots\n    this.lasso.items()\n         .filter((d) => (d.possible === true))\n         .classed({ \"not_possible\": false, \"possible\": true });\n\n    // Style the not possible dot\n    this.lasso.items()\n         .filter((d) => (d.possible===false))\n         .classed({ \"not_possible\": true, \"possible\": false })\n         .style(\"stroke\", \"#000\");\n  };\n\n  let lassoEnd = () => {\n    // Reset the color of all dots\n    this.lasso.items()\n              .style(\"fill\", (dot) => (color(dot[color_column])));\n\n    // Style the selected dots\n    this.lasso.items()\n              .filter((dot) => ( dot.selected === true ))\n              .classed({ \"not_possible\": false, \"possible\": false })\n              .attr(\"r\", 6.5);\n\n    // Reset the style of the not selected dots (we made them 0.5 smaller)\n    this.lasso.items()\n              .filter((dot) => ( dot.selected === false ))\n              .classed({ \"not_possible\": false, \"possible\": false })\n              .attr(\"r\", 3)\n              .style(\"stroke\", \"#000\");\n\n    // ********************************************************************\n    // The following code draws the side table using the selection data\n    // ********************************************************************\n    // AJF annotation\n    // The data that we have is multi-dimensional, with X and Y values only two\n    // dimensions of the total available per datum.\n    // The dimensions that we want to expose/categorize in the side table are\n    // those that are not directly plottable on the X-Y axes.\n    // This algorithm will:\n    // 1) extract the explicit X/Y coordinate values from the selection\n    //  a) adjust/scale the x/y values (reason tbd still)\n    // 2) find the corresponding points from all the data plotted (all data is sorted)\n    // 3) extract the additional dimension data from the corresponding points in all data plotted\n    // 4) create an array containing the feature data from the selection and the corresponding index in\n    //    all data\n    // 5) pass selected data array with additional dimensions to tabulation function to build\n    //    side table\n    // When possible, see whether it's possible to get algorithm to run under O(n^2)\n\n    // get values for table -> array inside a list\n    let selectedDots = this.lasso.items()\n                                 .filter((dot) => (dot.selected === true))[0];\n    // adjust the x and y values\n    let selectedXValues = [];\n    let selectedYValues = [];\n    for (let i=0; i < selectedDots.length; i++) {\n      // From the spec: https://www.w3.org/TR/SVGTiny12/svgudom.html#svg__SVGLocatable_getBBox\n      // SVGLocatable.getBBox()\n      // Returns a DOMRect representing the computed bounding box of the current element.\n      selectedXValues.push(\n        (((selectedDots[i].getBBox().x + 6.5) * (x_max - x_min)) / _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"]) + x_min\n      );\n      selectedYValues.push(\n        ((selectedDots[i].getBBox().y + 6.5) * (y_min - y_max)) / _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"] + y_max\n      );\n    };\n    var selected_data=[], selected_data_indices=[];\n\n    // Compare every selected point to all points (tempX)\n    // in order to match coordinates with actual data\n    for (let ii=0; ii < selectedXValues.length; ii++) {\n      console.log(\"lasso_end gathering selected data\");\n      console.log(allXValues.length);\n      for (let jj=0; jj < allXValues.length; jj++) {\n        selectedXValues[ii] = +(selectedXValues[ii].toFixed(3)); // coerce String to Int\n        selectedYValues[ii] = +(selectedYValues[ii].toFixed(5)); // coerce String to Int\n        // find which data point in the selection corresponds to the data in allData (index jj)\n        if ( (selectedXValues[ii] === +(allXValues[jj].toFixed(3))) && (selectedYValues[ii] === +(allYValues[jj].toFixed(5))) ) {\n          let all_values = {};\n          // set the value\n          for (var k=1;k<categories.length;k++) {\n            all_values[categories[k]] = (dict1[categories[k]][jj]);\n          }\n          if(Object(_utilities__WEBPACK_IMPORTED_MODULE_2__[\"searchDic\"])(selected_data,all_values)==true){\n            selected_data.push(all_values);\n            selected_data_indices.push(jj);\n            break;\n          }\n        }\n      }\n    }\n\n    // render the table for the points selected by lasso\n    if (selected_data.length > 0) {\n      console.log(\"Rendering table...\");\n      console.log(selected_data);\n      console.log(columns);\n      console.log(selectedXValues);\n      Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"tabulate\"])(selected_data, columns, selectedXValues);\n      if (_utilities__WEBPACK_IMPORTED_MODULE_2__[\"queryParams\"].get('semantic_model') === \"true\") {\n        console.log(\"Predicting words...\");\n        Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"classify\"])(selected_data_indices, vectorspace_2darray, weights_2darray, biases_1darray, vocab_1darray);\n        Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"benchmark\"])(selected_data_indices, bow_2darray, vocab_1darray);\n      }\n    }\n  };\n\n  this.lasso = d3.lasso()\n        .closePathDistance(75) // max distance for the lasso loop to be closed\n        .closePathSelect(true) // can items be selected by closing the path?\n        .hoverSelect(true) // can items by selected by hovering over them?\n        .area(createLassoArea()) // area where the lasso can be started\n        .on(\"start\", lassoStart) // lasso start function\n        .on(\"draw\", lassoDraw) // lasso draw function\n        .on(\"end\", lassoEnd); // lasso end function\n\n  this.initialize = () => {\n    return this.lasso;\n  }\n}\n\nfunction SvgInitializer (color, color_column, x_max, x_min, y_max, y_min, allXValues, allYValues, categories, dict1, columns) {\n  this.svg = d3.select(\"body\")\n               .select('div.plot-container')\n               .append(\"svg\")\n               .attr(\"width\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"] + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].left + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].right)\n               .attr(\"height\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"] + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].top + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].bottom)\n               .append(\"g\")\n               .attr(\"transform\",`translate(${_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].left}, ${_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].top})`);\n\n  this.lasso = new LassoInitializer(this.svg, color, color_column, x_max, x_min, y_max, y_min, allXValues, allYValues, categories, dict1, columns).initialize();\n  this.initializeWithLasso = () => {\n    // Init the lasso object on the svg:g that contains the dots\n    this.svg.call(this.lasso);\n    return this.svg;\n  };\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9zdmdfaW5pdGlhbGl6ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9zdmdfaW5pdGlhbGl6ZXIuanM/MmMyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoZWlnaHQsIG1hcmdpbiwgd2lkdGggfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBjbGFzc2lmeSwgYmVuY2htYXJrLCB0YWJ1bGF0ZSB9IGZyb20gJy4vdGFibGVfY3JlYXRvci5qcyc7XG5pbXBvcnQgeyBzZWFyY2hEaWMsIHF1ZXJ5UGFyYW1zIH0gZnJvbSAnLi91dGlsaXRpZXMnO1xuXG5cbmZ1bmN0aW9uIExhc3NvSW5pdGlhbGl6ZXIoc3ZnLCBjb2xvciwgY29sb3JfY29sdW1uLCB4X21heCwgeF9taW4sIHlfbWF4LCB5X21pbiwgYWxsWFZhbHVlcywgYWxsWVZhbHVlcywgY2F0ZWdvcmllcywgZGljdDEsIGNvbHVtbnMpIHtcbiAgdGhpcy5zdmcgPSBzdmc7XG5cbiAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAvLyBVVElMSVRZIEZVTkNUSU9OU1xuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgbGV0IHJlbW92ZVRhYmxlID0gKCkgPT4ge1xuICAgIGQzLnNlbGVjdChcInRhYmxlXCIpLnJlbW92ZSgpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVtbzNcIikuaW5uZXJIVE1MID0gXCJcIjtcbiAgfTtcblxuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIExBU1NPIEFSRUEgQU5EIENBTExCQUNLU1xuICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgbGV0IGNyZWF0ZUxhc3NvQXJlYSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdmcuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gIH07XG5cbiAgbGV0IGxhc3NvU3RhcnQgPSAoKSA9PiB7XG4gICAgcmVtb3ZlVGFibGUoKTtcbiAgICB0aGlzLmxhc3NvLml0ZW1zKClcbiAgICAgICAgIC5hdHRyKFwiclwiLCAzLjUpIC8vIHJlc2V0IHNpemVcbiAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgbnVsbCkgLy8gY2xlYXIgYWxsIG9mIHRoZSBmaWxscyAoZ3JleXMgb3V0KVxuICAgICAgICAgLmNsYXNzZWQoeyBcIm5vdF9wb3NzaWJsZVwiOiB0cnVlLCBcInNlbGVjdGVkXCI6IGZhbHNlIH0pOyAvLyBzdHlsZSBhcyBub3QgcG9zc2libGVcbiAgfTtcblxuICBsZXQgbGFzc29EcmF3ID0gKCkgPT4ge1xuICAgIC8vIFN0eWxlIHRoZSBwb3NzaWJsZSBkb3RzXG4gICAgdGhpcy5sYXNzby5pdGVtcygpXG4gICAgICAgICAuZmlsdGVyKChkKSA9PiAoZC5wb3NzaWJsZSA9PT0gdHJ1ZSkpXG4gICAgICAgICAuY2xhc3NlZCh7IFwibm90X3Bvc3NpYmxlXCI6IGZhbHNlLCBcInBvc3NpYmxlXCI6IHRydWUgfSk7XG5cbiAgICAvLyBTdHlsZSB0aGUgbm90IHBvc3NpYmxlIGRvdFxuICAgIHRoaXMubGFzc28uaXRlbXMoKVxuICAgICAgICAgLmZpbHRlcigoZCkgPT4gKGQucG9zc2libGU9PT1mYWxzZSkpXG4gICAgICAgICAuY2xhc3NlZCh7IFwibm90X3Bvc3NpYmxlXCI6IHRydWUsIFwicG9zc2libGVcIjogZmFsc2UgfSlcbiAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwMDBcIik7XG4gIH07XG5cbiAgbGV0IGxhc3NvRW5kID0gKCkgPT4ge1xuICAgIC8vIFJlc2V0IHRoZSBjb2xvciBvZiBhbGwgZG90c1xuICAgIHRoaXMubGFzc28uaXRlbXMoKVxuICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIChkb3QpID0+IChjb2xvcihkb3RbY29sb3JfY29sdW1uXSkpKTtcblxuICAgIC8vIFN0eWxlIHRoZSBzZWxlY3RlZCBkb3RzXG4gICAgdGhpcy5sYXNzby5pdGVtcygpXG4gICAgICAgICAgICAgIC5maWx0ZXIoKGRvdCkgPT4gKCBkb3Quc2VsZWN0ZWQgPT09IHRydWUgKSlcbiAgICAgICAgICAgICAgLmNsYXNzZWQoeyBcIm5vdF9wb3NzaWJsZVwiOiBmYWxzZSwgXCJwb3NzaWJsZVwiOiBmYWxzZSB9KVxuICAgICAgICAgICAgICAuYXR0cihcInJcIiwgNi41KTtcblxuICAgIC8vIFJlc2V0IHRoZSBzdHlsZSBvZiB0aGUgbm90IHNlbGVjdGVkIGRvdHMgKHdlIG1hZGUgdGhlbSAwLjUgc21hbGxlcilcbiAgICB0aGlzLmxhc3NvLml0ZW1zKClcbiAgICAgICAgICAgICAgLmZpbHRlcigoZG90KSA9PiAoIGRvdC5zZWxlY3RlZCA9PT0gZmFsc2UgKSlcbiAgICAgICAgICAgICAgLmNsYXNzZWQoeyBcIm5vdF9wb3NzaWJsZVwiOiBmYWxzZSwgXCJwb3NzaWJsZVwiOiBmYWxzZSB9KVxuICAgICAgICAgICAgICAuYXR0cihcInJcIiwgMylcbiAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzAwMFwiKTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGRyYXdzIHRoZSBzaWRlIHRhYmxlIHVzaW5nIHRoZSBzZWxlY3Rpb24gZGF0YVxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gQUpGIGFubm90YXRpb25cbiAgICAvLyBUaGUgZGF0YSB0aGF0IHdlIGhhdmUgaXMgbXVsdGktZGltZW5zaW9uYWwsIHdpdGggWCBhbmQgWSB2YWx1ZXMgb25seSB0d29cbiAgICAvLyBkaW1lbnNpb25zIG9mIHRoZSB0b3RhbCBhdmFpbGFibGUgcGVyIGRhdHVtLlxuICAgIC8vIFRoZSBkaW1lbnNpb25zIHRoYXQgd2Ugd2FudCB0byBleHBvc2UvY2F0ZWdvcml6ZSBpbiB0aGUgc2lkZSB0YWJsZSBhcmVcbiAgICAvLyB0aG9zZSB0aGF0IGFyZSBub3QgZGlyZWN0bHkgcGxvdHRhYmxlIG9uIHRoZSBYLVkgYXhlcy5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSB3aWxsOlxuICAgIC8vIDEpIGV4dHJhY3QgdGhlIGV4cGxpY2l0IFgvWSBjb29yZGluYXRlIHZhbHVlcyBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgICAvLyAgYSkgYWRqdXN0L3NjYWxlIHRoZSB4L3kgdmFsdWVzIChyZWFzb24gdGJkIHN0aWxsKVxuICAgIC8vIDIpIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnRzIGZyb20gYWxsIHRoZSBkYXRhIHBsb3R0ZWQgKGFsbCBkYXRhIGlzIHNvcnRlZClcbiAgICAvLyAzKSBleHRyYWN0IHRoZSBhZGRpdGlvbmFsIGRpbWVuc2lvbiBkYXRhIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnRzIGluIGFsbCBkYXRhIHBsb3R0ZWRcbiAgICAvLyA0KSBjcmVhdGUgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgZmVhdHVyZSBkYXRhIGZyb20gdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgaW5kZXggaW5cbiAgICAvLyAgICBhbGwgZGF0YVxuICAgIC8vIDUpIHBhc3Mgc2VsZWN0ZWQgZGF0YSBhcnJheSB3aXRoIGFkZGl0aW9uYWwgZGltZW5zaW9ucyB0byB0YWJ1bGF0aW9uIGZ1bmN0aW9uIHRvIGJ1aWxkXG4gICAgLy8gICAgc2lkZSB0YWJsZVxuICAgIC8vIFdoZW4gcG9zc2libGUsIHNlZSB3aGV0aGVyIGl0J3MgcG9zc2libGUgdG8gZ2V0IGFsZ29yaXRobSB0byBydW4gdW5kZXIgTyhuXjIpXG5cbiAgICAvLyBnZXQgdmFsdWVzIGZvciB0YWJsZSAtPiBhcnJheSBpbnNpZGUgYSBsaXN0XG4gICAgbGV0IHNlbGVjdGVkRG90cyA9IHRoaXMubGFzc28uaXRlbXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZG90KSA9PiAoZG90LnNlbGVjdGVkID09PSB0cnVlKSlbMF07XG4gICAgLy8gYWRqdXN0IHRoZSB4IGFuZCB5IHZhbHVlc1xuICAgIGxldCBzZWxlY3RlZFhWYWx1ZXMgPSBbXTtcbiAgICBsZXQgc2VsZWN0ZWRZVmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgc2VsZWN0ZWREb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBGcm9tIHRoZSBzcGVjOiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHVGlueTEyL3N2Z3Vkb20uaHRtbCNzdmdfX1NWR0xvY2F0YWJsZV9nZXRCQm94XG4gICAgICAvLyBTVkdMb2NhdGFibGUuZ2V0QkJveCgpXG4gICAgICAvLyBSZXR1cm5zIGEgRE9NUmVjdCByZXByZXNlbnRpbmcgdGhlIGNvbXB1dGVkIGJvdW5kaW5nIGJveCBvZiB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgc2VsZWN0ZWRYVmFsdWVzLnB1c2goXG4gICAgICAgICgoKHNlbGVjdGVkRG90c1tpXS5nZXRCQm94KCkueCArIDYuNSkgKiAoeF9tYXggLSB4X21pbikpIC8gd2lkdGgpICsgeF9taW5cbiAgICAgICk7XG4gICAgICBzZWxlY3RlZFlWYWx1ZXMucHVzaChcbiAgICAgICAgKChzZWxlY3RlZERvdHNbaV0uZ2V0QkJveCgpLnkgKyA2LjUpICogKHlfbWluIC0geV9tYXgpKSAvIGhlaWdodCArIHlfbWF4XG4gICAgICApO1xuICAgIH07XG4gICAgdmFyIHNlbGVjdGVkX2RhdGE9W10sIHNlbGVjdGVkX2RhdGFfaW5kaWNlcz1bXTtcblxuICAgIC8vIENvbXBhcmUgZXZlcnkgc2VsZWN0ZWQgcG9pbnQgdG8gYWxsIHBvaW50cyAodGVtcFgpXG4gICAgLy8gaW4gb3JkZXIgdG8gbWF0Y2ggY29vcmRpbmF0ZXMgd2l0aCBhY3R1YWwgZGF0YVxuICAgIGZvciAobGV0IGlpPTA7IGlpIDwgc2VsZWN0ZWRYVmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgY29uc29sZS5sb2coXCJsYXNzb19lbmQgZ2F0aGVyaW5nIHNlbGVjdGVkIGRhdGFcIik7XG4gICAgICBjb25zb2xlLmxvZyhhbGxYVmFsdWVzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBqaj0wOyBqaiA8IGFsbFhWYWx1ZXMubGVuZ3RoOyBqaisrKSB7XG4gICAgICAgIHNlbGVjdGVkWFZhbHVlc1tpaV0gPSArKHNlbGVjdGVkWFZhbHVlc1tpaV0udG9GaXhlZCgzKSk7IC8vIGNvZXJjZSBTdHJpbmcgdG8gSW50XG4gICAgICAgIHNlbGVjdGVkWVZhbHVlc1tpaV0gPSArKHNlbGVjdGVkWVZhbHVlc1tpaV0udG9GaXhlZCg1KSk7IC8vIGNvZXJjZSBTdHJpbmcgdG8gSW50XG4gICAgICAgIC8vIGZpbmQgd2hpY2ggZGF0YSBwb2ludCBpbiB0aGUgc2VsZWN0aW9uIGNvcnJlc3BvbmRzIHRvIHRoZSBkYXRhIGluIGFsbERhdGEgKGluZGV4IGpqKVxuICAgICAgICBpZiAoIChzZWxlY3RlZFhWYWx1ZXNbaWldID09PSArKGFsbFhWYWx1ZXNbampdLnRvRml4ZWQoMykpKSAmJiAoc2VsZWN0ZWRZVmFsdWVzW2lpXSA9PT0gKyhhbGxZVmFsdWVzW2pqXS50b0ZpeGVkKDUpKSkgKSB7XG4gICAgICAgICAgbGV0IGFsbF92YWx1ZXMgPSB7fTtcbiAgICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgICAgZm9yICh2YXIgaz0xO2s8Y2F0ZWdvcmllcy5sZW5ndGg7aysrKSB7XG4gICAgICAgICAgICBhbGxfdmFsdWVzW2NhdGVnb3JpZXNba11dID0gKGRpY3QxW2NhdGVnb3JpZXNba11dW2pqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHNlYXJjaERpYyhzZWxlY3RlZF9kYXRhLGFsbF92YWx1ZXMpPT10cnVlKXtcbiAgICAgICAgICAgIHNlbGVjdGVkX2RhdGEucHVzaChhbGxfdmFsdWVzKTtcbiAgICAgICAgICAgIHNlbGVjdGVkX2RhdGFfaW5kaWNlcy5wdXNoKGpqKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbmRlciB0aGUgdGFibGUgZm9yIHRoZSBwb2ludHMgc2VsZWN0ZWQgYnkgbGFzc29cbiAgICBpZiAoc2VsZWN0ZWRfZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlbmRlcmluZyB0YWJsZS4uLlwiKTtcbiAgICAgIGNvbnNvbGUubG9nKHNlbGVjdGVkX2RhdGEpO1xuICAgICAgY29uc29sZS5sb2coY29sdW1ucyk7XG4gICAgICBjb25zb2xlLmxvZyhzZWxlY3RlZFhWYWx1ZXMpO1xuICAgICAgdGFidWxhdGUoc2VsZWN0ZWRfZGF0YSwgY29sdW1ucywgc2VsZWN0ZWRYVmFsdWVzKTtcbiAgICAgIGlmIChxdWVyeVBhcmFtcy5nZXQoJ3NlbWFudGljX21vZGVsJykgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJlZGljdGluZyB3b3Jkcy4uLlwiKTtcbiAgICAgICAgY2xhc3NpZnkoc2VsZWN0ZWRfZGF0YV9pbmRpY2VzLCB2ZWN0b3JzcGFjZV8yZGFycmF5LCB3ZWlnaHRzXzJkYXJyYXksIGJpYXNlc18xZGFycmF5LCB2b2NhYl8xZGFycmF5KTtcbiAgICAgICAgYmVuY2htYXJrKHNlbGVjdGVkX2RhdGFfaW5kaWNlcywgYm93XzJkYXJyYXksIHZvY2FiXzFkYXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0aGlzLmxhc3NvID0gZDMubGFzc28oKVxuICAgICAgICAuY2xvc2VQYXRoRGlzdGFuY2UoNzUpIC8vIG1heCBkaXN0YW5jZSBmb3IgdGhlIGxhc3NvIGxvb3AgdG8gYmUgY2xvc2VkXG4gICAgICAgIC5jbG9zZVBhdGhTZWxlY3QodHJ1ZSkgLy8gY2FuIGl0ZW1zIGJlIHNlbGVjdGVkIGJ5IGNsb3NpbmcgdGhlIHBhdGg/XG4gICAgICAgIC5ob3ZlclNlbGVjdCh0cnVlKSAvLyBjYW4gaXRlbXMgYnkgc2VsZWN0ZWQgYnkgaG92ZXJpbmcgb3ZlciB0aGVtP1xuICAgICAgICAuYXJlYShjcmVhdGVMYXNzb0FyZWEoKSkgLy8gYXJlYSB3aGVyZSB0aGUgbGFzc28gY2FuIGJlIHN0YXJ0ZWRcbiAgICAgICAgLm9uKFwic3RhcnRcIiwgbGFzc29TdGFydCkgLy8gbGFzc28gc3RhcnQgZnVuY3Rpb25cbiAgICAgICAgLm9uKFwiZHJhd1wiLCBsYXNzb0RyYXcpIC8vIGxhc3NvIGRyYXcgZnVuY3Rpb25cbiAgICAgICAgLm9uKFwiZW5kXCIsIGxhc3NvRW5kKTsgLy8gbGFzc28gZW5kIGZ1bmN0aW9uXG5cbiAgdGhpcy5pbml0aWFsaXplID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmxhc3NvO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTdmdJbml0aWFsaXplciAoY29sb3IsIGNvbG9yX2NvbHVtbiwgeF9tYXgsIHhfbWluLCB5X21heCwgeV9taW4sIGFsbFhWYWx1ZXMsIGFsbFlWYWx1ZXMsIGNhdGVnb3JpZXMsIGRpY3QxLCBjb2x1bW5zKSB7XG4gIHRoaXMuc3ZnID0gZDMuc2VsZWN0KFwiYm9keVwiKVxuICAgICAgICAgICAgICAgLnNlbGVjdCgnZGl2LnBsb3QtY29udGFpbmVyJylcbiAgICAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwgJHttYXJnaW4udG9wfSlgKTtcblxuICB0aGlzLmxhc3NvID0gbmV3IExhc3NvSW5pdGlhbGl6ZXIodGhpcy5zdmcsIGNvbG9yLCBjb2xvcl9jb2x1bW4sIHhfbWF4LCB4X21pbiwgeV9tYXgsIHlfbWluLCBhbGxYVmFsdWVzLCBhbGxZVmFsdWVzLCBjYXRlZ29yaWVzLCBkaWN0MSwgY29sdW1ucykuaW5pdGlhbGl6ZSgpO1xuICB0aGlzLmluaXRpYWxpemVXaXRoTGFzc28gPSAoKSA9PiB7XG4gICAgLy8gSW5pdCB0aGUgbGFzc28gb2JqZWN0IG9uIHRoZSBzdmc6ZyB0aGF0IGNvbnRhaW5zIHRoZSBkb3RzXG4gICAgdGhpcy5zdmcuY2FsbCh0aGlzLmxhc3NvKTtcbiAgICByZXR1cm4gdGhpcy5zdmc7XG4gIH07XG5cbn1cblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/svg_initializer.js\n");

/***/ }),

/***/ "./src/modules/table_creator.js":
/*!**************************************!*\
  !*** ./src/modules/table_creator.js ***!
  \**************************************/
/*! exports provided: classify, benchmark, tabulate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"classify\", function() { return classify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"benchmark\", function() { return benchmark; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tabulate\", function() { return tabulate; });\n// ****************************\n// Create Table functionality\n// ****************************\n\n// Utility function used for predicting words in semantic setting\n// Source: https://stackoverflow.com/a/11792230/7100714\nfunction findIndicesOfMax(inp, count) {\n  let outp = new Array();\n  for (let i = 0; i < inp.length; i++) {\n    outp.push(i);\n    if (outp.length > count) {\n      outp.sort((a, b) => (inp[b] - inp[a]));\n      outp.pop();\n    }\n  }\n  return outp;\n}\n\nfunction classify (indices, vs_source, weights_source, biases_source, vocab_source) {\n  let sum_vectors = vs_source[indices[0]];\n  for (i=1; i < indices.length; i++) {\n    sum_vectors = math.add(sum_vectors, vs_source[indices[i]]);\n  }\n  let avg_vector = sum_vectors.map((x) =>  ( x / indices.length ));\n  let mul = math.multiply(avg_vector, weights_source);\n  let add = math.add(mul, biases_source);\n  // get indices of 10 greatest elements\n  let topIndices = findIndicesOfMax(add, 10);\n  console.log(\"Top predicted vocab words:\");\n  let strbuilder = \"Predicted words:\";\n  for (i=0; i<10; i++) {\n    console.log((i+1) + \": \" + vocab_source[topIndices[i]]);\n    strbuilder += \" \" + vocab_source[topIndices[i]] + \",\";\n  }\n  document.getElementById(\"predicted_words\").innerHTML = strbuilder.slice(0, -1);\n};\n\nfunction benchmark (indices, bow_source, vocab_source) { // may need to adjust\n  var num_indices = indices.length;\n  var vocab_freq = bow_source[indices[0]];\n  for (i=1; i < num_indices; i++) {\n    vocab_freq = math.add(vocab_freq, bow_source[indices[i]]);\n  }\n  // get indices of 10 greatest elements\n  var topIndices = findIndicesOfMax(vocab_freq, 10);\n  console.log(\"Most frequent words:\");\n  var strbuilder = \"Most frequent words:\";\n  for (i=0; i<10; i++) {\n    console.log((i+1) + \": \" + vocab_source[topIndices[i]]);\n    strbuilder += \" \" + vocab_source[topIndices[i]] + \",\";\n  }\n  document.getElementById(\"frequent_words\").innerHTML = strbuilder.slice(0, -1);\n};\n\n// displays the summary in tabular form\nfunction tabulate (data_tab, columns) {\n  let table = d3.select(\"body\").select('div.plot-options-container').append(\"table\").attr(\"class\", \"select3\"),\n      thead = table.append(\"thead\"),\n      tbody = table.append(\"tbody\");\n\n  // append the header row\n  thead.append(\"tr\")\n       .selectAll(\"th\")\n       .data(columns)\n       .enter()\n       .append(\"th\")\n       .text((column) => (column ));\n\n  // create a row for each object in the data\n  let rows = tbody.selectAll(\"tr\")\n                  .data(data_tab)\n                  .enter()\n                  .append(\"tr\");\n\n  // create a cell in each row for each column\n  let cells = rows.selectAll(\"td\")\n                  .data((row) => {\n                    return columns.map((column) => {\n                      return {column: column, value: row[column]};\n                    });\n                  })\n                  .enter()\n                  .append(\"td\")\n                  .attr(\"style\", \"font-family: Courier\") // sets the font style\n                  .html((d) => ( d.value ) );\n\n  /*\n    crossfilter dimensions and group by\n    http://animateddata.co.uk/articles/crossfilter/\n  */\n  let output = \"\";\n  let cf = crossfilter(data_tab);\n  /* crossfilter currently only supports up to 32 columns) */\n  for (var i=0;i<columns.length && i<32;i++) {\n    let byParty = cf.dimension((party) => ( party[columns[i]] ));\n    output = output + \"<b>\" + columns[i] + \"</b>\" + \"<br>\";\n    var groupByParty = byParty.group();\n    groupByParty.top(5).forEach(function(p, i) {\n      output = output + p.key + \": \" + p.value + \"<br>\";\n      console.log(p.key + \": \" + p.value);\n    });\n    output = output + \"<br>\";\n  }\n  // side table\n  document.getElementById(\"demo3\").innerHTML = output;\n  return table;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy90YWJsZV9jcmVhdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvdGFibGVfY3JlYXRvci5qcz85ZTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIENyZWF0ZSBUYWJsZSBmdW5jdGlvbmFsaXR5XG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdXNlZCBmb3IgcHJlZGljdGluZyB3b3JkcyBpbiBzZW1hbnRpYyBzZXR0aW5nXG4vLyBTb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTc5MjIzMC83MTAwNzE0XG5mdW5jdGlvbiBmaW5kSW5kaWNlc09mTWF4KGlucCwgY291bnQpIHtcbiAgbGV0IG91dHAgPSBuZXcgQXJyYXkoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnAubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwLnB1c2goaSk7XG4gICAgaWYgKG91dHAubGVuZ3RoID4gY291bnQpIHtcbiAgICAgIG91dHAuc29ydCgoYSwgYikgPT4gKGlucFtiXSAtIGlucFthXSkpO1xuICAgICAgb3V0cC5wb3AoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc2lmeSAoaW5kaWNlcywgdnNfc291cmNlLCB3ZWlnaHRzX3NvdXJjZSwgYmlhc2VzX3NvdXJjZSwgdm9jYWJfc291cmNlKSB7XG4gIGxldCBzdW1fdmVjdG9ycyA9IHZzX3NvdXJjZVtpbmRpY2VzWzBdXTtcbiAgZm9yIChpPTE7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtX3ZlY3RvcnMgPSBtYXRoLmFkZChzdW1fdmVjdG9ycywgdnNfc291cmNlW2luZGljZXNbaV1dKTtcbiAgfVxuICBsZXQgYXZnX3ZlY3RvciA9IHN1bV92ZWN0b3JzLm1hcCgoeCkgPT4gICggeCAvIGluZGljZXMubGVuZ3RoICkpO1xuICBsZXQgbXVsID0gbWF0aC5tdWx0aXBseShhdmdfdmVjdG9yLCB3ZWlnaHRzX3NvdXJjZSk7XG4gIGxldCBhZGQgPSBtYXRoLmFkZChtdWwsIGJpYXNlc19zb3VyY2UpO1xuICAvLyBnZXQgaW5kaWNlcyBvZiAxMCBncmVhdGVzdCBlbGVtZW50c1xuICBsZXQgdG9wSW5kaWNlcyA9IGZpbmRJbmRpY2VzT2ZNYXgoYWRkLCAxMCk7XG4gIGNvbnNvbGUubG9nKFwiVG9wIHByZWRpY3RlZCB2b2NhYiB3b3JkczpcIik7XG4gIGxldCBzdHJidWlsZGVyID0gXCJQcmVkaWN0ZWQgd29yZHM6XCI7XG4gIGZvciAoaT0wOyBpPDEwOyBpKyspIHtcbiAgICBjb25zb2xlLmxvZygoaSsxKSArIFwiOiBcIiArIHZvY2FiX3NvdXJjZVt0b3BJbmRpY2VzW2ldXSk7XG4gICAgc3RyYnVpbGRlciArPSBcIiBcIiArIHZvY2FiX3NvdXJjZVt0b3BJbmRpY2VzW2ldXSArIFwiLFwiO1xuICB9XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJlZGljdGVkX3dvcmRzXCIpLmlubmVySFRNTCA9IHN0cmJ1aWxkZXIuc2xpY2UoMCwgLTEpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJlbmNobWFyayAoaW5kaWNlcywgYm93X3NvdXJjZSwgdm9jYWJfc291cmNlKSB7IC8vIG1heSBuZWVkIHRvIGFkanVzdFxuICB2YXIgbnVtX2luZGljZXMgPSBpbmRpY2VzLmxlbmd0aDtcbiAgdmFyIHZvY2FiX2ZyZXEgPSBib3dfc291cmNlW2luZGljZXNbMF1dO1xuICBmb3IgKGk9MTsgaSA8IG51bV9pbmRpY2VzOyBpKyspIHtcbiAgICB2b2NhYl9mcmVxID0gbWF0aC5hZGQodm9jYWJfZnJlcSwgYm93X3NvdXJjZVtpbmRpY2VzW2ldXSk7XG4gIH1cbiAgLy8gZ2V0IGluZGljZXMgb2YgMTAgZ3JlYXRlc3QgZWxlbWVudHNcbiAgdmFyIHRvcEluZGljZXMgPSBmaW5kSW5kaWNlc09mTWF4KHZvY2FiX2ZyZXEsIDEwKTtcbiAgY29uc29sZS5sb2coXCJNb3N0IGZyZXF1ZW50IHdvcmRzOlwiKTtcbiAgdmFyIHN0cmJ1aWxkZXIgPSBcIk1vc3QgZnJlcXVlbnQgd29yZHM6XCI7XG4gIGZvciAoaT0wOyBpPDEwOyBpKyspIHtcbiAgICBjb25zb2xlLmxvZygoaSsxKSArIFwiOiBcIiArIHZvY2FiX3NvdXJjZVt0b3BJbmRpY2VzW2ldXSk7XG4gICAgc3RyYnVpbGRlciArPSBcIiBcIiArIHZvY2FiX3NvdXJjZVt0b3BJbmRpY2VzW2ldXSArIFwiLFwiO1xuICB9XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJlcXVlbnRfd29yZHNcIikuaW5uZXJIVE1MID0gc3RyYnVpbGRlci5zbGljZSgwLCAtMSk7XG59O1xuXG4vLyBkaXNwbGF5cyB0aGUgc3VtbWFyeSBpbiB0YWJ1bGFyIGZvcm1cbmV4cG9ydCBmdW5jdGlvbiB0YWJ1bGF0ZSAoZGF0YV90YWIsIGNvbHVtbnMpIHtcbiAgbGV0IHRhYmxlID0gZDMuc2VsZWN0KFwiYm9keVwiKS5zZWxlY3QoJ2Rpdi5wbG90LW9wdGlvbnMtY29udGFpbmVyJykuYXBwZW5kKFwidGFibGVcIikuYXR0cihcImNsYXNzXCIsIFwic2VsZWN0M1wiKSxcbiAgICAgIHRoZWFkID0gdGFibGUuYXBwZW5kKFwidGhlYWRcIiksXG4gICAgICB0Ym9keSA9IHRhYmxlLmFwcGVuZChcInRib2R5XCIpO1xuXG4gIC8vIGFwcGVuZCB0aGUgaGVhZGVyIHJvd1xuICB0aGVhZC5hcHBlbmQoXCJ0clwiKVxuICAgICAgIC5zZWxlY3RBbGwoXCJ0aFwiKVxuICAgICAgIC5kYXRhKGNvbHVtbnMpXG4gICAgICAgLmVudGVyKClcbiAgICAgICAuYXBwZW5kKFwidGhcIilcbiAgICAgICAudGV4dCgoY29sdW1uKSA9PiAoY29sdW1uICkpO1xuXG4gIC8vIGNyZWF0ZSBhIHJvdyBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIGRhdGFcbiAgbGV0IHJvd3MgPSB0Ym9keS5zZWxlY3RBbGwoXCJ0clwiKVxuICAgICAgICAgICAgICAgICAgLmRhdGEoZGF0YV90YWIpXG4gICAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRyXCIpO1xuXG4gIC8vIGNyZWF0ZSBhIGNlbGwgaW4gZWFjaCByb3cgZm9yIGVhY2ggY29sdW1uXG4gIGxldCBjZWxscyA9IHJvd3Muc2VsZWN0QWxsKFwidGRcIilcbiAgICAgICAgICAgICAgICAgIC5kYXRhKChyb3cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInRkXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcInN0eWxlXCIsIFwiZm9udC1mYW1pbHk6IENvdXJpZXJcIikgLy8gc2V0cyB0aGUgZm9udCBzdHlsZVxuICAgICAgICAgICAgICAgICAgLmh0bWwoKGQpID0+ICggZC52YWx1ZSApICk7XG5cbiAgLypcbiAgICBjcm9zc2ZpbHRlciBkaW1lbnNpb25zIGFuZCBncm91cCBieVxuICAgIGh0dHA6Ly9hbmltYXRlZGRhdGEuY28udWsvYXJ0aWNsZXMvY3Jvc3NmaWx0ZXIvXG4gICovXG4gIGxldCBvdXRwdXQgPSBcIlwiO1xuICBsZXQgY2YgPSBjcm9zc2ZpbHRlcihkYXRhX3RhYik7XG4gIC8qIGNyb3NzZmlsdGVyIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHVwIHRvIDMyIGNvbHVtbnMpICovXG4gIGZvciAodmFyIGk9MDtpPGNvbHVtbnMubGVuZ3RoICYmIGk8MzI7aSsrKSB7XG4gICAgbGV0IGJ5UGFydHkgPSBjZi5kaW1lbnNpb24oKHBhcnR5KSA9PiAoIHBhcnR5W2NvbHVtbnNbaV1dICkpO1xuICAgIG91dHB1dCA9IG91dHB1dCArIFwiPGI+XCIgKyBjb2x1bW5zW2ldICsgXCI8L2I+XCIgKyBcIjxicj5cIjtcbiAgICB2YXIgZ3JvdXBCeVBhcnR5ID0gYnlQYXJ0eS5ncm91cCgpO1xuICAgIGdyb3VwQnlQYXJ0eS50b3AoNSkuZm9yRWFjaChmdW5jdGlvbihwLCBpKSB7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQgKyBwLmtleSArIFwiOiBcIiArIHAudmFsdWUgKyBcIjxicj5cIjtcbiAgICAgIGNvbnNvbGUubG9nKHAua2V5ICsgXCI6IFwiICsgcC52YWx1ZSk7XG4gICAgfSk7XG4gICAgb3V0cHV0ID0gb3V0cHV0ICsgXCI8YnI+XCI7XG4gIH1cbiAgLy8gc2lkZSB0YWJsZVxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlbW8zXCIpLmlubmVySFRNTCA9IG91dHB1dDtcbiAgcmV0dXJuIHRhYmxlO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/modules/table_creator.js\n");

/***/ }),

/***/ "./src/modules/tooltips.js":
/*!*********************************!*\
  !*** ./src/modules/tooltips.js ***!
  \*********************************/
/*! exports provided: tooltip, tooltip1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tooltip\", function() { return tooltip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tooltip1\", function() { return tooltip1; });\nlet tooltip = d3.select(\"body\")\n                       .append(\"div\")\n                       .attr(\"class\", \"tooltip\")\n                       .style(\"opacity\", 0);\n\nlet tooltip1 = d3.select(\"body\")\n                        .append(\"div\")\n                        .attr(\"class\", \"tooltip1\")\n                        .style(\"opacity\", 0);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy90b29sdGlwcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3Rvb2x0aXBzLmpzPzc1MDgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGxldCB0b29sdGlwID0gZDMuc2VsZWN0KFwiYm9keVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0b29sdGlwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cbmV4cG9ydCBsZXQgdG9vbHRpcDEgPSBkMy5zZWxlY3QoXCJib2R5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG9vbHRpcDFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/tooltips.js\n");

/***/ }),

/***/ "./src/modules/utilities.js":
/*!**********************************!*\
  !*** ./src/modules/utilities.js ***!
  \**********************************/
/*! exports provided: queryParams, searchDic, linSpace, printArray, transpar, dotSearchFilter, getParameterByName, xValue, yValue, xScale, yScale, xMap, yMap, xAxis, yAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"queryParams\", function() { return queryParams; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"searchDic\", function() { return searchDic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linSpace\", function() { return linSpace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"printArray\", function() { return printArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpar\", function() { return transpar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dotSearchFilter\", function() { return dotSearchFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getParameterByName\", function() { return getParameterByName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xValue\", function() { return xValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yValue\", function() { return yValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xScale\", function() { return xScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yScale\", function() { return yScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xMap\", function() { return xMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yMap\", function() { return yMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xAxis\", function() { return xAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yAxis\", function() { return yAxis; });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/modules/constants.js\");\n/* harmony import */ var _vendors_url_search_params_polyfill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vendors/url_search_params_polyfill.js */ \"./src/vendors/url_search_params_polyfill.js\");\n\n\n\n// Use native API or Polyfill for older browsers that don't support URLSearchParams API\nconst queryParams = (() => {\n  if ('URLSearchParams' in window) {\n    return new URLSearchParams(location.search)\n  } else {\n    return new _vendors_url_search_params_polyfill_js__WEBPACK_IMPORTED_MODULE_1__[\"URLSearchParamsPolyfill\"](location.search)\n  };\n})();\n\n// used to search a particular substring in the list of requested feature column\n// used to determine whether we should add allValues to selectedData, hence the t/f -> f/t\nfunction searchDic(selectedData, allValues) {\n  for(let i=0; i < selectedData.length; i++) {\n    if (JSON.stringify(allValues) === JSON.stringify(selectedData[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n\nfunction linSpace(start, end, n) {\n  var out = [];\n  var delta = (end - start) / (n - 1);\n  var i = 0;\n  while(i < (n - 1)) {\n    out.push(start + (i * delta));\n    i++;\n  }\n  out.push(end);\n  return out;\n};\n\n\n// VIEW HELPER: used to display the summary on the webpage\n// print all the key values pairs of a point\nfunction printArray(arr, d) {\n  var x = \"\";\n  for (var i=0; i < arr.length; i++) {\n    x = x + \"<b>\" + arr[i] + \"</b>: \" + d[arr[i]] + \"<br>\"\n  }\n  x = x + d.x + \"<br>\" + d[\"y\"];\n  return x;\n};\n\nfunction transpar (dot, valTransp, transparentColumn, valOpacityMatch, valOpacityNoMatch) {\n  let transparencyDisabled = valTransp === \"\" || typeof dot === 'undefined';\n  // the return value 1 means full opacity\n  if (transparencyDisabled) { return 1 };\n\n  let isMatch = ((dot, transparentColumn, valTransp) => {\n    let exactMatchEnabled = document.getElementsByClassName(\n      'transparency-exact-match'\n    )[0].checked;\n    if (exactMatchEnabled) { return dot[transparentColumn] === valTransp; }\n\n    let caseInsensitiveMatch = dot[transparentColumn].toLowerCase().indexOf(valTransp.toLowerCase()) > -1;\n    return (dot[transparentColumn] && caseInsensitiveMatch);\n  })(dot, transparentColumn, valTransp);\n\n  return isMatch ? parseFloat(valOpacityMatch) : parseFloat(valOpacityNoMatch);\n};\n\nfunction dotSearchFilter (dot, categorySearch, valSearch) {\n  // return value 1 means unmatched dots\n  // return value 2 means matched dots\n  if (typeof dot[categorySearch] == 'undefined' ) {\n    return 1;\n  }\n  // noMatch truthy if not found\n  let noMatch = ((dot, categorySearch, valSearch) => {\n    let exactMatchEnabled = document.getElementsByClassName(\n      'search-exact-match'\n    )[0].checked;\n    if (exactMatchEnabled) { return dot[categorySearch] !== valSearch; }\n\n    let caseInsensitiveMatch = dot[categorySearch].toLowerCase().indexOf(valSearch.toLowerCase()) < 0;\n    return caseInsensitiveMatch || valSearch.length === 0\n  })(dot, categorySearch, valSearch);\n\n  return noMatch ? 1 : 2;\n};\n\n// Checks the url query for name=value and extracts the value\n// *************************************************************\n// TODO: This can likely be accomplished using newer browser APIS, e.g.:\n// let queryParams = (new URL(location)).searchParams;\nfunction getParameterByName(name, url) {\n  if (!url) url = window.location.href;\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n  results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\n\n// The following two functions are getter methods:\n// value accessor - returns the value to encode for a given data object.\n// Type Signature: data Object -> value\nfunction xValue(data) { return data.x };\nfunction yValue(data) { return data[\"y\"] };\n\n// The following two functions map a value to a visual display encoding, such as\n// a pixel position.\n// Type Signature: Value -> display Object\nlet xScale = d3.scale.linear().range([0, _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"]]);\nlet yScale = d3.scale.linear().range([_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"], 0]);\n\n// The following two functions map from data Object to display value (? not sure\n// if value of object)\n// Type Signature: data Object -> display Object (? Might be value)\nfunction xMap(data) { return xScale(xValue(data)) };\nfunction yMap(data) { return yScale(yValue(data)) };\n\n// The following two variables are the X and Y axis objects\nlet xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\");\nlet yAxis = d3.svg.axis().scale(yScale).orient(\"left\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy91dGlsaXRpZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91dGlsaXRpZXMuanM/OTc2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoZWlnaHQsIG1hcmdpbiwgd2lkdGggfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBVUkxTZWFyY2hQYXJhbXNQb2x5ZmlsbCB9IGZyb20gJy4uL3ZlbmRvcnMvdXJsX3NlYXJjaF9wYXJhbXNfcG9seWZpbGwuanMnO1xuXG4vLyBVc2UgbmF0aXZlIEFQSSBvciBQb2x5ZmlsbCBmb3Igb2xkZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IFVSTFNlYXJjaFBhcmFtcyBBUElcbmV4cG9ydCBjb25zdCBxdWVyeVBhcmFtcyA9ICgoKSA9PiB7XG4gIGlmICgnVVJMU2VhcmNoUGFyYW1zJyBpbiB3aW5kb3cpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNQb2x5ZmlsbChsb2NhdGlvbi5zZWFyY2gpXG4gIH07XG59KSgpO1xuXG4vLyB1c2VkIHRvIHNlYXJjaCBhIHBhcnRpY3VsYXIgc3Vic3RyaW5nIGluIHRoZSBsaXN0IG9mIHJlcXVlc3RlZCBmZWF0dXJlIGNvbHVtblxuLy8gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBzaG91bGQgYWRkIGFsbFZhbHVlcyB0byBzZWxlY3RlZERhdGEsIGhlbmNlIHRoZSB0L2YgLT4gZi90XG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoRGljKHNlbGVjdGVkRGF0YSwgYWxsVmFsdWVzKSB7XG4gIGZvcihsZXQgaT0wOyBpIDwgc2VsZWN0ZWREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KGFsbFZhbHVlcykgPT09IEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkRGF0YVtpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbGluU3BhY2Uoc3RhcnQsIGVuZCwgbikge1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBkZWx0YSA9IChlbmQgLSBzdGFydCkgLyAobiAtIDEpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCAobiAtIDEpKSB7XG4gICAgb3V0LnB1c2goc3RhcnQgKyAoaSAqIGRlbHRhKSk7XG4gICAgaSsrO1xuICB9XG4gIG91dC5wdXNoKGVuZCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5cbi8vIFZJRVcgSEVMUEVSOiB1c2VkIHRvIGRpc3BsYXkgdGhlIHN1bW1hcnkgb24gdGhlIHdlYnBhZ2Vcbi8vIHByaW50IGFsbCB0aGUga2V5IHZhbHVlcyBwYWlycyBvZiBhIHBvaW50XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRBcnJheShhcnIsIGQpIHtcbiAgdmFyIHggPSBcIlwiO1xuICBmb3IgKHZhciBpPTA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICB4ID0geCArIFwiPGI+XCIgKyBhcnJbaV0gKyBcIjwvYj46IFwiICsgZFthcnJbaV1dICsgXCI8YnI+XCJcbiAgfVxuICB4ID0geCArIGQueCArIFwiPGJyPlwiICsgZFtcInlcIl07XG4gIHJldHVybiB4O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcGFyIChkb3QsIHZhbFRyYW5zcCwgdHJhbnNwYXJlbnRDb2x1bW4sIHZhbE9wYWNpdHlNYXRjaCwgdmFsT3BhY2l0eU5vTWF0Y2gpIHtcbiAgbGV0IHRyYW5zcGFyZW5jeURpc2FibGVkID0gdmFsVHJhbnNwID09PSBcIlwiIHx8IHR5cGVvZiBkb3QgPT09ICd1bmRlZmluZWQnO1xuICAvLyB0aGUgcmV0dXJuIHZhbHVlIDEgbWVhbnMgZnVsbCBvcGFjaXR5XG4gIGlmICh0cmFuc3BhcmVuY3lEaXNhYmxlZCkgeyByZXR1cm4gMSB9O1xuXG4gIGxldCBpc01hdGNoID0gKChkb3QsIHRyYW5zcGFyZW50Q29sdW1uLCB2YWxUcmFuc3ApID0+IHtcbiAgICBsZXQgZXhhY3RNYXRjaEVuYWJsZWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxuICAgICAgJ3RyYW5zcGFyZW5jeS1leGFjdC1tYXRjaCdcbiAgICApWzBdLmNoZWNrZWQ7XG4gICAgaWYgKGV4YWN0TWF0Y2hFbmFibGVkKSB7IHJldHVybiBkb3RbdHJhbnNwYXJlbnRDb2x1bW5dID09PSB2YWxUcmFuc3A7IH1cblxuICAgIGxldCBjYXNlSW5zZW5zaXRpdmVNYXRjaCA9IGRvdFt0cmFuc3BhcmVudENvbHVtbl0udG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbFRyYW5zcC50b0xvd2VyQ2FzZSgpKSA+IC0xO1xuICAgIHJldHVybiAoZG90W3RyYW5zcGFyZW50Q29sdW1uXSAmJiBjYXNlSW5zZW5zaXRpdmVNYXRjaCk7XG4gIH0pKGRvdCwgdHJhbnNwYXJlbnRDb2x1bW4sIHZhbFRyYW5zcCk7XG5cbiAgcmV0dXJuIGlzTWF0Y2ggPyBwYXJzZUZsb2F0KHZhbE9wYWNpdHlNYXRjaCkgOiBwYXJzZUZsb2F0KHZhbE9wYWNpdHlOb01hdGNoKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkb3RTZWFyY2hGaWx0ZXIgKGRvdCwgY2F0ZWdvcnlTZWFyY2gsIHZhbFNlYXJjaCkge1xuICAvLyByZXR1cm4gdmFsdWUgMSBtZWFucyB1bm1hdGNoZWQgZG90c1xuICAvLyByZXR1cm4gdmFsdWUgMiBtZWFucyBtYXRjaGVkIGRvdHNcbiAgaWYgKHR5cGVvZiBkb3RbY2F0ZWdvcnlTZWFyY2hdID09ICd1bmRlZmluZWQnICkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIC8vIG5vTWF0Y2ggdHJ1dGh5IGlmIG5vdCBmb3VuZFxuICBsZXQgbm9NYXRjaCA9ICgoZG90LCBjYXRlZ29yeVNlYXJjaCwgdmFsU2VhcmNoKSA9PiB7XG4gICAgbGV0IGV4YWN0TWF0Y2hFbmFibGVkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcbiAgICAgICdzZWFyY2gtZXhhY3QtbWF0Y2gnXG4gICAgKVswXS5jaGVja2VkO1xuICAgIGlmIChleGFjdE1hdGNoRW5hYmxlZCkgeyByZXR1cm4gZG90W2NhdGVnb3J5U2VhcmNoXSAhPT0gdmFsU2VhcmNoOyB9XG5cbiAgICBsZXQgY2FzZUluc2Vuc2l0aXZlTWF0Y2ggPSBkb3RbY2F0ZWdvcnlTZWFyY2hdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWxTZWFyY2gudG9Mb3dlckNhc2UoKSkgPCAwO1xuICAgIHJldHVybiBjYXNlSW5zZW5zaXRpdmVNYXRjaCB8fCB2YWxTZWFyY2gubGVuZ3RoID09PSAwXG4gIH0pKGRvdCwgY2F0ZWdvcnlTZWFyY2gsIHZhbFNlYXJjaCk7XG5cbiAgcmV0dXJuIG5vTWF0Y2ggPyAxIDogMjtcbn07XG5cbi8vIENoZWNrcyB0aGUgdXJsIHF1ZXJ5IGZvciBuYW1lPXZhbHVlIGFuZCBleHRyYWN0cyB0aGUgdmFsdWVcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIFRPRE86IFRoaXMgY2FuIGxpa2VseSBiZSBhY2NvbXBsaXNoZWQgdXNpbmcgbmV3ZXIgYnJvd3NlciBBUElTLCBlLmcuOlxuLy8gbGV0IHF1ZXJ5UGFyYW1zID0gKG5ldyBVUkwobG9jYXRpb24pKS5zZWFyY2hQYXJhbXM7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVyQnlOYW1lKG5hbWUsIHVybCkge1xuICBpZiAoIXVybCkgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtcXF1dL2csIFwiXFxcXCQmXCIpO1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiWz8mXVwiICsgbmFtZSArIFwiKD0oW14mI10qKXwmfCN8JClcIiksXG4gIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gIGlmICghcmVzdWx0cykgcmV0dXJuIG51bGw7XG4gIGlmICghcmVzdWx0c1syXSkgcmV0dXJuICcnO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMl0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgdHdvIGZ1bmN0aW9ucyBhcmUgZ2V0dGVyIG1ldGhvZHM6XG4vLyB2YWx1ZSBhY2Nlc3NvciAtIHJldHVybnMgdGhlIHZhbHVlIHRvIGVuY29kZSBmb3IgYSBnaXZlbiBkYXRhIG9iamVjdC5cbi8vIFR5cGUgU2lnbmF0dXJlOiBkYXRhIE9iamVjdCAtPiB2YWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHhWYWx1ZShkYXRhKSB7IHJldHVybiBkYXRhLnggfTtcbmV4cG9ydCBmdW5jdGlvbiB5VmFsdWUoZGF0YSkgeyByZXR1cm4gZGF0YVtcInlcIl0gfTtcblxuLy8gVGhlIGZvbGxvd2luZyB0d28gZnVuY3Rpb25zIG1hcCBhIHZhbHVlIHRvIGEgdmlzdWFsIGRpc3BsYXkgZW5jb2RpbmcsIHN1Y2ggYXNcbi8vIGEgcGl4ZWwgcG9zaXRpb24uXG4vLyBUeXBlIFNpZ25hdHVyZTogVmFsdWUgLT4gZGlzcGxheSBPYmplY3RcbmV4cG9ydCBsZXQgeFNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkucmFuZ2UoWzAsIHdpZHRoXSk7XG5leHBvcnQgbGV0IHlTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLnJhbmdlKFtoZWlnaHQsIDBdKTtcblxuLy8gVGhlIGZvbGxvd2luZyB0d28gZnVuY3Rpb25zIG1hcCBmcm9tIGRhdGEgT2JqZWN0IHRvIGRpc3BsYXkgdmFsdWUgKD8gbm90IHN1cmVcbi8vIGlmIHZhbHVlIG9mIG9iamVjdClcbi8vIFR5cGUgU2lnbmF0dXJlOiBkYXRhIE9iamVjdCAtPiBkaXNwbGF5IE9iamVjdCAoPyBNaWdodCBiZSB2YWx1ZSlcbmV4cG9ydCBmdW5jdGlvbiB4TWFwKGRhdGEpIHsgcmV0dXJuIHhTY2FsZSh4VmFsdWUoZGF0YSkpIH07XG5leHBvcnQgZnVuY3Rpb24geU1hcChkYXRhKSB7IHJldHVybiB5U2NhbGUoeVZhbHVlKGRhdGEpKSB9O1xuXG4vLyBUaGUgZm9sbG93aW5nIHR3byB2YXJpYWJsZXMgYXJlIHRoZSBYIGFuZCBZIGF4aXMgb2JqZWN0c1xuZXhwb3J0IGxldCB4QXhpcyA9IGQzLnN2Zy5heGlzKCkuc2NhbGUoeFNjYWxlKS5vcmllbnQoXCJib3R0b21cIik7XG5leHBvcnQgbGV0IHlBeGlzID0gZDMuc3ZnLmF4aXMoKS5zY2FsZSh5U2NhbGUpLm9yaWVudChcImxlZnRcIik7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/utilities.js\n");

/***/ }),

/***/ "./src/vendors/url_search_params_polyfill.js":
/*!***************************************************!*\
  !*** ./src/vendors/url_search_params_polyfill.js ***!
  \***************************************************/
/*! exports provided: URLSearchParamsPolyfill */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"URLSearchParamsPolyfill\", function() { return URLSearchParamsPolyfill; });\n// Credit to https://github.com/WebReflection\n// Full repo found here: https://github.com/WebReflection/url-search-params\n// Accessed April 28 2018\n\n\n\nfunction URLSearchParamsPolyfill(query) {\n  var\n    index, key, value,\n    pairs, i, length,\n    dict = Object.create(null)\n  ;\n  this[secret] = dict;\n  if (!query) return;\n  if (typeof query === 'string') {\n    if (query.charAt(0) === '?') {\n      query = query.slice(1);\n    }\n    for (\n      pairs = query.split('&'),\n      i = 0,\n      length = pairs.length; i < length; i++\n    ) {\n      value = pairs[i];\n      index = value.indexOf('=');\n      if (-1 < index) {\n        appendTo(\n          dict,\n          decode(value.slice(0, index)),\n          decode(value.slice(index + 1))\n        );\n      } else if (value.length){\n        appendTo(\n          dict,\n          decode(value),\n          ''\n        );\n      }\n    }\n  } else {\n    if (isArray(query)) {\n      for (\n        i = 0,\n        length = query.length; i < length; i++\n      ) {\n        value = query[i];\n        appendTo(dict, value[0], value[1]);\n      }\n    } else {\n      for (key in query) {\n         appendTo(dict, key, query[key]);\n      }\n    }\n  }\n}\n\nvar\n  isArray = Array.isArray,\n  URLSearchParamsProto = URLSearchParamsPolyfill.prototype,\n  find = /[!'\\(\\)~]|%20|%00/g,\n  plus = /\\+/g,\n  replace = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  },\n  replacer = function (match) {\n    return replace[match];\n  },\n  secret = '__URLSearchParams__:' + Math.random()\n;\n\nfunction appendTo(dict, name, value) {\n  if (name in dict) {\n    dict[name].push('' + value);\n  } else {\n    dict[name] = isArray(value) ? value : ['' + value];\n  }\n}\n\nfunction decode(str) {\n  return decodeURIComponent(str.replace(plus, ' '));\n}\n\nfunction encode(str) {\n  return encodeURIComponent(str).replace(find, replacer);\n}\n\nURLSearchParamsProto.append = function append(name, value) {\n  appendTo(this[secret], name, value);\n};\n\nURLSearchParamsProto.delete = function del(name) {\n  delete this[secret][name];\n};\n\nURLSearchParamsProto.get = function get(name) {\n  var dict = this[secret];\n  return name in dict ? dict[name][0] : null;\n};\n\nURLSearchParamsProto.getAll = function getAll(name) {\n  var dict = this[secret];\n  return name in dict ? dict[name].slice(0) : [];\n};\n\nURLSearchParamsProto.has = function has(name) {\n  return name in this[secret];\n};\n\nURLSearchParamsProto.set = function set(name, value) {\n  this[secret][name] = ['' + value];\n};\n\nURLSearchParamsProto.forEach = function forEach(callback, thisArg) {\n  var dict = this[secret];\n  Object.getOwnPropertyNames(dict).forEach(function(name) {\n    dict[name].forEach(function(value) {\n      callback.call(thisArg, value, name, this);\n    }, this);\n  }, this);\n};\n\n/*\nURLSearchParamsProto.toBody = function() {\n  return new Blob(\n    [this.toString()],\n    {type: 'application/x-www-form-urlencoded'}\n  );\n};\n*/\n\nURLSearchParamsProto.toJSON = function toJSON() {\n  return {};\n};\n\nURLSearchParamsProto.toString = function toString() {\n  var dict = this[secret], query = [], i, key, name, value;\n  for (key in dict) {\n    name = encode(key);\n    for (\n      i = 0,\n      value = dict[key];\n      i < value.length; i++\n    ) {\n      query.push(name + '=' + encode(value[i]));\n    }\n  }\n  return query.join('&');\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9ycy91cmxfc2VhcmNoX3BhcmFtc19wb2x5ZmlsbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy92ZW5kb3JzL3VybF9zZWFyY2hfcGFyYW1zX3BvbHlmaWxsLmpzPzUyNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3JlZGl0IHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uXG4vLyBGdWxsIHJlcG8gZm91bmQgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vdXJsLXNlYXJjaC1wYXJhbXNcbi8vIEFjY2Vzc2VkIEFwcmlsIDI4IDIwMThcblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gVVJMU2VhcmNoUGFyYW1zUG9seWZpbGwocXVlcnkpIHtcbiAgdmFyXG4gICAgaW5kZXgsIGtleSwgdmFsdWUsXG4gICAgcGFpcnMsIGksIGxlbmd0aCxcbiAgICBkaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICA7XG4gIHRoaXNbc2VjcmV0XSA9IGRpY3Q7XG4gIGlmICghcXVlcnkpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAocXVlcnkuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuc2xpY2UoMSk7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICBwYWlycyA9IHF1ZXJ5LnNwbGl0KCcmJyksXG4gICAgICBpID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrXG4gICAgKSB7XG4gICAgICB2YWx1ZSA9IHBhaXJzW2ldO1xuICAgICAgaW5kZXggPSB2YWx1ZS5pbmRleE9mKCc9Jyk7XG4gICAgICBpZiAoLTEgPCBpbmRleCkge1xuICAgICAgICBhcHBlbmRUbyhcbiAgICAgICAgICBkaWN0LFxuICAgICAgICAgIGRlY29kZSh2YWx1ZS5zbGljZSgwLCBpbmRleCkpLFxuICAgICAgICAgIGRlY29kZSh2YWx1ZS5zbGljZShpbmRleCArIDEpKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGgpe1xuICAgICAgICBhcHBlbmRUbyhcbiAgICAgICAgICBkaWN0LFxuICAgICAgICAgIGRlY29kZSh2YWx1ZSksXG4gICAgICAgICAgJydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQXJyYXkocXVlcnkpKSB7XG4gICAgICBmb3IgKFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuZ3RoID0gcXVlcnkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKytcbiAgICAgICkge1xuICAgICAgICB2YWx1ZSA9IHF1ZXJ5W2ldO1xuICAgICAgICBhcHBlbmRUbyhkaWN0LCB2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGtleSBpbiBxdWVyeSkge1xuICAgICAgICAgYXBwZW5kVG8oZGljdCwga2V5LCBxdWVyeVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyXG4gIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICBVUkxTZWFyY2hQYXJhbXNQcm90byA9IFVSTFNlYXJjaFBhcmFtc1BvbHlmaWxsLnByb3RvdHlwZSxcbiAgZmluZCA9IC9bISdcXChcXCl+XXwlMjB8JTAwL2csXG4gIHBsdXMgPSAvXFwrL2csXG4gIHJlcGxhY2UgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9LFxuICByZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiByZXBsYWNlW21hdGNoXTtcbiAgfSxcbiAgc2VjcmV0ID0gJ19fVVJMU2VhcmNoUGFyYW1zX186JyArIE1hdGgucmFuZG9tKClcbjtcblxuZnVuY3Rpb24gYXBwZW5kVG8oZGljdCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKG5hbWUgaW4gZGljdCkge1xuICAgIGRpY3RbbmFtZV0ucHVzaCgnJyArIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBkaWN0W25hbWVdID0gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFsnJyArIHZhbHVlXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UocGx1cywgJyAnKSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoZmluZCwgcmVwbGFjZXIpO1xufVxuXG5VUkxTZWFyY2hQYXJhbXNQcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgYXBwZW5kVG8odGhpc1tzZWNyZXRdLCBuYW1lLCB2YWx1ZSk7XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNQcm90by5kZWxldGUgPSBmdW5jdGlvbiBkZWwobmFtZSkge1xuICBkZWxldGUgdGhpc1tzZWNyZXRdW25hbWVdO1xufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgdmFyIGRpY3QgPSB0aGlzW3NlY3JldF07XG4gIHJldHVybiBuYW1lIGluIGRpY3QgPyBkaWN0W25hbWVdWzBdIDogbnVsbDtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmdldEFsbCA9IGZ1bmN0aW9uIGdldEFsbChuYW1lKSB7XG4gIHZhciBkaWN0ID0gdGhpc1tzZWNyZXRdO1xuICByZXR1cm4gbmFtZSBpbiBkaWN0ID8gZGljdFtuYW1lXS5zbGljZSgwKSA6IFtdO1xufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgaW4gdGhpc1tzZWNyZXRdO1xufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gIHRoaXNbc2VjcmV0XVtuYW1lXSA9IFsnJyArIHZhbHVlXTtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIHZhciBkaWN0ID0gdGhpc1tzZWNyZXRdO1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkaWN0KS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkaWN0W25hbWVdLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgIH0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbn07XG5cbi8qXG5VUkxTZWFyY2hQYXJhbXNQcm90by50b0JvZHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBCbG9iKFxuICAgIFt0aGlzLnRvU3RyaW5nKCldLFxuICAgIHt0eXBlOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ31cbiAgKTtcbn07XG4qL1xuXG5VUkxTZWFyY2hQYXJhbXNQcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIHJldHVybiB7fTtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHZhciBkaWN0ID0gdGhpc1tzZWNyZXRdLCBxdWVyeSA9IFtdLCBpLCBrZXksIG5hbWUsIHZhbHVlO1xuICBmb3IgKGtleSBpbiBkaWN0KSB7XG4gICAgbmFtZSA9IGVuY29kZShrZXkpO1xuICAgIGZvciAoXG4gICAgICBpID0gMCxcbiAgICAgIHZhbHVlID0gZGljdFtrZXldO1xuICAgICAgaSA8IHZhbHVlLmxlbmd0aDsgaSsrXG4gICAgKSB7XG4gICAgICBxdWVyeS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGUodmFsdWVbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5LmpvaW4oJyYnKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/vendors/url_search_params_polyfill.js\n");

/***/ })

/******/ });